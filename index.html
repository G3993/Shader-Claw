<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>ShaderClaw</title>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/codemirror.min.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/theme/material-darker.min.css">
<style>
:root {
  --bg: #09090f;
  --panel: #111119;
  --panel-alt: #16161f;
  --border: #1e1e2e;
  --text: #c8c8d4;
  --text-dim: #666680;
  --accent: #e63946;
  --accent-dim: #e6394622;
  --green: #4ecdc4;
  --font: 'SF Mono', 'Cascadia Code', 'Fira Code', 'Consolas', monospace;
}

* { margin: 0; padding: 0; box-sizing: border-box; }

body {
  font-family: var(--font);
  background: var(--bg);
  color: var(--text);
  height: 100vh;
  overflow: hidden;
}

#app {
  display: grid;
  grid-template-columns: 1fr 260px;
  height: 100vh;
}

/* ===== SIDEBAR ===== */
#sidebar {
  background: var(--panel);
  border-left: 1px solid var(--border);
  border-right: none;
  display: flex;
  flex-direction: column;
  overflow: hidden;
  order: 2;
}

.brand {
  padding: 16px;
  font-size: 15px;
  font-weight: 700;
  letter-spacing: 1px;
  border-bottom: 1px solid var(--border);
  display: flex;
  align-items: center;
  gap: 10px;
}

.brand .logo-wrap {
  position: relative;
  width: 28px;
  height: 28px;
  flex-shrink: 0;
}

.brand .claw-marks {
  filter: drop-shadow(0 0 4px var(--accent));
  animation: clawPulse 2s ease-in-out infinite;
}

@keyframes clawPulse {
  0%, 100% { filter: drop-shadow(0 0 3px var(--accent)) drop-shadow(0 0 8px var(--accent)); opacity: 0.85; }
  50% { filter: drop-shadow(0 0 6px var(--accent)) drop-shadow(0 0 16px var(--accent)) drop-shadow(0 0 24px #ff2040); opacity: 1; }
}

.brand .brand-text { display: flex; align-items: center; gap: 6px; }
.brand .brand-text span { color: var(--accent); }

.status-light {
  width: 6px;
  height: 6px;
  border-radius: 50%;
  background: var(--accent);
  flex-shrink: 0;
  transition: opacity 0.3s;
}

.status-light.connected {
  animation: statusPulse 2s ease-in-out infinite;
}

.status-light.disconnected {
  opacity: 0.15;
  animation: none;
}

@keyframes statusPulse {
  0%, 100% { opacity: 0.4; box-shadow: 0 0 2px var(--accent); }
  50% { opacity: 1; box-shadow: 0 0 6px var(--accent), 0 0 12px var(--accent); }
}

#shader-list {
  flex: 1;
  overflow-y: auto;
  padding: 8px;
}

#shader-list::-webkit-scrollbar { width: 4px; }
#shader-list::-webkit-scrollbar-thumb { background: var(--border); border-radius: 2px; }

.shader-item {
  padding: 8px 10px;
  border-radius: 4px;
  cursor: pointer;
  font-size: 12px;
  display: flex;
  justify-content: space-between;
  align-items: center;
  transition: background 0.15s;
}

.shader-item:hover { background: var(--panel-alt); }
.shader-item.active { background: var(--accent-dim); border-left: 2px solid var(--accent); }

.shader-item .name {
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
  flex: 1;
}


/* ===== MAIN PANEL ===== */
#main {
  display: flex;
  flex-direction: column;
  overflow: hidden;
  position: relative;
  order: 1;
}

#preview {
  position: relative;
  flex: 1;
  background: #000;
}

#gl-canvas, #three-canvas {
  width: 100%;
  height: 100%;
  display: block;
  position: absolute;
  top: 0;
  left: 0;
}

#three-canvas { display: none; }

.canvas-controls {
  position: absolute;
  top: 8px;
  right: 8px;
  display: flex;
  gap: 4px;
}

.canvas-btn {
  background: #000000aa;
  border: 1px solid var(--border);
  color: var(--text);
  width: 28px;
  height: 28px;
  border-radius: 4px;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 14px;
  transition: background 0.15s;
}

.canvas-btn:hover { background: #000000dd; }

#error-bar {
  position: absolute;
  bottom: 0;
  left: 0;
  right: 0;
  background: #e6394620;
  border-top: 1px solid var(--accent);
  color: var(--accent);
  font-size: 11px;
  padding: 6px 12px;
  display: none;
  max-height: 80px;
  overflow-y: auto;
  white-space: pre-wrap;
  font-family: var(--font);
}

#error-bar.show { display: block; }

/* ===== FLOATING PARAMS PANEL ===== */
#params-panel {
  position: absolute;
  top: 12px;
  left: 12px;
  z-index: 100;
  min-width: 260px;
  max-width: 360px;
  background: rgba(17, 17, 25, 0.92);
  backdrop-filter: blur(12px);
  -webkit-backdrop-filter: blur(12px);
  border: 1px solid var(--border);
  border-radius: 8px;
  box-shadow: 0 8px 32px rgba(0,0,0,0.5);
  display: none;
  overflow: hidden;
  transition: opacity 0.2s;
}

#params-panel.visible { display: block; }

#params-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 8px 12px;
  cursor: grab;
  user-select: none;
  border-bottom: 1px solid var(--border);
  background: rgba(22, 22, 31, 0.6);
}

#params-header:active { cursor: grabbing; }

#params-header .title {
  font-size: 10px;
  font-weight: 600;
  letter-spacing: 1px;
  color: var(--text-dim);
  text-transform: uppercase;
}

#params-header .actions {
  display: flex;
  gap: 4px;
}

.params-btn {
  background: none;
  border: none;
  color: var(--text-dim);
  cursor: pointer;
  font-size: 13px;
  width: 20px;
  height: 20px;
  display: flex;
  align-items: center;
  justify-content: center;
  border-radius: 3px;
  transition: color 0.15s, background 0.15s;
}

.params-btn:hover { color: var(--text); background: rgba(255,255,255,0.05); }

#params-body {
  padding: 10px 12px;
  max-height: 70vh;
  overflow-y: auto;
}

#params-body::-webkit-scrollbar { width: 4px; }
#params-body::-webkit-scrollbar-thumb { background: var(--border); border-radius: 2px; }

#params-body.collapsed {
  max-height: 0;
  padding: 0 12px;
  overflow: hidden;
}

.control-row {
  display: flex;
  align-items: center;
  gap: 8px;
  margin-bottom: 8px;
  font-size: 11px;
}

.control-row:last-child { margin-bottom: 0; }

.control-row label {
  width: 80px;
  flex-shrink: 0;
  color: var(--text-dim);
  text-overflow: ellipsis;
  overflow: hidden;
  white-space: nowrap;
  font-size: 10px;
}

.control-row input[type="range"] {
  flex: 1;
  accent-color: var(--accent);
  height: 3px;
}

.control-row input[type="color"] {
  width: 28px;
  height: 22px;
  border: 1px solid var(--border);
  border-radius: 3px;
  background: none;
  cursor: pointer;
  padding: 0;
}

.control-row select {
  flex: 1;
  background: var(--bg);
  color: var(--text);
  border: 1px solid var(--border);
  border-radius: 3px;
  padding: 2px 4px;
  font-size: 11px;
  font-family: inherit;
  cursor: pointer;
  max-width: 120px;
}

.control-row input[type="text"] {
  flex: 1;
  background: var(--bg);
  color: var(--text);
  border: 1px solid var(--border);
  border-radius: 3px;
  padding: 3px 6px;
  font-size: 12px;
  font-family: monospace;
  letter-spacing: 1px;
  text-transform: uppercase;
  max-width: 160px;
}

.control-row .val {
  width: 44px;
  text-align: right;
  color: var(--text-dim);
  font-size: 10px;
  font-variant-numeric: tabular-nums;
}

.no-params {
  color: var(--text-dim);
  font-size: 11px;
  text-align: center;
  padding: 8px 0;
}

/* ===== SECTION HEADERS ===== */
.section-header {
  font-size: 9px;
  font-weight: 700;
  letter-spacing: 1.5px;
  color: var(--text-dim);
  text-transform: uppercase;
  padding: 12px 10px 4px;
}

.section-header:first-child { padding-top: 4px; }

.section-header-row {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 12px 10px 4px;
}

.section-header-row .section-header {
  padding: 0;
}

.section-add-btn {
  background: none;
  border: 1px solid var(--border);
  color: var(--text-dim);
  width: 18px;
  height: 18px;
  border-radius: 3px;
  cursor: pointer;
  font-size: 12px;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: color 0.15s, border-color 0.15s;
  line-height: 1;
}

.section-add-btn:hover {
  color: var(--text);
  border-color: var(--text-dim);
}

.media-item {
  padding: 6px 10px;
  border-radius: 4px;
  cursor: pointer;
  font-size: 11px;
  display: flex;
  align-items: center;
  gap: 6px;
  transition: background 0.15s;
}

.media-item:hover { background: var(--panel-alt); }

.media-item .media-icon {
  font-size: 12px;
  flex-shrink: 0;
  width: 16px;
  text-align: center;
}

.media-item .media-name {
  flex: 1;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
  color: var(--text);
}

.media-item .media-delete {
  background: none;
  border: none;
  color: var(--text-dim);
  cursor: pointer;
  font-size: 11px;
  padding: 0 2px;
  opacity: 0;
  transition: opacity 0.15s, color 0.15s;
}

.media-item:hover .media-delete { opacity: 1; }
.media-item .media-delete:hover { color: var(--accent); }

#media-file-input { display: none; }

/* Editor — hidden, kept functional for MCP */
#editor-area {
  display: none;
}

/* Scrollbar global */
::-webkit-scrollbar { width: 6px; }
::-webkit-scrollbar-track { background: transparent; }
::-webkit-scrollbar-thumb { background: var(--border); border-radius: 3px; }
</style>
</head>
<body>

<div id="app">
  <!-- SIDEBAR -->
  <div id="sidebar">
    <div class="brand">
      <div class="logo-wrap">
        <svg class="claw-marks" width="28" height="28" viewBox="0 0 28 28" fill="none" stroke="#e63946" stroke-width="2.5" stroke-linecap="round">
          <path d="M7 3 L5 14 L8 24"/>
          <path d="M14 2 L14 14 L14 25"/>
          <path d="M21 3 L23 14 L20 24"/>
        </svg>
      </div>
      <div class="brand-text">SHADER<span>CLAW</span></div>
      <div class="status-light disconnected" id="status-light"></div>
    </div>
    <div id="shader-list"></div>
    <input type="file" id="media-file-input" accept="image/*,video/*,.glb,.gltf" multiple>
  </div>

  <!-- MAIN -->
  <div id="main">
    <div id="preview">
      <canvas id="gl-canvas"></canvas>
      <canvas id="three-canvas"></canvas>
      <div class="canvas-controls">
        <button class="canvas-btn" id="params-toggle-btn" title="Toggle Parameters">&#x2699;</button>
        <button class="canvas-btn" id="play-btn" title="Play/Pause">&#9654;</button>
        <button class="canvas-btn" id="fs-btn" title="Fullscreen">&#x26F6;</button>
        <button class="canvas-btn" id="copy-btn" title="Copy Shader">&#x2398;</button>
        <button class="canvas-btn" id="download-btn" title="Save .fs">&#x2B73;</button>
      </div>
      <div id="error-bar"></div>

      <!-- Floating parameter panel -->
      <div id="params-panel">
        <div id="params-header">
          <span class="title">Parameters</span>
          <div class="actions">
            <button class="params-btn" id="params-collapse" title="Collapse">&#x25B2;</button>
            <button class="params-btn" id="params-close" title="Close">&#x2715;</button>
          </div>
        </div>
        <div id="params-body"></div>
      </div>
    </div>

    <div id="editor-area">
      <div id="editor-toolbar">
        <button id="compile-btn">Compile</button>
        <label id="auto-compile-label"><input type="checkbox" id="auto-compile" checked> Auto</label>
        <div class="spacer"></div>
        <button id="new-btn">New</button>
        <button id="download-btn">Save .fs</button>
      </div>
      <div id="editor-wrap"><textarea id="code"></textarea></div>
    </div>
  </div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/codemirror.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/mode/clike/clike.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/addon/edit/matchbrackets.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/addon/edit/closebrackets.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
<script>
// ============================================================
// ShaderClaw — ISF Shader Builder
// ============================================================

const DEFAULT_SHADER = `/*{
  "DESCRIPTION": "ShaderClaw default — radial pulse",
  "CATEGORIES": ["Generator"],
  "INPUTS": [
    { "NAME": "speed", "TYPE": "float", "DEFAULT": 1.0, "MIN": 0.0, "MAX": 5.0 },
    { "NAME": "rings", "TYPE": "float", "DEFAULT": 10.0, "MIN": 1.0, "MAX": 40.0 },
    { "NAME": "color1", "TYPE": "color", "DEFAULT": [0.9, 0.15, 0.2, 1.0] },
    { "NAME": "color2", "TYPE": "color", "DEFAULT": [0.06, 0.06, 0.12, 1.0] }
  ]
}*/

void main() {
    vec2 uv = isf_FragNormCoord - 0.5;
    float d = length(uv);
    float wave = sin(d * rings - TIME * speed) * 0.5 + 0.5;
    wave *= smoothstep(0.5, 0.1, d);
    gl_FragColor = mix(color2, color1, wave);
}`;

// ============================================================
// ISF Parser
// ============================================================

function parseISF(source) {
  const match = source.match(/\/\*\s*(\{[\s\S]*?\})\s*\*\//);
  if (!match) return { meta: null, glsl: source.trim(), inputs: [] };
  try {
    const meta = JSON.parse(match[1]);
    const glsl = source.slice(source.indexOf(match[0]) + match[0].length).trim();
    return { meta, glsl, inputs: meta.INPUTS || [] };
  } catch (e) {
    return { meta: null, glsl: source.trim(), inputs: [] };
  }
}

function isfInputToUniform(input) {
  const t = input.TYPE;
  if (t === 'float') return `uniform float ${input.NAME};`;
  if (t === 'color') return `uniform vec4 ${input.NAME};`;
  if (t === 'bool') return `uniform bool ${input.NAME};`;
  if (t === 'point2D') return `uniform vec2 ${input.NAME};`;
  if (t === 'image') return `uniform sampler2D ${input.NAME};`;
  if (t === 'long') return `uniform float ${input.NAME};`;
  if (t === 'text') {
    const maxLen = input.MAX_LENGTH || 12;
    const lines = [];
    for (let i = 0; i < maxLen; i++) lines.push(`uniform float ${input.NAME}_${i};`);
    lines.push(`uniform float ${input.NAME}_len;`);
    return lines.join('\n');
  }
  return `// unknown type: ${t} ${input.NAME}`;
}

function buildFragmentShader(source) {
  const parsed = parseISF(source);
  const uniformLines = (parsed.inputs || []).map(isfInputToUniform);

  const header = [
    'precision highp float;',
    'uniform float TIME;',
    'uniform vec2 RENDERSIZE;',
    'uniform int PASSINDEX;',
    'uniform int FRAMEINDEX;',
    'varying vec2 isf_FragNormCoord;',
    '#define IMG_NORM_PIXEL(img, coord) texture2D(img, coord)',
    '#define IMG_PIXEL(img, coord) texture2D(img, coord / RENDERSIZE)',
    ...uniformLines,
    ''
  ].join('\n');

  const cleaned = parsed.glsl.replace(/#version\s+\d+.*/g, '');
  return { frag: header + cleaned, parsed };
}

const VERT_SHADER = `
attribute vec2 position;
varying vec2 isf_FragNormCoord;
void main() {
    isf_FragNormCoord = position * 0.5 + 0.5;
    gl_Position = vec4(position, 0.0, 1.0);
}`;

// ============================================================
// Media Inputs Store
// ============================================================

const mediaInputs = [];
let mediaIdCounter = 0;

function detectMediaType(file) {
  const ext = file.name.split('.').pop().toLowerCase();
  if (['glb', 'gltf'].includes(ext)) return 'model';
  if (file.type.startsWith('video/')) return 'video';
  return 'image';
}

function mediaTypeIcon(type) {
  if (type === 'video') return '\u{1F3AC}';
  if (type === 'model') return '\u{1F9CA}';
  return '\u{1F5BC}';
}

function createGLTexture(gl, source) {
  const tex = gl.createTexture();
  gl.bindTexture(gl.TEXTURE_2D, tex);
  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, source);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
  gl.bindTexture(gl.TEXTURE_2D, null);
  return tex;
}

// ============================================================
// WebGL Renderer
// ============================================================

class Renderer {
  constructor(canvas) {
    this.canvas = canvas;
    this.gl = canvas.getContext('webgl', { antialias: false, preserveDrawingBuffer: true });
    if (!this.gl) throw new Error('WebGL not supported');
    this.program = null;
    this.uniformLocs = {};
    this.inputValues = {};
    this.startTime = performance.now();
    this.frameIndex = 0;
    this.playing = true;
    this.animId = null;
    this.textures = {}; // name → { glTexture, isVideo, element }
    this._initGeometry();
    this.resize();
    window.addEventListener('resize', () => this.resize());
  }

  _initGeometry() {
    const gl = this.gl;
    const buf = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, buf);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1,-1, 3,-1, -1,3]), gl.STATIC_DRAW);
    this.posBuf = buf;
  }

  resize() {
    // Fixed 1920x1080 render resolution — CSS handles display scaling
    this.canvas.width = 1920;
    this.canvas.height = 1080;
    this.gl.viewport(0, 0, 1920, 1080);
  }

  compile(vertSrc, fragSrc) {
    const gl = this.gl;
    const vs = this._compileShader(gl.VERTEX_SHADER, vertSrc);
    if (!vs.shader) return { ok: false, errors: 'Vertex: ' + vs.log };

    const fs = this._compileShader(gl.FRAGMENT_SHADER, fragSrc);
    if (!fs.shader) {
      gl.deleteShader(vs.shader);
      return { ok: false, errors: this._prettyErrors(fs.log) };
    }

    const prog = gl.createProgram();
    gl.attachShader(prog, vs.shader);
    gl.attachShader(prog, fs.shader);
    gl.bindAttribLocation(prog, 0, 'position');
    gl.linkProgram(prog);

    gl.deleteShader(vs.shader);
    gl.deleteShader(fs.shader);

    if (!gl.getProgramParameter(prog, gl.LINK_STATUS)) {
      const log = gl.getProgramInfoLog(prog);
      gl.deleteProgram(prog);
      return { ok: false, errors: 'Link: ' + log };
    }

    if (this.program) gl.deleteProgram(this.program);
    this.program = prog;
    this.uniformLocs = {};
    return { ok: true, errors: null };
  }

  _compileShader(type, src) {
    const gl = this.gl;
    const s = gl.createShader(type);
    gl.shaderSource(s, src);
    gl.compileShader(s);
    if (!gl.getShaderParameter(s, gl.COMPILE_STATUS)) {
      const log = gl.getShaderInfoLog(s);
      gl.deleteShader(s);
      return { shader: null, log };
    }
    return { shader: s, log: null };
  }

  _prettyErrors(log) {
    if (!log) return '';
    const headerLines = 9;
    return log.replace(/ERROR:\s*\d+:(\d+)/g, (m, line) => {
      const adjusted = Math.max(1, parseInt(line) - headerLines);
      return `Line ${adjusted}`;
    });
  }

  _getLoc(name) {
    if (!(name in this.uniformLocs)) {
      this.uniformLocs[name] = this.gl.getUniformLocation(this.program, name);
    }
    return this.uniformLocs[name];
  }

  render() {
    const gl = this.gl;
    if (!this.program) return;

    gl.useProgram(this.program);

    const elapsed = (performance.now() - this.startTime) / 1000;
    const timeLoc = this._getLoc('TIME');
    if (timeLoc) gl.uniform1f(timeLoc, elapsed);

    const resLoc = this._getLoc('RENDERSIZE');
    if (resLoc) gl.uniform2f(resLoc, this.canvas.width, this.canvas.height);

    const piLoc = this._getLoc('PASSINDEX');
    if (piLoc) gl.uniform1i(piLoc, 0);

    const fiLoc = this._getLoc('FRAMEINDEX');
    if (fiLoc) gl.uniform1i(fiLoc, this.frameIndex);

    for (const [name, val] of Object.entries(this.inputValues)) {
      const loc = this._getLoc(name);
      if (!loc) continue;
      if (typeof val === 'number') gl.uniform1f(loc, val);
      else if (typeof val === 'boolean') gl.uniform1i(loc, val ? 1 : 0);
      else if (Array.isArray(val)) {
        if (val.length === 2) gl.uniform2f(loc, val[0], val[1]);
        else if (val.length === 4) gl.uniform4f(loc, val[0], val[1], val[2], val[3]);
      }
    }

    // Bind textures
    let texUnit = 0;
    for (const [name, tex] of Object.entries(this.textures)) {
      gl.activeTexture(gl.TEXTURE0 + texUnit);
      gl.bindTexture(gl.TEXTURE_2D, tex.glTexture);
      if (tex.isVideo && tex.element && tex.element.readyState >= 2) {
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, tex.element);
      }
      gl.uniform1i(this._getLoc(name), texUnit);
      texUnit++;
    }

    gl.bindBuffer(gl.ARRAY_BUFFER, this.posBuf);
    gl.enableVertexAttribArray(0);
    gl.vertexAttribPointer(0, 2, gl.FLOAT, false, 0, 0);
    gl.drawArrays(gl.TRIANGLES, 0, 3);

    this.frameIndex++;
  }

  start() {
    this.playing = true;
    const loop = () => {
      if (!this.playing) return;
      this.render();
      this.animId = requestAnimationFrame(loop);
    };
    loop();
  }

  stop() {
    this.playing = false;
    if (this.animId) cancelAnimationFrame(this.animId);
  }

  togglePlay() {
    if (this.playing) this.stop();
    else this.start();
    return this.playing;
  }

  resetTime() {
    this.startTime = performance.now();
    this.frameIndex = 0;
  }
}

// ============================================================
// Three.js Scene Renderer
// ============================================================

class SceneRenderer {
  constructor(canvas) {
    this.canvas = canvas;
    this.renderer = null;
    this.sceneDef = null;
    this.playing = false;
    this.animId = null;
    this.startTime = performance.now();
    this.inputValues = {};
    this.inputs = [];
    this.media = []; // { name, type, threeTexture, threeModel }
  }

  load(sceneDef) {
    this.cleanup();
    this.renderer = new THREE.WebGLRenderer({ canvas: this.canvas, antialias: true, preserveDrawingBuffer: true });
    this.renderer.setPixelRatio(window.devicePixelRatio);
    this.resize();
    this.sceneDef = sceneDef.create(this.renderer, this.canvas, this.media);
    this.inputs = sceneDef.INPUTS || [];
    this.startTime = performance.now();
  }

  render() {
    if (!this.sceneDef || !this.renderer) return;
    const elapsed = (performance.now() - this.startTime) / 1000;
    this.sceneDef.update(elapsed, this.inputValues);
    this.renderer.render(this.sceneDef.scene, this.sceneDef.camera);
  }

  start() {
    this.playing = true;
    const loop = () => {
      if (!this.playing) return;
      this.render();
      this.animId = requestAnimationFrame(loop);
    };
    loop();
  }

  stop() {
    this.playing = false;
    if (this.animId) cancelAnimationFrame(this.animId);
  }

  togglePlay() {
    if (this.playing) this.stop();
    else this.start();
    return this.playing;
  }

  resize() {
    if (!this.renderer) return;
    const parent = this.canvas.parentElement;
    const w = parent.clientWidth;
    const h = parent.clientHeight;
    this.renderer.setSize(w, h, false);
    this.canvas.style.width = w + 'px';
    this.canvas.style.height = h + 'px';
    if (this.sceneDef && this.sceneDef.resize) {
      this.sceneDef.resize(w, h);
    }
  }

  cleanup() {
    this.stop();
    if (this.sceneDef && this.sceneDef.dispose) {
      this.sceneDef.dispose();
    }
    if (this.renderer) {
      this.renderer.dispose();
      this.renderer = null;
    }
    this.sceneDef = null;
    this.inputs = [];
    this.inputValues = {};
  }

  resetTime() {
    this.startTime = performance.now();
  }
}

// ============================================================
// Draggable Panel
// ============================================================

function makeDraggable(panel, handle) {
  let ox = 0, oy = 0, sx = 0, sy = 0;
  let dragging = false;

  handle.addEventListener('mousedown', (e) => {
    if (e.target.closest('.params-btn')) return;
    dragging = true;
    sx = e.clientX;
    sy = e.clientY;
    ox = panel.offsetLeft;
    oy = panel.offsetTop;
    document.body.style.userSelect = 'none';
    e.preventDefault();
  });

  document.addEventListener('mousemove', (e) => {
    if (!dragging) return;
    const dx = e.clientX - sx;
    const dy = e.clientY - sy;
    panel.style.left = (ox + dx) + 'px';
    panel.style.top = (oy + dy) + 'px';
  });

  document.addEventListener('mouseup', () => {
    dragging = false;
    document.body.style.userSelect = '';
  });
}

// ============================================================
// UI Controls Generator
// ============================================================

function generateControls(inputs, container, onChange) {
  container.innerHTML = '';
  if (!inputs || inputs.length === 0) {
    container.innerHTML = '<div class="no-params">No parameters</div>';
    return {};
  }

  const values = {};

  inputs.forEach(inp => {
    const row = document.createElement('div');
    row.className = 'control-row';

    const label = document.createElement('label');
    label.textContent = inp.NAME;
    row.appendChild(label);

    if (inp.TYPE === 'float') {
      const def = inp.DEFAULT != null ? inp.DEFAULT : 0.5;
      const min = inp.MIN != null ? inp.MIN : 0;
      const max = inp.MAX != null ? inp.MAX : 1;
      values[inp.NAME] = def;

      const range = document.createElement('input');
      range.type = 'range';
      range.min = min;
      range.max = max;
      range.step = (max - min) / 200;
      range.value = def;

      const valSpan = document.createElement('span');
      valSpan.className = 'val';
      valSpan.textContent = Number(def).toFixed(2);

      range.addEventListener('input', () => {
        const v = parseFloat(range.value);
        values[inp.NAME] = v;
        valSpan.textContent = v.toFixed(2);
        onChange(values);
      });

      row.appendChild(range);
      row.appendChild(valSpan);

    } else if (inp.TYPE === 'color') {
      const def = inp.DEFAULT || [1, 1, 1, 1];
      values[inp.NAME] = [...def];

      const hex = rgbToHex(def[0], def[1], def[2]);
      const picker = document.createElement('input');
      picker.type = 'color';
      picker.value = hex;

      picker.addEventListener('input', () => {
        const rgb = hexToRgb(picker.value);
        values[inp.NAME] = [rgb[0], rgb[1], rgb[2], def[3] || 1];
        onChange(values);
      });

      row.appendChild(picker);

    } else if (inp.TYPE === 'bool') {
      const def = inp.DEFAULT ? true : false;
      values[inp.NAME] = def;

      const cb = document.createElement('input');
      cb.type = 'checkbox';
      cb.checked = def;
      cb.style.accentColor = 'var(--accent)';

      cb.addEventListener('change', () => {
        values[inp.NAME] = cb.checked;
        onChange(values);
      });

      row.appendChild(cb);

    } else if (inp.TYPE === 'long') {
      const vals = inp.VALUES || [];
      const labels = inp.LABELS || vals.map(String);
      const def = inp.DEFAULT != null ? inp.DEFAULT : (vals[0] || 0);
      values[inp.NAME] = def;

      const select = document.createElement('select');
      for (let i = 0; i < vals.length; i++) {
        const opt = document.createElement('option');
        opt.value = vals[i];
        opt.textContent = labels[i] || vals[i];
        if (vals[i] === def) opt.selected = true;
        select.appendChild(opt);
      }

      select.addEventListener('change', () => {
        values[inp.NAME] = parseFloat(select.value);
        onChange(values);
      });

      row.appendChild(select);

    } else if (inp.TYPE === 'text') {
      const maxLen = inp.MAX_LENGTH || 12;
      const def = (inp.DEFAULT || '').toUpperCase();

      function charToCode(ch) {
        if (!ch || ch === ' ') return 26;
        const c = ch.toUpperCase().charCodeAt(0) - 65;
        return (c >= 0 && c <= 25) ? c : 26;
      }

      for (let i = 0; i < maxLen; i++) {
        values[inp.NAME + '_' + i] = charToCode(def[i]);
      }
      values[inp.NAME + '_len'] = def.replace(/\s+$/, '').length;

      const textInput = document.createElement('input');
      textInput.type = 'text';
      textInput.maxLength = maxLen;
      textInput.value = def;
      textInput.spellcheck = false;

      textInput.addEventListener('input', () => {
        const str = textInput.value.toUpperCase();
        for (let i = 0; i < maxLen; i++) {
          values[inp.NAME + '_' + i] = charToCode(str[i]);
        }
        values[inp.NAME + '_len'] = str.replace(/\s+$/, '').length;
        onChange(values);
      });

      row.appendChild(textInput);

    } else if (inp.TYPE === 'image') {
      values[inp.NAME] = null; // texture binding, not a scalar value

      const compatibleMedia = mediaInputs.filter(m => m.type === 'image' || m.type === 'video');
      if (compatibleMedia.length === 0) {
        const placeholder = document.createElement('span');
        placeholder.style.cssText = 'color: var(--text-dim); font-size: 10px;';
        placeholder.textContent = 'No media — add via sidebar';
        row.appendChild(placeholder);
      } else {
        const select = document.createElement('select');
        const noneOpt = document.createElement('option');
        noneOpt.value = '';
        noneOpt.textContent = '(none)';
        select.appendChild(noneOpt);

        compatibleMedia.forEach(m => {
          const opt = document.createElement('option');
          opt.value = m.id;
          opt.textContent = mediaTypeIcon(m.type) + ' ' + m.name;
          select.appendChild(opt);
        });

        // Auto-select first if nothing bound
        if (compatibleMedia.length > 0) {
          select.value = compatibleMedia[0].id;
          values[inp.NAME] = compatibleMedia[0].id;
        }

        select.addEventListener('change', () => {
          values[inp.NAME] = select.value || null;
          onChange(values);
        });

        row.appendChild(select);
      }

    } else if (inp.TYPE === 'point2D') {
      const def = inp.DEFAULT || [0, 0];
      const min = inp.MIN || [-1, -1];
      const max = inp.MAX || [1, 1];
      values[inp.NAME] = [...def];

      for (let axis = 0; axis < 2; axis++) {
        const range = document.createElement('input');
        range.type = 'range';
        range.min = min[axis];
        range.max = max[axis];
        range.step = (max[axis] - min[axis]) / 200;
        range.value = def[axis];
        range.style.flex = '1';

        range.addEventListener('input', () => {
          values[inp.NAME][axis] = parseFloat(range.value);
          onChange(values);
        });

        row.appendChild(range);
      }
    }

    container.appendChild(row);
  });

  return values;
}

function rgbToHex(r, g, b) {
  const c = (v) => Math.round(Math.max(0, Math.min(1, v)) * 255).toString(16).padStart(2, '0');
  return '#' + c(r) + c(g) + c(b);
}

function hexToRgb(hex) {
  const r = parseInt(hex.slice(1, 3), 16) / 255;
  const g = parseInt(hex.slice(3, 5), 16) / 255;
  const b = parseInt(hex.slice(5, 7), 16) / 255;
  return [r, g, b];
}

// ============================================================
// App Init
// ============================================================

(async function init() {
  const glCanvas = document.getElementById('gl-canvas');
  const threeCanvas = document.getElementById('three-canvas');
  const isfRenderer = new Renderer(glCanvas);
  const sceneRenderer = new SceneRenderer(threeCanvas);
  const paramsPanel = document.getElementById('params-panel');
  const paramsBody = document.getElementById('params-body');
  const paramsHeader = document.getElementById('params-header');
  const errorBar = document.getElementById('error-bar');

  // Track which renderer is active: 'shader' or 'scene'
  let activeMode = 'shader';

  function getActiveRenderer() {
    return activeMode === 'scene' ? sceneRenderer : isfRenderer;
  }

  function getActiveCanvas() {
    return activeMode === 'scene' ? threeCanvas : glCanvas;
  }

  function switchToShader() {
    if (activeMode === 'scene') sceneRenderer.stop();
    activeMode = 'shader';
    glCanvas.style.display = 'block';
    threeCanvas.style.display = 'none';
  }

  function switchToScene() {
    if (activeMode === 'shader') isfRenderer.stop();
    activeMode = 'scene';
    glCanvas.style.display = 'none';
    threeCanvas.style.display = 'block';
  }

  // Make params panel draggable
  makeDraggable(paramsPanel, paramsHeader);

  // CodeMirror editor
  const editor = CodeMirror.fromTextArea(document.getElementById('code'), {
    mode: 'x-shader/x-fragment',
    theme: 'material-darker',
    lineNumbers: true,
    matchBrackets: true,
    autoCloseBrackets: true,
    tabSize: 4,
    indentWithTabs: true
  });

  let currentInputValues = {};
  let lastErrors = null;
  let currentInputs = [];

  // --- Compile (ISF shaders only) ---
  function compile() {
    const source = editor.getValue();
    const { frag, parsed } = buildFragmentShader(source);
    const result = isfRenderer.compile(VERT_SHADER, frag);

    currentInputs = parsed.inputs || [];

    if (result.ok) {
      lastErrors = null;
      errorBar.textContent = '';
      errorBar.classList.remove('show');

      currentInputValues = generateControls(parsed.inputs, paramsBody, (vals) => {
        isfRenderer.inputValues = vals;
        autoBindTextures();
      });
      isfRenderer.inputValues = currentInputValues;
      autoBindTextures();

      if (parsed.inputs.length > 0) {
        paramsPanel.classList.add('visible');
      }

      if (!isfRenderer.playing) isfRenderer.render();
    } else {
      lastErrors = result.errors;
      errorBar.textContent = result.errors;
      errorBar.classList.add('show');
    }

    return result;
  }

  // --- Load shader source into editor ---
  function loadSource(source) {
    editor.setValue(source);
    compile();
  }

  // --- Load a Three.js scene file ---
  async function loadScene(folder, file) {
    switchToScene();
    errorBar.textContent = '';
    errorBar.classList.remove('show');
    lastErrors = null;

    try {
      const r = await fetch((folder || 'scenes') + '/' + file);
      const src = await r.text();
      const sceneDef = new Function('THREE', 'return (' + src + ')(THREE)')(THREE);
      sceneRenderer.load(sceneDef);

      currentInputs = sceneDef.INPUTS || [];
      currentInputValues = generateControls(currentInputs, paramsBody, (vals) => {
        sceneRenderer.inputValues = vals;
      });
      sceneRenderer.inputValues = currentInputValues;

      if (currentInputs.length > 0) {
        paramsPanel.classList.add('visible');
      } else {
        paramsPanel.classList.remove('visible');
      }

      sceneRenderer.resize();
      sceneRenderer.start();
      document.getElementById('play-btn').innerHTML = '&#9654;';
    } catch (e) {
      lastErrors = e.message;
      errorBar.textContent = 'Scene error: ' + e.message;
      errorBar.classList.add('show');
    }
  }

  // Expose full API for MCP server bridge
  window.shaderClaw = {
    loadSource,
    loadScene,
    compile,
    getSource: () => editor.getValue(),
    getActiveMode: () => activeMode,

    getErrors: () => lastErrors,

    getInputs: () => {
      return currentInputs.map(inp => ({
        name: inp.NAME,
        type: inp.TYPE,
        value: currentInputValues[inp.NAME],
        min: inp.MIN,
        max: inp.MAX,
        default: inp.DEFAULT,
      }));
    },

    setParameter: (name, value) => {
      if (!(name in currentInputValues)) return { ok: false, error: `Unknown parameter: ${name}` };
      currentInputValues[name] = value;
      const r = getActiveRenderer();
      r.inputValues = currentInputValues;
      window.shaderClaw.updateControlUI(name, value);
      if (!r.playing) r.render();
      return { ok: true };
    },

    screenshot: () => {
      const r = getActiveRenderer();
      const c = getActiveCanvas();
      r.render();
      return c.toDataURL('image/png');
    },

    updateControlUI: (name, value) => {
      const rows = paramsBody.querySelectorAll('.control-row');
      for (const row of rows) {
        const label = row.querySelector('label');
        if (!label || label.textContent !== name) continue;

        const range = row.querySelector('input[type="range"]');
        if (range && typeof value === 'number') {
          range.value = value;
          const valSpan = row.querySelector('.val');
          if (valSpan) valSpan.textContent = value.toFixed(2);
        }

        const color = row.querySelector('input[type="color"]');
        if (color && Array.isArray(value)) {
          const cr = Math.round(Math.max(0, Math.min(1, value[0])) * 255).toString(16).padStart(2, '0');
          const cg = Math.round(Math.max(0, Math.min(1, value[1])) * 255).toString(16).padStart(2, '0');
          const cb = Math.round(Math.max(0, Math.min(1, value[2])) * 255).toString(16).padStart(2, '0');
          color.value = '#' + cr + cg + cb;
        }

        const cb = row.querySelector('input[type="checkbox"]');
        if (cb && typeof value === 'boolean') {
          cb.checked = value;
        }

        break;
      }
    },

    addMedia: async (name, dataUrl) => {
      const entry = await addMediaFromDataUrl(name, dataUrl);
      if (!entry) return { ok: false, error: 'Failed to load media' };
      return { ok: true, id: entry.id, name: entry.name, type: entry.type };
    },

    getMedia: () => {
      return mediaInputs.map(m => ({ id: m.id, name: m.name, type: m.type }));
    },

    removeMedia: (id) => {
      const exists = mediaInputs.find(m => m.id === id);
      if (!exists) return { ok: false, error: `Unknown media id: ${id}` };
      removeMedia(id);
      return { ok: true };
    },
  };

  // --- Auto-compile on change ---
  let compileTimeout = null;
  editor.on('change', () => {
    if (!document.getElementById('auto-compile').checked) return;
    clearTimeout(compileTimeout);
    compileTimeout = setTimeout(compile, 600);
  });

  // --- Buttons ---
  document.getElementById('compile-btn').addEventListener('click', compile);

  document.getElementById('play-btn').addEventListener('click', () => {
    const r = getActiveRenderer();
    const playing = r.togglePlay();
    document.getElementById('play-btn').innerHTML = playing ? '&#9654;' : '&#9646;&#9646;';
  });

  document.getElementById('fs-btn').addEventListener('click', () => {
    if (document.fullscreenElement) document.exitFullscreen();
    else document.getElementById('preview').requestFullscreen();
  });

  // Params panel toggle
  document.getElementById('params-toggle-btn').addEventListener('click', () => {
    paramsPanel.classList.toggle('visible');
  });

  // Params collapse
  document.getElementById('params-collapse').addEventListener('click', () => {
    paramsBody.classList.toggle('collapsed');
    document.getElementById('params-collapse').innerHTML =
      paramsBody.classList.contains('collapsed') ? '&#x25BC;' : '&#x25B2;';
  });

  // Params close
  document.getElementById('params-close').addEventListener('click', () => {
    paramsPanel.classList.remove('visible');
  });

  document.getElementById('new-btn').addEventListener('click', () => {
    switchToShader();
    loadSource(DEFAULT_SHADER);
    isfRenderer.start();
  });

  document.getElementById('copy-btn').addEventListener('click', () => {
    navigator.clipboard.writeText(editor.getValue()).then(() => {
      const btn = document.getElementById('copy-btn');
      btn.textContent = '\u2713';
      setTimeout(() => { btn.innerHTML = '&#x2398;'; }, 1200);
    });
  });

  document.getElementById('download-btn').addEventListener('click', () => {
    const blob = new Blob([editor.getValue()], { type: 'text/plain' });
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = 'shader.fs';
    a.click();
    URL.revokeObjectURL(a.href);
  });

  // --- Load Shader Library ---
  try {
    const resp = await fetch('shaders/manifest.json');
    const manifest = await resp.json();
    const list = document.getElementById('shader-list');

    // Separate shaders and scenes
    const shaders = manifest.filter(item => item.type !== 'scene');
    const scenes = manifest.filter(item => item.type === 'scene');

    function addSectionHeader(text) {
      const header = document.createElement('div');
      header.className = 'section-header';
      header.textContent = text;
      list.appendChild(header);
    }

    function addItem(item) {
      const div = document.createElement('div');
      div.className = 'shader-item';
      div.innerHTML = `<span class="name">${item.title}</span>`;

      div.addEventListener('click', async () => {
        list.querySelectorAll('.shader-item').forEach(el => el.classList.remove('active'));
        div.classList.add('active');

        if (item.type === 'scene') {
          await loadScene(item.folder, item.file);
        } else {
          try {
            switchToShader();
            const r = await fetch((item.folder || 'shaders') + '/' + item.file);
            const src = await r.text();
            loadSource(src);
            isfRenderer.start();
            document.getElementById('play-btn').innerHTML = '&#9654;';
          } catch (e) {
            errorBar.textContent = 'Failed to load: ' + item.file;
            errorBar.classList.add('show');
          }
        }
      });

      list.appendChild(div);
    }

    if (shaders.length > 0) {
      addSectionHeader('Shaders');
      shaders.forEach(addItem);
    }
    if (scenes.length > 0) {
      addSectionHeader('Scenes');
      scenes.forEach(addItem);
    }
  } catch (e) {
    console.warn('Could not load shader manifest:', e);
  }

  // --- INPUTS Section (Media) ---
  const mediaFileInput = document.getElementById('media-file-input');
  const mediaListContainer = document.createElement('div');
  mediaListContainer.id = 'media-list';

  // Add INPUTS section header with + button
  const inputsSectionRow = document.createElement('div');
  inputsSectionRow.className = 'section-header-row';
  const inputsSectionLabel = document.createElement('div');
  inputsSectionLabel.className = 'section-header';
  inputsSectionLabel.textContent = 'Inputs';
  const inputsAddBtn = document.createElement('button');
  inputsAddBtn.className = 'section-add-btn';
  inputsAddBtn.textContent = '+';
  inputsAddBtn.title = 'Add media input';
  inputsAddBtn.addEventListener('click', () => mediaFileInput.click());
  inputsSectionRow.appendChild(inputsSectionLabel);
  inputsSectionRow.appendChild(inputsAddBtn);

  const list = document.getElementById('shader-list');
  list.appendChild(inputsSectionRow);
  list.appendChild(mediaListContainer);

  function renderMediaList() {
    mediaListContainer.innerHTML = '';
    mediaInputs.forEach(media => {
      const item = document.createElement('div');
      item.className = 'media-item';

      const icon = document.createElement('span');
      icon.className = 'media-icon';
      icon.textContent = mediaTypeIcon(media.type);

      const name = document.createElement('span');
      name.className = 'media-name';
      name.textContent = media.name;

      const del = document.createElement('button');
      del.className = 'media-delete';
      del.textContent = '\u00D7';
      del.title = 'Remove';
      del.addEventListener('click', (e) => {
        e.stopPropagation();
        removeMedia(media.id);
      });

      item.appendChild(icon);
      item.appendChild(name);
      item.appendChild(del);
      mediaListContainer.appendChild(item);
    });
  }

  function autoBindTextures() {
    // Auto-bind image/video media to ISF image inputs by order
    isfRenderer.textures = {};
    const imageInputs = currentInputs.filter(inp => inp.TYPE === 'image');
    const compatibleMedia = mediaInputs.filter(m => m.type === 'image' || m.type === 'video');

    imageInputs.forEach((inp, i) => {
      // Check if a specific media was selected via control UI
      const selectedId = currentInputValues[inp.NAME];
      let media = null;
      if (selectedId) {
        media = mediaInputs.find(m => String(m.id) === String(selectedId));
      }
      if (!media && i < compatibleMedia.length) {
        media = compatibleMedia[i];
      }
      if (media && media.glTexture) {
        isfRenderer.textures[inp.NAME] = {
          glTexture: media.glTexture,
          isVideo: media.type === 'video',
          element: media.element,
        };
      }
    });

    // Update SceneRenderer media
    sceneRenderer.media = mediaInputs.map(m => ({
      name: m.name,
      type: m.type,
      threeTexture: m.threeTexture,
      threeModel: m.threeModel,
    }));
  }

  async function addMediaFromFile(file) {
    const type = detectMediaType(file);
    const id = ++mediaIdCounter;
    const entry = { id, name: file.name, type, element: null, glTexture: null, threeTexture: null, threeModel: null };

    if (type === 'image') {
      const img = new Image();
      const url = URL.createObjectURL(file);
      await new Promise((resolve, reject) => {
        img.onload = resolve;
        img.onerror = reject;
        img.src = url;
      });
      entry.element = img;
      entry.glTexture = createGLTexture(isfRenderer.gl, img);
      const threeTex = new THREE.Texture(img);
      threeTex.needsUpdate = true;
      entry.threeTexture = threeTex;

    } else if (type === 'video') {
      const video = document.createElement('video');
      video.muted = true;
      video.loop = true;
      video.playsInline = true;
      video.src = URL.createObjectURL(file);
      await new Promise((resolve) => {
        video.onloadeddata = resolve;
        video.load();
      });
      video.play();
      entry.element = video;
      entry.glTexture = createGLTexture(isfRenderer.gl, video);
      const threeTex = new THREE.VideoTexture(video);
      threeTex.needsUpdate = true;
      entry.threeTexture = threeTex;

    } else if (type === 'model') {
      if (typeof THREE.GLTFLoader === 'undefined') {
        console.warn('GLTFLoader not available');
        return null;
      }
      const loader = new THREE.GLTFLoader();
      const url = URL.createObjectURL(file);
      const gltf = await new Promise((resolve, reject) => {
        loader.load(url, resolve, undefined, reject);
      });
      entry.threeModel = gltf.scene;
    }

    mediaInputs.push(entry);
    renderMediaList();
    autoBindTextures();
    return entry;
  }

  async function addMediaFromDataUrl(name, dataUrl) {
    const resp = await fetch(dataUrl);
    const blob = await resp.blob();
    const file = new File([blob], name, { type: blob.type });
    return addMediaFromFile(file);
  }

  function removeMedia(id) {
    const idx = mediaInputs.findIndex(m => m.id === id);
    if (idx === -1) return;
    const entry = mediaInputs[idx];
    // Cleanup GL texture
    if (entry.glTexture) {
      isfRenderer.gl.deleteTexture(entry.glTexture);
    }
    // Cleanup THREE texture
    if (entry.threeTexture) {
      entry.threeTexture.dispose();
    }
    // Cleanup video element
    if (entry.type === 'video' && entry.element) {
      entry.element.pause();
      entry.element.src = '';
    }
    mediaInputs.splice(idx, 1);
    renderMediaList();
    autoBindTextures();
  }

  mediaFileInput.addEventListener('change', async (e) => {
    for (const file of e.target.files) {
      await addMediaFromFile(file);
    }
    mediaFileInput.value = '';
  });

  // --- Load default shader and start ---
  loadSource(DEFAULT_SHADER);
  isfRenderer.start();

  // Handle canvas resize on panel resize
  const resizeObs = new ResizeObserver(() => {
    isfRenderer.resize();
    if (activeMode === 'scene') sceneRenderer.resize();
  });
  resizeObs.observe(document.getElementById('preview'));

  // ============================================================
  // WebSocket Client — connects to MCP server bridge
  // ============================================================

  if (location.protocol !== 'file:') {
    const statusLight = document.getElementById('status-light');
    let ws = null;
    let reconnectTimer = null;

    function wsConnect() {
      const wsUrl = `ws://${location.host}`;
      ws = new WebSocket(wsUrl);

      ws.onopen = () => {
        statusLight.className = 'status-light connected';
        if (reconnectTimer) { clearInterval(reconnectTimer); reconnectTimer = null; }
      };

      ws.onclose = () => {
        statusLight.className = 'status-light disconnected';
        if (!reconnectTimer) {
          reconnectTimer = setInterval(() => wsConnect(), 2000);
        }
      };

      ws.onerror = () => {};

      ws.onmessage = async (evt) => {
        let msg;
        try { msg = JSON.parse(evt.data); } catch { return; }

        const { id, action, params } = msg;
        let result = null;
        let error = null;

        try {
          switch (action) {
            case 'load_shader': {
              switchToShader();
              window.shaderClaw.loadSource(params.code);
              isfRenderer.start();
              const compileResult = window.shaderClaw.getErrors();
              result = {
                ok: compileResult === null,
                errors: compileResult,
                inputs: window.shaderClaw.getInputs(),
              };
              break;
            }

            case 'load_scene': {
              await window.shaderClaw.loadScene(params.folder, params.file);
              result = {
                ok: window.shaderClaw.getErrors() === null,
                errors: window.shaderClaw.getErrors(),
                inputs: window.shaderClaw.getInputs(),
              };
              break;
            }

            case 'get_shader': {
              result = { code: window.shaderClaw.getSource() };
              break;
            }

            case 'set_parameter': {
              result = window.shaderClaw.setParameter(params.name, params.value);
              break;
            }

            case 'get_parameters': {
              result = { inputs: window.shaderClaw.getInputs() };
              break;
            }

            case 'screenshot': {
              const dataUrl = window.shaderClaw.screenshot();
              result = { dataUrl };
              break;
            }

            case 'get_errors': {
              const errs = window.shaderClaw.getErrors();
              result = { hasErrors: errs !== null, errors: errs };
              break;
            }

            case 'add_media': {
              result = await window.shaderClaw.addMedia(params.name, params.dataUrl);
              break;
            }

            case 'get_media': {
              result = { media: window.shaderClaw.getMedia() };
              break;
            }

            case 'remove_media': {
              result = window.shaderClaw.removeMedia(params.id);
              break;
            }

            default:
              error = `Unknown action: ${action}`;
          }
        } catch (e) {
          error = e.message;
        }

        ws.send(JSON.stringify({ id, result, error }));
      };
    }

    wsConnect();
  }

})();
</script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>ShaderClaw</title>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/codemirror.min.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/theme/material-darker.min.css">
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@100..900&family=Libre+Caslon+Text:ital,wght@0,400;0,700;1,400&family=Outfit:wght@100..900&display=swap" rel="stylesheet">
<style>
:root {
  --bg: #09090f;
  --panel: #111119;
  --panel-alt: #16161f;
  --border: #1e1e2e;
  --text: #c8c8d4;
  --text-dim: #666680;
  --accent: #e63946;
  --accent-dim: #e6394622;
  --green: #4ecdc4;
  --font: 'SF Mono', 'Cascadia Code', 'Fira Code', 'Consolas', monospace;
}

* { margin: 0; padding: 0; box-sizing: border-box; }

body {
  font-family: var(--font);
  background: var(--bg);
  color: var(--text);
  height: 100vh;
  overflow: hidden;
}

#app {
  display: grid;
  grid-template-columns: 1fr 260px;
  height: 100vh;
}

/* ===== SIDEBAR ===== */
#sidebar {
  background: var(--panel);
  border-left: 1px solid var(--border);
  border-right: none;
  display: flex;
  flex-direction: column;
  overflow: hidden;
  order: 2;
}

.brand {
  padding: 16px;
  font-size: 15px;
  font-weight: 700;
  letter-spacing: 1px;
  border-bottom: 1px solid var(--border);
  display: flex;
  align-items: center;
  gap: 10px;
}

.brand .logo-wrap {
  position: relative;
  width: 44px;
  height: 44px;
  flex-shrink: 0;
}

.brand .brand-text { display: flex; align-items: center; gap: 6px; }
.brand .brand-text span { color: var(--accent); }

#shader-list {
  flex: 1;
  overflow-y: auto;
  padding: 8px;
}

#shader-list::-webkit-scrollbar { width: 4px; }
#shader-list::-webkit-scrollbar-thumb { background: var(--border); border-radius: 2px; }

.shader-item {
  padding: 8px 10px;
  border-radius: 4px;
  cursor: pointer;
  font-size: 12px;
  display: flex;
  justify-content: space-between;
  align-items: center;
  transition: background 0.15s;
}

.shader-item:hover { background: var(--panel-alt); }
.shader-item.active { background: var(--accent-dim); border-left: 2px solid var(--accent); }

.shader-item.active::before {
  content: '';
  width: 6px;
  height: 6px;
  border-radius: 50%;
  background: var(--accent);
  flex-shrink: 0;
  margin-right: 6px;
  box-shadow: 0 0 4px var(--accent), 0 0 10px var(--accent);
  animation: dotPulse 2s ease-in-out infinite;
}

@keyframes dotPulse {
  0%, 100% { opacity: 0.7; box-shadow: 0 0 3px var(--accent), 0 0 6px var(--accent); }
  50% { opacity: 1; box-shadow: 0 0 6px var(--accent), 0 0 14px var(--accent); }
}

.shader-item .name {
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
  flex: 1;
}


/* ===== MAIN PANEL ===== */
#main {
  display: flex;
  flex-direction: column;
  overflow: hidden;
  position: relative;
  order: 1;
}

#preview {
  position: relative;
  flex: 1;
  background: #000;
}

#gl-canvas, #three-canvas {
  width: 100%;
  height: 100%;
  display: block;
  position: absolute;
  top: 0;
  left: 0;
}

#three-canvas { display: none; }

.canvas-controls {
  position: absolute;
  top: 8px;
  right: 8px;
  display: flex;
  gap: 4px;
}

.canvas-btn {
  background: #000000aa;
  border: 1px solid var(--border);
  color: var(--text);
  width: 28px;
  height: 28px;
  border-radius: 4px;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 14px;
  transition: background 0.15s;
}

.canvas-btn:hover { background: #000000dd; }

#error-bar {
  position: absolute;
  bottom: 0;
  left: 0;
  right: 0;
  background: #e6394620;
  border-top: 1px solid var(--accent);
  color: var(--accent);
  font-size: 11px;
  padding: 6px 12px;
  display: none;
  max-height: 80px;
  overflow-y: auto;
  white-space: pre-wrap;
  font-family: var(--font);
}

#error-bar.show { display: block; }

/* ===== FLOATING PARAMS PANEL ===== */
#panels-container {
  position: absolute;
  top: 12px;
  left: 12px;
  z-index: 100;
  width: 280px;
  display: flex;
  flex-direction: column;
  gap: 8px;
}

#params-panel {
  width: 100%;
  background: rgba(17, 17, 25, 0.92);
  backdrop-filter: blur(12px);
  -webkit-backdrop-filter: blur(12px);
  border: 1px solid var(--border);
  border-radius: 8px;
  box-shadow: 0 8px 32px rgba(0,0,0,0.5);
  display: none;
  overflow: hidden;
  transition: opacity 0.2s;
}

#params-panel.visible { display: block; }

#params-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 8px 12px;
  cursor: grab;
  user-select: none;
  border-bottom: 1px solid var(--border);
  background: rgba(22, 22, 31, 0.6);
}

#params-header:active { cursor: grabbing; }

#params-header .title {
  font-size: 10px;
  font-weight: 600;
  letter-spacing: 1px;
  color: var(--text-dim);
  text-transform: uppercase;
}

#params-header .actions {
  display: flex;
  gap: 4px;
}

.params-btn {
  background: none;
  border: none;
  color: var(--text-dim);
  cursor: pointer;
  font-size: 13px;
  width: 20px;
  height: 20px;
  display: flex;
  align-items: center;
  justify-content: center;
  border-radius: 3px;
  transition: color 0.15s, background 0.15s;
}

.params-btn:hover { color: var(--text); background: rgba(255,255,255,0.05); }

#params-body {
  padding: 10px 12px;
  max-height: 70vh;
  overflow-y: auto;
}

#params-body::-webkit-scrollbar { width: 4px; }
#params-body::-webkit-scrollbar-thumb { background: var(--border); border-radius: 2px; }

#params-body.collapsed {
  max-height: 0;
  padding: 0 12px;
  overflow: hidden;
}

.control-row {
  display: flex;
  align-items: center;
  gap: 8px;
  margin-bottom: 8px;
  font-size: 11px;
}

.control-row:last-child { margin-bottom: 0; }

.control-row label {
  width: 80px;
  flex-shrink: 0;
  color: var(--text-dim);
  text-overflow: ellipsis;
  overflow: hidden;
  white-space: nowrap;
  font-size: 10px;
}

.control-row input[type="range"] {
  flex: 1;
  accent-color: var(--accent);
  height: 3px;
}

.control-row input[type="color"] {
  width: 28px;
  height: 22px;
  border: 1px solid var(--border);
  border-radius: 3px;
  background: none;
  cursor: pointer;
  padding: 0;
}

.control-row select {
  flex: 1;
  background: var(--bg);
  color: var(--text);
  border: 1px solid var(--border);
  border-radius: 3px;
  padding: 2px 4px;
  font-size: 11px;
  font-family: inherit;
  cursor: pointer;
  max-width: 120px;
}

.control-row input[type="text"] {
  flex: 1;
  min-width: 0;
  background: var(--bg);
  color: var(--text);
  border: 1px solid var(--border);
  border-radius: 3px;
  padding: 3px 6px;
  font-size: 12px;
  font-family: monospace;
  letter-spacing: 1px;
  text-transform: uppercase;
  max-width: 200px;
}

.control-row .val {
  width: 44px;
  text-align: right;
  color: var(--text-dim);
  font-size: 10px;
  font-variant-numeric: tabular-nums;
}

.no-params {
  color: var(--text-dim);
  font-size: 11px;
  text-align: center;
  padding: 8px 0;
}

/* ===== MASK ROW ===== */
.mask-row {
  display: flex;
  align-items: center;
  gap: 6px;
  padding: 6px 12px;
  font-size: 11px;
  border-top: 1px solid var(--border);
}
.mask-row label {
  width: 40px;
  flex-shrink: 0;
  color: var(--text-dim);
  font-size: 10px;
  text-transform: uppercase;
  letter-spacing: 0.5px;
}
.mask-row select {
  flex: 1;
  background: var(--bg);
  color: var(--text);
  border: 1px solid var(--border);
  border-radius: 3px;
  padding: 2px 4px;
  font-size: 11px;
  font-family: inherit;
  cursor: pointer;
  min-width: 0;
}
.mask-mode-btns {
  display: flex;
  gap: 2px;
}
.mask-mode-btns button {
  background: none;
  border: 1px solid var(--border);
  color: var(--text-dim);
  border-radius: 3px;
  padding: 1px 5px;
  font-size: 9px;
  font-family: inherit;
  cursor: pointer;
  transition: all 0.15s;
}
.mask-mode-btns button.active {
  background: var(--accent-dim);
  border-color: var(--accent);
  color: var(--text);
}

/* ===== SECTION HEADERS ===== */
.section-header {
  font-size: 9px;
  font-weight: 700;
  letter-spacing: 1.5px;
  color: var(--text-dim);
  text-transform: uppercase;
  padding: 12px 10px 4px;
}

.section-header:first-child { padding-top: 4px; }

.import-grid {
  display: grid;
  grid-template-columns: repeat(3, 1fr);
  gap: 4px;
  padding: 6px 8px;
  border-bottom: 1px solid var(--border);
}

.import-tile {
  background: rgba(30, 30, 42, 0.6);
  border: 1px solid var(--border);
  color: var(--text-dim);
  border-radius: 5px;
  cursor: pointer;
  padding: 6px 2px 4px;
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 2px;
  transition: color 0.15s, border-color 0.15s, background 0.15s;
  font-family: inherit;
}

.import-tile:hover {
  color: var(--text);
  border-color: var(--text-dim);
  background: rgba(40, 40, 56, 0.8);
}

.import-tile svg { opacity: 0.7; }
.import-tile:hover svg { opacity: 1; }

.import-tile span {
  font-size: 8px;
  letter-spacing: 0.3px;
  text-transform: uppercase;
}

.media-item {
  padding: 6px 10px;
  border-radius: 4px;
  cursor: pointer;
  font-size: 11px;
  display: flex;
  align-items: center;
  gap: 6px;
  transition: background 0.15s;
}

.media-item:hover { background: var(--panel-alt); }

.media-item .media-icon {
  font-size: 12px;
  flex-shrink: 0;
  width: 16px;
  text-align: center;
}

.media-item .media-name {
  flex: 1;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
  color: var(--text);
}

.media-item .media-delete {
  background: none;
  border: none;
  color: var(--text-dim);
  cursor: pointer;
  font-size: 11px;
  padding: 0 2px;
  opacity: 0;
  transition: opacity 0.15s, color 0.15s;
}

.media-item:hover .media-delete { opacity: 1; }
.media-item .media-delete:hover { color: var(--accent); }

.media-item .flip-toggle {
  background: none;
  border: 1px solid var(--border);
  color: var(--text-dim);
  border-radius: 3px;
  padding: 0 4px;
  font-size: 9px;
  font-family: inherit;
  cursor: pointer;
  transition: all 0.15s;
  flex-shrink: 0;
  line-height: 16px;
}
.media-item .flip-toggle:hover { color: var(--text); border-color: var(--text-dim); }
.media-item .flip-toggle.active { color: var(--green); border-color: var(--green); background: rgba(78,205,196,0.1); }

.text-mic-btn {
  background: none;
  border: 1px solid var(--border);
  color: var(--text-dim);
  border-radius: 3px;
  cursor: pointer;
  font-size: 11px;
  padding: 1px 4px;
  margin-left: 4px;
  transition: color 0.15s, border-color 0.15s, background 0.15s;
  flex-shrink: 0;
}
.text-mic-btn:hover { color: var(--text); border-color: var(--text-dim); }
.text-mic-btn.active { color: #ff4444; border-color: #ff4444; background: rgba(255,68,68,0.1); }

.media-item .audio-bar {
  width: 30px;
  height: 6px;
  background: rgba(40, 40, 56, 0.8);
  border-radius: 3px;
  overflow: hidden;
  flex-shrink: 0;
}

.media-item .audio-bar-fill {
  height: 100%;
  width: 0%;
  background: #4ecdc4;
  border-radius: 3px;
  transition: width 0.05s;
}

.media-item .audio-toggle {
  background: none;
  border: none;
  color: var(--text-dim);
  cursor: pointer;
  font-size: 10px;
  padding: 0 2px;
  flex-shrink: 0;
}

.media-item .audio-toggle:hover { color: var(--text); }

#inputs-panel {
  width: 100%;
  background: rgba(17, 17, 25, 0.92);
  backdrop-filter: blur(12px);
  -webkit-backdrop-filter: blur(12px);
  border: 1px solid var(--border);
  border-radius: 8px;
  box-shadow: 0 8px 32px rgba(0,0,0,0.5);
  overflow: hidden;
}

#inputs-panel .inputs-header {
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 8px 12px;
  border-bottom: 1px solid var(--border);
  background: rgba(22, 22, 31, 0.6);
}

#inputs-panel .inputs-header .title {
  font-size: 10px;
  font-weight: 600;
  letter-spacing: 1px;
  color: var(--text-dim);
  text-transform: uppercase;
  flex: 1;
}

#inputs-panel .media-list {
  padding: 4px 0;
  max-height: 200px;
  overflow-y: auto;
}

#inputs-panel .media-list:empty {
  padding: 8px 12px;
}

#inputs-panel .media-list:empty::after {
  content: 'No media';
  color: var(--text-dim);
  font-size: 10px;
}

/* Drag shader as background */
.shader-item[draggable="true"] { cursor: grab; }
.shader-item[draggable="true"]:active { cursor: grabbing; }

#three-canvas.drag-over {
  outline: 2px solid var(--accent);
  outline-offset: -2px;
  box-shadow: inset 0 0 40px rgba(230, 57, 70, 0.15);
}

#remove-bg-btn {
  display: none;
  font-size: 11px;
  width: auto;
  padding: 0 8px;
  gap: 4px;
  color: var(--accent);
  border-color: var(--accent);
}

#remove-bg-btn.visible { display: flex; }

/* Editor — hidden, kept functional for MCP */
#editor-area {
  display: none;
}

/* Scrollbar global */
::-webkit-scrollbar { width: 6px; }
::-webkit-scrollbar-track { background: transparent; }
::-webkit-scrollbar-thumb { background: var(--border); border-radius: 3px; }
</style>
</head>
<body>

<div id="app">
  <!-- SIDEBAR -->
  <div id="sidebar">
    <div class="brand">
      <div class="logo-wrap">
        <img src="logo.png" alt="ShaderClaw" width="44" height="44" style="object-fit: contain;">
      </div>
      <div class="brand-text">SHADER<span>CLAW</span></div>
    </div>
    <div id="shader-list"></div>
  </div>

  <!-- MAIN -->
  <div id="main">
    <div id="preview">
      <canvas id="gl-canvas"></canvas>
      <canvas id="three-canvas"></canvas>
      <div class="canvas-controls">
        <button class="canvas-btn" id="remove-bg-btn" title="Remove shader background">&#x2715; BG</button>
        <button class="canvas-btn" id="params-toggle-btn" title="Toggle Parameters">&#x2699;</button>
        <button class="canvas-btn" id="play-btn" title="Play/Pause">&#9654;</button>
        <button class="canvas-btn" id="fs-btn" title="Fullscreen">&#x26F6;</button>
        <button class="canvas-btn" id="copy-btn" title="Copy Shader">&#x2398;</button>
        <button class="canvas-btn" id="download-btn" title="Save .fs">&#x2B73;</button>
      </div>
      <div id="error-bar"></div>

      <!-- Floating panels container -->
      <div id="panels-container">
        <!-- Inputs panel (top) -->
        <div id="inputs-panel">
          <div class="inputs-header">
            <span class="title">Inputs</span>
          </div>
          <div class="import-grid">
            <button class="import-tile" id="tile-image" title="Import image">
              <svg viewBox="0 0 24 24" width="18" height="18" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="3" width="18" height="18" rx="2"/><circle cx="8.5" cy="8.5" r="1.5"/><path d="M21 15l-5-5L5 21"/></svg>
              <span>Image</span>
            </button>
            <button class="import-tile" id="tile-video" title="Import video">
              <svg viewBox="0 0 24 24" width="18" height="18" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><polygon points="5,3 19,12 5,21"/></svg>
              <span>Video</span>
            </button>
            <button class="import-tile" id="tile-model" title="Import 3D model">
              <svg viewBox="0 0 24 24" width="18" height="18" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><path d="M12 2L2 7l10 5 10-5-10-5z"/><path d="M2 17l10 5 10-5"/><path d="M2 12l10 5 10-5"/></svg>
              <span>3D Model</span>
            </button>
            <button class="import-tile" id="tile-sound" title="Import audio">
              <svg viewBox="0 0 24 24" width="18" height="18" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><polygon points="11,5 6,9 2,9 2,15 6,15 11,19"/><path d="M19.07 4.93a10 10 0 010 14.14"/><path d="M15.54 8.46a5 5 0 010 7.07"/></svg>
              <span>Sound</span>
            </button>
            <button class="import-tile" id="tile-vector" title="Import SVG" style="display:none">
              <svg viewBox="0 0 24 24" width="18" height="18" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><path d="M12 19l7-7 3 3-7 7-3-3z"/><path d="M18 13l-1.5-7.5L2 2l3.5 14.5L13 18l5-5z"/><path d="M2 2l7.586 7.586"/><circle cx="11" cy="11" r="2"/></svg>
              <span>Vector</span>
            </button>
            <button class="import-tile" id="tile-text3d" title="Create 3D text" style="display:none">
              <svg viewBox="0 0 24 24" width="18" height="18" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><polyline points="4,7 4,4 20,4 20,7"/><line x1="12" y1="4" x2="12" y2="20"/><line x1="8" y1="20" x2="16" y2="20"/></svg>
              <span>3D Text</span>
            </button>
            <button class="import-tile" id="tile-webcam" title="Webcam input">
              <svg viewBox="0 0 24 24" width="18" height="18" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><path d="M23 7l-7 5 7 5V7z"/><rect x="1" y="5" width="15" height="14" rx="2"/></svg>
              <span>Webcam</span>
            </button>
            <button class="import-tile" id="tile-mic" title="Live mic captions" style="display:none">
              <svg viewBox="0 0 24 24" width="18" height="18" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><path d="M12 1a3 3 0 00-3 3v8a3 3 0 006 0V4a3 3 0 00-3-3z"/><path d="M19 10v2a7 7 0 01-14 0v-2"/><line x1="12" y1="19" x2="12" y2="23"/><line x1="8" y1="23" x2="16" y2="23"/></svg>
              <span>Mic</span>
            </button>
          </div>
          <div class="media-list" id="media-list"></div>
          <div class="mask-row" id="mask-row" style="display:none">
            <label>mask</label>
            <select id="mask-select"><option value="">(none)</option></select>
            <div class="mask-mode-btns">
              <button class="mask-mode-btn active" data-mode="1">mul</button>
              <button class="mask-mode-btn" data-mode="2">inv</button>
            </div>
          </div>
          <div class="mask-row" id="bg-row">
            <label>bg</label>
            <select id="bg-select"><option value="">(none)</option></select>
          </div>
        </div>

        <!-- Parameters panel (below) -->
        <div id="params-panel">
          <div id="params-header">
            <span class="title">Details</span>
            <div class="actions">
              <button class="params-btn" id="params-collapse" title="Collapse">&#x25B2;</button>
              <button class="params-btn" id="params-close" title="Close">&#x2715;</button>
            </div>
          </div>
          <div id="params-body"></div>
        </div>
      </div>
      <input type="file" id="image-file-input" accept="image/jpeg,image/png,image/gif,image/webp" multiple style="display:none">
      <input type="file" id="video-file-input" accept="video/mp4,video/webm" multiple style="display:none">
      <input type="file" id="model-file-input" accept=".glb,.gltf,.stl,.fbx,.obj" multiple style="display:none">
      <input type="file" id="sound-file-input" accept="audio/mpeg,audio/wav,audio/ogg,.mp3,.wav,.ogg" multiple style="display:none">
      <input type="file" id="vector-file-input" accept=".svg,image/svg+xml" style="display:none">
    </div>

    <div id="editor-area">
      <div id="editor-toolbar">
        <button id="compile-btn">Compile</button>
        <label id="auto-compile-label"><input type="checkbox" id="auto-compile" checked> Auto</label>
        <div class="spacer"></div>
        <button id="new-btn">New</button>
        <button id="download-btn">Save .fs</button>
      </div>
      <div id="editor-wrap"><textarea id="code"></textarea></div>
    </div>
  </div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/codemirror.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/mode/clike/clike.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/addon/edit/matchbrackets.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/addon/edit/closebrackets.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
<script src="https://cdn.jsdelivr.net/npm/fflate@0.6.10/umd/index.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/STLLoader.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/OBJLoader.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/FBXLoader.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/FontLoader.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/geometries/TextGeometry.js"></script>
<script>
// ============================================================
// ShaderClaw — ISF Shader Builder
// ============================================================

// FBXLoader needs fflate — shim it onto THREE namespace
if (window.fflate && typeof THREE !== 'undefined') THREE.fflate = window.fflate;

const DEFAULT_SHADER = `/*{
  "DESCRIPTION": "ShaderClaw default — radial pulse",
  "CATEGORIES": ["Generator"],
  "INPUTS": [
    { "NAME": "speed", "TYPE": "float", "DEFAULT": 1.0, "MIN": 0.0, "MAX": 5.0 },
    { "NAME": "rings", "TYPE": "float", "DEFAULT": 10.0, "MIN": 1.0, "MAX": 40.0 },
    { "NAME": "color1", "TYPE": "color", "DEFAULT": [0.9, 0.15, 0.2, 1.0] },
    { "NAME": "color2", "TYPE": "color", "DEFAULT": [0.06, 0.06, 0.12, 1.0] }
  ]
}*/

void main() {
    vec2 uv = isf_FragNormCoord - 0.5;
    float d = length(uv);
    float wave = sin(d * rings - TIME * speed) * 0.5 + 0.5;
    wave *= smoothstep(0.5, 0.1, d);
    gl_FragColor = mix(color2, color1, wave);
}`;

// ============================================================
// ISF Parser
// ============================================================

function parseISF(source) {
  const match = source.match(/\/\*\s*(\{[\s\S]*?\})\s*\*\//);
  if (!match) return { meta: null, glsl: source.trim(), inputs: [] };
  try {
    const meta = JSON.parse(match[1]);
    const glsl = source.slice(source.indexOf(match[0]) + match[0].length).trim();
    return { meta, glsl, inputs: meta.INPUTS || [] };
  } catch (e) {
    return { meta: null, glsl: source.trim(), inputs: [] };
  }
}

function isfInputToUniform(input) {
  const t = input.TYPE;
  if (t === 'float') return `uniform float ${input.NAME};`;
  if (t === 'color') return `uniform vec4 ${input.NAME};`;
  if (t === 'bool') return `uniform bool ${input.NAME};`;
  if (t === 'point2D') return `uniform vec2 ${input.NAME};`;
  if (t === 'image') return `uniform sampler2D ${input.NAME};`;
  if (t === 'long') return `uniform float ${input.NAME};`;
  if (t === 'text') {
    const maxLen = input.MAX_LENGTH || 12;
    const lines = [];
    for (let i = 0; i < maxLen; i++) lines.push(`uniform float ${input.NAME}_${i};`);
    lines.push(`uniform float ${input.NAME}_len;`);
    return lines.join('\n');
  }
  return `// unknown type: ${t} ${input.NAME}`;
}

function buildFragmentShader(source) {
  const parsed = parseISF(source);
  const uniformLines = (parsed.inputs || []).map(isfInputToUniform);

  const headerParts = [
    'precision highp float;',
    'uniform float TIME;',
    'uniform vec2 RENDERSIZE;',
    'uniform int PASSINDEX;',
    'uniform int FRAMEINDEX;',
    'varying vec2 isf_FragNormCoord;',
    '#define IMG_NORM_PIXEL(img, coord) texture2D(img, coord)',
    '#define IMG_PIXEL(img, coord) texture2D(img, coord / RENDERSIZE)',
    // Audio-reactive uniforms (always declared, zero when no audio)
    'uniform sampler2D audioFFT;',
    'uniform float audioLevel;',
    'uniform float audioBass;',
    'uniform float audioMid;',
    'uniform float audioHigh;',
    // Variable font texture (for Text shader effect 20)
    'uniform sampler2D varFontTex;',
    // Mask uniforms (global post-process mask)
    'uniform sampler2D _maskTex;',
    'uniform float _maskMode;',
    'uniform float _maskFlip;',
    'uniform float _maskFlipV;',
    ...uniformLines,
    ''
  ];
  const header = headerParts.join('\n');

  const cleaned = parsed.glsl.replace(/#version\s+\d+.*/g, '');

  // Wrap shader main() to inject mask post-processing
  let body = header + cleaned;
  const mainRe = /void\s+main\s*\(\s*\)/;
  if (mainRe.test(body)) {
    body = body.replace(mainRe, 'void _shaderMain()');
    body += `
void main() {
    _shaderMain();
    if (_maskMode > 0.5) {
        vec2 muv = gl_FragCoord.xy / RENDERSIZE.xy;
        if (_maskFlip > 0.5) muv.x = 1.0 - muv.x;
        if (_maskFlipV > 0.5) muv.y = 1.0 - muv.y;
        vec4 _m = texture2D(_maskTex, muv);
        float _lum = dot(_m.rgb, vec3(0.299, 0.587, 0.114));
        if (_maskMode > 1.5) _lum = 1.0 - _lum;
        gl_FragColor.rgb *= _lum;
    }
}
`;
  }

  return { frag: body, parsed, headerLineCount: headerParts.length };
}

const VERT_SHADER = `
attribute vec2 position;
varying vec2 isf_FragNormCoord;
void main() {
    isf_FragNormCoord = position * 0.5 + 0.5;
    gl_Position = vec4(position, 0.0, 1.0);
}`;

// ============================================================
// Media Inputs Store
// ============================================================

const mediaInputs = [];
let mediaIdCounter = 0;

// Global mask state (persists across shader switches)
let _maskMediaId = null;
let _maskMode = 0; // 0=off, 1=multiply, 2=invert

// Audio-reactive system
let audioCtx = null;
let audioAnalyser = null;
let audioDataArray = null;
let audioFFTGLTexture = null;
let audioFFTThreeTexture = null;
let audioLevel = 0, audioBass = 0, audioMid = 0, audioHigh = 0;
let activeAudioEntry = null;

// Variable font texture system (for Text shader "Variable Font" effect)
let _vfCanvas = null;
let _vfCtx = null;
let _vfGLTexture = null;
let _vfLastMsg = '';
let _vfWeight = 400;
const _fontFamilies = [
  '"Inter", "Segoe UI Variable", "SF Pro", sans-serif',
  '"Times New Roman", "Times", Georgia, serif',
  '"Libre Caslon Text", "Palatino Linotype", "Book Antiqua", serif',
  '"Outfit", "Inter", "Segoe UI Variable", sans-serif',
];

function _getFontStack(inputValues) {
  const idx = Math.round(inputValues['fontFamily'] || 0);
  return _fontFamilies[idx] || _fontFamilies[0];
}

function updateVarFontTexture(gl, inputValues) {
  // Build msg from character uniforms
  const maxLen = 24;
  let msg = '';
  const msgLen = inputValues['msg_len'];
  const len = (msgLen != null && msgLen > 0) ? Math.min(msgLen, maxLen) : 0;
  for (let i = 0; i < len; i++) {
    const code = inputValues['msg_' + i];
    if (code == null || code === 26) msg += ' ';
    else if (code >= 0 && code <= 25) msg += String.fromCharCode(65 + code);
    else msg += ' ';
  }
  msg = msg.trim() || 'ETHEREA';

  // Only re-render canvas if text, weight, or font changed
  const fontStack = _getFontStack(inputValues);
  const key = msg + '|' + _vfWeight + '|' + fontStack;
  if (key === _vfLastMsg && _vfGLTexture) return;
  _vfLastMsg = key;

  if (!_vfCanvas) {
    _vfCanvas = document.createElement('canvas');
    _vfCanvas.width = 2048;
    _vfCanvas.height = 512;
    _vfCtx = _vfCanvas.getContext('2d');
  }

  const c = _vfCanvas;
  const ctx = _vfCtx;
  ctx.clearRect(0, 0, c.width, c.height);
  ctx.save();
  // Flip vertically for GL coord system
  ctx.translate(0, c.height);
  ctx.scale(1, -1);
  const w = Math.round(_vfWeight);
  ctx.font = w + ' ' + Math.round(c.height * 0.35) + 'px ' + fontStack;
  ctx.fillStyle = '#ffffff';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText(msg, c.width / 2, c.height / 2);
  ctx.restore();

  if (!_vfGLTexture) {
    _vfGLTexture = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, _vfGLTexture);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
  } else {
    gl.bindTexture(gl.TEXTURE_2D, _vfGLTexture);
  }
  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, c);
}

// Audio-reactive per-frame update (global scope — called from Renderer.render)
function updateAudioUniforms(gl) {
  if (!audioAnalyser || !activeAudioEntry) {
    audioLevel = audioBass = audioMid = audioHigh = 0;
    return;
  }
  audioAnalyser.getByteFrequencyData(audioDataArray);
  const len = audioDataArray.length; // 128 bins

  // Compute RMS level
  let sum = 0;
  for (let i = 0; i < len; i++) sum += audioDataArray[i] * audioDataArray[i];
  audioLevel = Math.sqrt(sum / len) / 255.0;

  // Bass (bins 0-15), Mid (16-80), High (81-127)
  let bassSum = 0, midSum = 0, highSum = 0;
  for (let i = 0; i < 16; i++) bassSum += audioDataArray[i];
  for (let i = 16; i < 81; i++) midSum += audioDataArray[i];
  for (let i = 81; i < len; i++) highSum += audioDataArray[i];
  audioBass = bassSum / (16 * 255);
  audioMid = midSum / (65 * 255);
  audioHigh = highSum / (47 * 255);

  // Upload FFT data to GL texture (256x1 LUMINANCE)
  if (!audioFFTGLTexture) {
    audioFFTGLTexture = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, audioFFTGLTexture);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
  }
  gl.bindTexture(gl.TEXTURE_2D, audioFFTGLTexture);
  gl.texImage2D(gl.TEXTURE_2D, 0, gl.LUMINANCE, len, 1, 0, gl.LUMINANCE, gl.UNSIGNED_BYTE, audioDataArray);

  // Update THREE DataTexture
  if (!audioFFTThreeTexture) {
    audioFFTThreeTexture = new THREE.DataTexture(audioDataArray, len, 1, THREE.LuminanceFormat);
    audioFFTThreeTexture.needsUpdate = true;
  } else {
    audioFFTThreeTexture.needsUpdate = true;
  }

  // Update audio level bar in media list
  if (activeAudioEntry) {
    const bar = document.querySelector('.audio-bar-fill[data-audio-id="' + activeAudioEntry.id + '"]');
    if (bar) bar.style.width = (audioLevel * 100) + '%';
  }
}

function detectMediaType(file) {
  const ext = file.name.split('.').pop().toLowerCase();
  if (['glb', 'gltf', 'stl', 'fbx', 'obj'].includes(ext)) return 'model';
  if (['mp3', 'wav', 'ogg'].includes(ext)) return 'audio';
  if (ext === 'svg') return 'svg';
  if (file.type.startsWith('video/')) return 'video';
  return 'image';
}

function mediaTypeIcon(type, name) {
  if (type === 'video' && name === 'Webcam') return '\u{1F4F9}';
  if (type === 'video') return '\u{1F3AC}';
  if (type === 'model') return '\u{1F9CA}';
  if (type === 'audio') return '\u{1F50A}';
  if (type === 'svg') return '\u{2712}';
  return '\u{1F5BC}';
}

function createGLTexture(gl, source) {
  const tex = gl.createTexture();
  gl.bindTexture(gl.TEXTURE_2D, tex);
  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, source);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
  gl.bindTexture(gl.TEXTURE_2D, null);
  return tex;
}

// ============================================================
// WebGL Renderer
// ============================================================

class Renderer {
  constructor(canvas) {
    this.canvas = canvas;
    this.gl = canvas.getContext('webgl', { antialias: false, preserveDrawingBuffer: true });
    if (!this.gl) throw new Error('WebGL not supported');
    this.program = null;
    this.uniformLocs = {};
    this.inputValues = {};
    this.startTime = performance.now();
    this.frameIndex = 0;
    this.playing = true;
    this.animId = null;
    this.textures = {}; // name → { glTexture, isVideo, element }
    this._bgProgram = null;
    this._bgUniformLocs = {};
    this._initGeometry();
    this.resize();
    window.addEventListener('resize', () => this.resize());
  }

  _initGeometry() {
    const gl = this.gl;
    const buf = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, buf);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1,-1, 3,-1, -1,3]), gl.STATIC_DRAW);
    this.posBuf = buf;
  }

  resize() {
    // Fixed 1920x1080 render resolution — CSS handles display scaling
    this.canvas.width = 1920;
    this.canvas.height = 1080;
    this.gl.viewport(0, 0, 1920, 1080);
  }

  compile(vertSrc, fragSrc) {
    const gl = this.gl;
    const vs = this._compileShader(gl.VERTEX_SHADER, vertSrc);
    if (!vs.shader) return { ok: false, errors: 'Vertex: ' + vs.log };

    const fs = this._compileShader(gl.FRAGMENT_SHADER, fragSrc);
    if (!fs.shader) {
      gl.deleteShader(vs.shader);
      return { ok: false, errors: this._prettyErrors(fs.log) };
    }

    const prog = gl.createProgram();
    gl.attachShader(prog, vs.shader);
    gl.attachShader(prog, fs.shader);
    gl.bindAttribLocation(prog, 0, 'position');
    gl.linkProgram(prog);

    gl.deleteShader(vs.shader);
    gl.deleteShader(fs.shader);

    if (!gl.getProgramParameter(prog, gl.LINK_STATUS)) {
      const log = gl.getProgramInfoLog(prog);
      gl.deleteProgram(prog);
      return { ok: false, errors: 'Link: ' + log };
    }

    if (this.program) gl.deleteProgram(this.program);
    this.program = prog;
    this.uniformLocs = {};
    return { ok: true, errors: null };
  }

  _compileShader(type, src) {
    const gl = this.gl;
    const s = gl.createShader(type);
    gl.shaderSource(s, src);
    gl.compileShader(s);
    if (!gl.getShaderParameter(s, gl.COMPILE_STATUS)) {
      const log = gl.getShaderInfoLog(s);
      gl.deleteShader(s);
      return { shader: null, log };
    }
    return { shader: s, log: null };
  }

  _prettyErrors(log) {
    if (!log) return '';
    const headerLines = this._headerLines || 14;
    return log.replace(/ERROR:\s*\d+:(\d+)/g, (m, line) => {
      const adjusted = Math.max(1, parseInt(line) - headerLines);
      return `Line ${adjusted}`;
    });
  }

  _getLoc(name) {
    if (!(name in this.uniformLocs)) {
      this.uniformLocs[name] = this.gl.getUniformLocation(this.program, name);
    }
    return this.uniformLocs[name];
  }

  _getBgLoc(name) {
    if (!(name in this._bgUniformLocs)) {
      this._bgUniformLocs[name] = this.gl.getUniformLocation(this._bgProgram, name);
    }
    return this._bgUniformLocs[name];
  }

  compileBg(vertSrc, fragSrc) {
    const gl = this.gl;
    if (this._bgProgram) { gl.deleteProgram(this._bgProgram); this._bgProgram = null; }
    this._bgUniformLocs = {};
    if (!fragSrc) return { ok: true }; // clearing bg

    const vs = this._compileShader(gl.VERTEX_SHADER, vertSrc);
    if (!vs.shader) return { ok: false, errors: 'BG Vertex: ' + vs.log };
    const fs = this._compileShader(gl.FRAGMENT_SHADER, fragSrc);
    if (!fs.shader) { gl.deleteShader(vs.shader); return { ok: false, errors: 'BG: ' + fs.log }; }
    const prog = gl.createProgram();
    gl.attachShader(prog, vs.shader);
    gl.attachShader(prog, fs.shader);
    gl.bindAttribLocation(prog, 0, 'position');
    gl.linkProgram(prog);
    gl.deleteShader(vs.shader);
    gl.deleteShader(fs.shader);
    if (!gl.getProgramParameter(prog, gl.LINK_STATUS)) {
      gl.deleteProgram(prog);
      return { ok: false, errors: 'BG Link failed' };
    }
    this._bgProgram = prog;
    return { ok: true };
  }

  _renderBg() {
    const gl = this.gl;
    if (!this._bgProgram) return;

    gl.useProgram(this._bgProgram);
    const elapsed = (performance.now() - this.startTime) / 1000;
    const tLoc = this._getBgLoc('TIME');
    if (tLoc) gl.uniform1f(tLoc, elapsed);
    const rLoc = this._getBgLoc('RENDERSIZE');
    if (rLoc) gl.uniform2f(rLoc, this.canvas.width, this.canvas.height);
    const pLoc = this._getBgLoc('PASSINDEX');
    if (pLoc) gl.uniform1i(pLoc, 0);
    const fLoc = this._getBgLoc('FRAMEINDEX');
    if (fLoc) gl.uniform1i(fLoc, this.frameIndex);

    // Set bg shader's own input defaults (stored on renderer)
    if (this._bgInputValues) {
      for (const [name, val] of Object.entries(this._bgInputValues)) {
        const loc = this._getBgLoc(name);
        if (!loc) continue;
        if (typeof val === 'number') gl.uniform1f(loc, val);
        else if (typeof val === 'boolean') gl.uniform1i(loc, val ? 1 : 0);
        else if (Array.isArray(val)) {
          if (val.length === 2) gl.uniform2f(loc, val[0], val[1]);
          else if (val.length === 4) gl.uniform4f(loc, val[0], val[1], val[2], val[3]);
        }
      }
    }

    // Audio uniforms for bg shader
    if (audioFFTGLTexture) {
      gl.activeTexture(gl.TEXTURE0);
      gl.bindTexture(gl.TEXTURE_2D, audioFFTGLTexture);
      const aLoc = this._getBgLoc('audioFFT');
      if (aLoc) gl.uniform1i(aLoc, 0);
    }
    const bgAl = this._getBgLoc('audioLevel');
    if (bgAl) gl.uniform1f(bgAl, audioLevel);
    const bgAb = this._getBgLoc('audioBass');
    if (bgAb) gl.uniform1f(bgAb, audioBass);
    const bgAm = this._getBgLoc('audioMid');
    if (bgAm) gl.uniform1f(bgAm, audioMid);
    const bgAh = this._getBgLoc('audioHigh');
    if (bgAh) gl.uniform1f(bgAh, audioHigh);

    gl.bindBuffer(gl.ARRAY_BUFFER, this.posBuf);
    gl.enableVertexAttribArray(0);
    gl.vertexAttribPointer(0, 2, gl.FLOAT, false, 0, 0);
    gl.drawArrays(gl.TRIANGLES, 0, 3);
  }

  render() {
    const gl = this.gl;
    if (!this.program) return;

    // Render background shader first (if set)
    if (this._bgProgram) {
      gl.disable(gl.BLEND);
      this._renderBg();
      // Now enable blending so foreground composites on top
      gl.enable(gl.BLEND);
      gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
    } else {
      gl.disable(gl.BLEND);
    }

    gl.useProgram(this.program);

    const elapsed = (performance.now() - this.startTime) / 1000;
    const timeLoc = this._getLoc('TIME');
    if (timeLoc) gl.uniform1f(timeLoc, elapsed);

    const resLoc = this._getLoc('RENDERSIZE');
    if (resLoc) gl.uniform2f(resLoc, this.canvas.width, this.canvas.height);

    const piLoc = this._getLoc('PASSINDEX');
    if (piLoc) gl.uniform1i(piLoc, 0);

    const fiLoc = this._getLoc('FRAMEINDEX');
    if (fiLoc) gl.uniform1i(fiLoc, this.frameIndex);

    for (const [name, val] of Object.entries(this.inputValues)) {
      const loc = this._getLoc(name);
      if (!loc) continue;
      if (typeof val === 'number') gl.uniform1f(loc, val);
      else if (typeof val === 'boolean') gl.uniform1i(loc, val ? 1 : 0);
      else if (Array.isArray(val)) {
        if (val.length === 2) gl.uniform2f(loc, val[0], val[1]);
        else if (val.length === 4) gl.uniform4f(loc, val[0], val[1], val[2], val[3]);
      }
    }

    // Bind textures
    let texUnit = 0;
    for (const [name, tex] of Object.entries(this.textures)) {
      gl.activeTexture(gl.TEXTURE0 + texUnit);
      gl.bindTexture(gl.TEXTURE_2D, tex.glTexture);
      if (tex.isVideo && tex.element && tex.element.readyState >= 2) {
        if (tex.flipH || tex.flipV) {
          // Mirror webcam: draw flipped to offscreen canvas
          if (!tex._flipCanvas) {
            tex._flipCanvas = document.createElement('canvas');
            tex._flipCtx = tex._flipCanvas.getContext('2d');
          }
          const v = tex.element;
          const fc = tex._flipCanvas;
          if (fc.width !== v.videoWidth || fc.height !== v.videoHeight) {
            fc.width = v.videoWidth || 640;
            fc.height = v.videoHeight || 480;
          }
          const ctx = tex._flipCtx;
          ctx.save();
          ctx.translate(tex.flipH ? fc.width : 0, tex.flipV ? fc.height : 0);
          ctx.scale(tex.flipH ? -1 : 1, tex.flipV ? -1 : 1);
          ctx.drawImage(v, 0, 0);
          ctx.restore();
          gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, fc);
        } else {
          gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, tex.element);
        }
      }
      gl.uniform1i(this._getLoc(name), texUnit);
      texUnit++;
    }

    // Audio-reactive uniforms
    updateAudioUniforms(gl);
    if (audioFFTGLTexture) {
      gl.activeTexture(gl.TEXTURE0 + texUnit);
      gl.bindTexture(gl.TEXTURE_2D, audioFFTGLTexture);
      gl.uniform1i(this._getLoc('audioFFT'), texUnit);
      texUnit++;
    }
    const alLoc = this._getLoc('audioLevel');
    if (alLoc) gl.uniform1f(alLoc, audioLevel);
    const abLoc = this._getLoc('audioBass');
    if (abLoc) gl.uniform1f(abLoc, audioBass);
    const amLoc = this._getLoc('audioMid');
    if (amLoc) gl.uniform1f(amLoc, audioMid);
    const ahLoc = this._getLoc('audioHigh');
    if (ahLoc) gl.uniform1f(ahLoc, audioHigh);

    // Variable font texture (for Text shader effect 20)
    const vfLoc = this._getLoc('varFontTex');
    if (vfLoc) {
      updateVarFontTexture(gl, this.inputValues);
      if (_vfGLTexture) {
        gl.activeTexture(gl.TEXTURE0 + texUnit);
        gl.bindTexture(gl.TEXTURE_2D, _vfGLTexture);
        gl.uniform1i(vfLoc, texUnit);
        texUnit++;
      }
    }

    // Global mask texture
    const _maskModeLoc = this._getLoc('_maskMode');
    if (_maskModeLoc) gl.uniform1f(_maskModeLoc, _maskMode);
    const _maskFlipLoc = this._getLoc('_maskFlip');
    const _maskFlipVLoc = this._getLoc('_maskFlipV');
    if (_maskFlipLoc) gl.uniform1f(_maskFlipLoc, 0.0);
    if (_maskFlipVLoc) gl.uniform1f(_maskFlipVLoc, 0.0);
    if (_maskMediaId && _maskMode > 0) {
      const maskMedia = mediaInputs.find(m => String(m.id) === String(_maskMediaId));
      if (maskMedia && maskMedia.glTexture) {
        gl.activeTexture(gl.TEXTURE0 + texUnit);
        gl.bindTexture(gl.TEXTURE_2D, maskMedia.glTexture);
        if (maskMedia.type === 'video' && maskMedia.element && maskMedia.element.readyState >= 2) {
          gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, maskMedia.element);
        }
        if (_maskFlipLoc && maskMedia._webcamFlip) gl.uniform1f(_maskFlipLoc, 1.0);
        if (_maskFlipVLoc && maskMedia._webcamFlipV) gl.uniform1f(_maskFlipVLoc, 1.0);
        gl.uniform1i(this._getLoc('_maskTex'), texUnit);
        texUnit++;
      }
    }

    gl.bindBuffer(gl.ARRAY_BUFFER, this.posBuf);
    gl.enableVertexAttribArray(0);
    gl.vertexAttribPointer(0, 2, gl.FLOAT, false, 0, 0);
    gl.drawArrays(gl.TRIANGLES, 0, 3);

    this.frameIndex++;
  }

  start() {
    this.playing = true;
    const loop = () => {
      if (!this.playing) return;
      this.render();
      this.animId = requestAnimationFrame(loop);
    };
    loop();
  }

  stop() {
    this.playing = false;
    if (this.animId) cancelAnimationFrame(this.animId);
  }

  togglePlay() {
    if (this.playing) this.stop();
    else this.start();
    return this.playing;
  }

  resetTime() {
    this.startTime = performance.now();
    this.frameIndex = 0;
  }
}

// ============================================================
// Three.js Scene Renderer
// ============================================================

class SceneRenderer {
  constructor(canvas) {
    this.canvas = canvas;
    this.renderer = null;
    this.sceneDef = null;
    this.playing = false;
    this.animId = null;
    this.startTime = performance.now();
    this.inputValues = {};
    this.inputs = [];
    this.media = []; // { name, type, threeTexture, threeModel }
    this._shaderBg = null; // { isfRenderer, texture } when shader bg active
  }

  load(sceneDef) {
    this.cleanup();
    this.renderer = new THREE.WebGLRenderer({ canvas: this.canvas, antialias: true, preserveDrawingBuffer: true, powerPreference: 'high-performance' });
    this.renderer.setPixelRatio(window.devicePixelRatio);
    this.resize();
    this.sceneDef = sceneDef.create(this.renderer, this.canvas, this.media);
    this.inputs = sceneDef.INPUTS || [];
    this.startTime = performance.now();
  }

  render() {
    if (!this.sceneDef || !this.renderer) return;
    // Update audio analysis (used by ISF bg shader and scene)
    if (this._isfGL) updateAudioUniforms(this._isfGL);
    // Drive ISF offscreen render and update texture before 3D render
    if (this._shaderBg) {
      this._shaderBg.isfRenderer.render();
      this._shaderBg.texture.needsUpdate = true;
    }
    const elapsed = (performance.now() - this.startTime) / 1000;
    this.sceneDef.update(elapsed, this.inputValues, this.media);
    this.renderer.render(this.sceneDef.scene, this.sceneDef.camera);
  }

  start() {
    this.playing = true;
    const loop = () => {
      if (!this.playing) return;
      this.render();
      this.animId = requestAnimationFrame(loop);
    };
    loop();
  }

  stop() {
    this.playing = false;
    if (this.animId) cancelAnimationFrame(this.animId);
  }

  togglePlay() {
    if (this.playing) this.stop();
    else this.start();
    return this.playing;
  }

  resize() {
    if (!this.renderer) return;
    const parent = this.canvas.parentElement;
    const w = parent.clientWidth;
    const h = parent.clientHeight;
    this.renderer.setSize(w, h, false);
    this.canvas.style.width = w + 'px';
    this.canvas.style.height = h + 'px';
    if (this.sceneDef && this.sceneDef.resize) {
      this.sceneDef.resize(w, h);
    }
  }

  cleanup() {
    this.stop();
    if (this.sceneDef && this.sceneDef.dispose) {
      this.sceneDef.dispose();
    }
    if (this.renderer) {
      this.renderer.dispose();
      this.renderer = null;
    }
    this.sceneDef = null;
    this.inputs = [];
    this.inputValues = {};
  }

  resetTime() {
    this.startTime = performance.now();
  }
}

// ============================================================
// Draggable Panel
// ============================================================

function makeDraggable(panel, handle) {
  let ox = 0, oy = 0, sx = 0, sy = 0;
  let dragging = false;

  handle.addEventListener('mousedown', (e) => {
    if (e.target.closest('.params-btn')) return;
    dragging = true;
    sx = e.clientX;
    sy = e.clientY;
    ox = panel.offsetLeft;
    oy = panel.offsetTop;
    document.body.style.userSelect = 'none';
    e.preventDefault();
  });

  document.addEventListener('mousemove', (e) => {
    if (!dragging) return;
    const dx = e.clientX - sx;
    const dy = e.clientY - sy;
    panel.style.left = (ox + dx) + 'px';
    panel.style.top = (oy + dy) + 'px';
  });

  document.addEventListener('mouseup', () => {
    dragging = false;
    document.body.style.userSelect = '';
  });
}

// ============================================================
// UI Controls Generator
// ============================================================

function generateControls(inputs, container, onChange) {
  container.innerHTML = '';
  if (!inputs || inputs.length === 0) {
    container.innerHTML = '<div class="no-params">No parameters</div>';
    return {};
  }

  const values = {};

  inputs.forEach(inp => {
    const row = document.createElement('div');
    row.className = 'control-row';

    const label = document.createElement('label');
    label.textContent = inp.NAME;
    row.appendChild(label);

    if (inp.TYPE === 'float') {
      const def = inp.DEFAULT != null ? inp.DEFAULT : 0.5;
      const min = inp.MIN != null ? inp.MIN : 0;
      const max = inp.MAX != null ? inp.MAX : 1;
      values[inp.NAME] = def;

      const range = document.createElement('input');
      range.type = 'range';
      range.min = min;
      range.max = max;
      range.step = (max - min) / 200;
      range.value = def;

      const valSpan = document.createElement('span');
      valSpan.className = 'val';
      valSpan.textContent = Number(def).toFixed(2);

      range.addEventListener('input', () => {
        const v = parseFloat(range.value);
        values[inp.NAME] = v;
        valSpan.textContent = v.toFixed(2);
        onChange(values);
      });

      row.appendChild(range);
      row.appendChild(valSpan);

    } else if (inp.TYPE === 'color') {
      const def = inp.DEFAULT || [1, 1, 1, 1];
      values[inp.NAME] = [...def];

      const hex = rgbToHex(def[0], def[1], def[2]);
      const picker = document.createElement('input');
      picker.type = 'color';
      picker.value = hex;

      picker.addEventListener('input', () => {
        const rgb = hexToRgb(picker.value);
        values[inp.NAME] = [rgb[0], rgb[1], rgb[2], def[3] || 1];
        onChange(values);
      });

      row.appendChild(picker);

    } else if (inp.TYPE === 'bool') {
      const def = inp.DEFAULT ? true : false;
      values[inp.NAME] = def;

      const cb = document.createElement('input');
      cb.type = 'checkbox';
      cb.checked = def;
      cb.style.accentColor = 'var(--accent)';

      cb.addEventListener('change', () => {
        values[inp.NAME] = cb.checked;
        onChange(values);
      });

      row.appendChild(cb);

    } else if (inp.TYPE === 'long') {
      const vals = inp.VALUES || [];
      const labels = inp.LABELS || vals.map(String);
      const def = inp.DEFAULT != null ? inp.DEFAULT : (vals[0] || 0);
      values[inp.NAME] = def;

      const select = document.createElement('select');
      for (let i = 0; i < vals.length; i++) {
        const opt = document.createElement('option');
        opt.value = vals[i];
        opt.textContent = labels[i] || vals[i];
        if (vals[i] === def) opt.selected = true;
        select.appendChild(opt);
      }

      select.addEventListener('change', () => {
        values[inp.NAME] = parseFloat(select.value);
        onChange(values);
      });

      row.appendChild(select);

    } else if (inp.TYPE === 'text') {
      const maxLen = inp.MAX_LENGTH || 12;
      const def = (inp.DEFAULT || '').toUpperCase();

      function charToCode(ch) {
        if (!ch || ch === ' ') return 26;
        const c = ch.toUpperCase().charCodeAt(0) - 65;
        return (c >= 0 && c <= 25) ? c : 26;
      }

      for (let i = 0; i < maxLen; i++) {
        values[inp.NAME + '_' + i] = charToCode(def[i]);
      }
      values[inp.NAME + '_len'] = def.replace(/\s+$/, '').length;

      const textInput = document.createElement('input');
      textInput.type = 'text';
      textInput.maxLength = maxLen;
      textInput.value = def;
      textInput.spellcheck = false;

      textInput.addEventListener('input', () => {
        const str = textInput.value.toUpperCase();
        for (let i = 0; i < maxLen; i++) {
          values[inp.NAME + '_' + i] = charToCode(str[i]);
        }
        values[inp.NAME + '_len'] = str.replace(/\s+$/, '').length;
        onChange(values);
      });

      row.appendChild(textInput);

      // Mic button — toggles speech recognition into this text field
      const SpeechRec = window.SpeechRecognition || window.webkitSpeechRecognition;
      if (SpeechRec) {
        const micBtn = document.createElement('button');
        micBtn.className = 'text-mic-btn';
        micBtn.textContent = '\u{1F3A4}';
        micBtn.title = 'Mic input';
        let micRec = null;
        let micActive = false;

        function startMicRec() {
          micRec = new SpeechRec();
          micRec.continuous = true;
          micRec.interimResults = true;
          micRec.onresult = (event) => {
            let interim = '';
            let final = '';
            for (let i = event.resultIndex; i < event.results.length; i++) {
              if (event.results[i].isFinal) final += event.results[i][0].transcript;
              else interim += event.results[i][0].transcript;
            }
            const raw = (final || interim).trim();
            if (!raw) return;
            let str = raw.toUpperCase();
            if (str.length > maxLen) {
              // Cut to last maxLen chars, then skip to next full word
              str = str.slice(-maxLen);
              const sp = str.indexOf(' ');
              if (sp > 0) str = str.slice(sp + 1);
            }
            textInput.value = str;
            for (let i = 0; i < maxLen; i++) {
              values[inp.NAME + '_' + i] = charToCode(str[i]);
            }
            values[inp.NAME + '_len'] = str.replace(/\s+$/, '').length;
            onChange(values);
          };
          micRec.onerror = (e) => {
            console.warn('Mic error:', e.error);
            if (e.error === 'not-allowed' || e.error === 'aborted') {
              micActive = false;
              micBtn.classList.remove('active');
            }
          };
          micRec.onend = () => {
            if (micActive) {
              // Create fresh instance — Chrome won't restart a used one reliably
              setTimeout(startMicRec, 300);
            }
          };
          micRec.start();
        }

        micBtn.addEventListener('click', () => {
          if (micActive && micRec) {
            micActive = false;
            micRec.stop();
            micRec = null;
            micBtn.classList.remove('active');
            return;
          }
          micActive = true;
          micBtn.classList.add('active');
          startMicRec();
        });
        row.appendChild(micBtn);
      }

    } else if (inp.TYPE === 'image') {
      values[inp.NAME] = null; // texture binding, not a scalar value

      const compatibleMedia = mediaInputs.filter(m => m.type === 'image' || m.type === 'video' || m.type === 'svg');
      if (compatibleMedia.length === 0) {
        const placeholder = document.createElement('span');
        placeholder.style.cssText = 'color: var(--text-dim); font-size: 10px;';
        placeholder.textContent = 'No media — add via sidebar';
        row.appendChild(placeholder);
      } else {
        const select = document.createElement('select');
        const noneOpt = document.createElement('option');
        noneOpt.value = '';
        noneOpt.textContent = '(none)';
        select.appendChild(noneOpt);

        compatibleMedia.forEach(m => {
          const opt = document.createElement('option');
          opt.value = m.id;
          opt.textContent = mediaTypeIcon(m.type) + ' ' + m.name;
          select.appendChild(opt);
        });

        // Auto-select first if nothing bound
        if (compatibleMedia.length > 0) {
          select.value = compatibleMedia[0].id;
          values[inp.NAME] = compatibleMedia[0].id;
        }

        select.addEventListener('change', () => {
          values[inp.NAME] = select.value || null;
          onChange(values);
        });

        row.appendChild(select);
      }

    } else if (inp.TYPE === 'point2D') {
      const def = inp.DEFAULT || [0, 0];
      const min = inp.MIN || [-1, -1];
      const max = inp.MAX || [1, 1];
      values[inp.NAME] = [...def];

      for (let axis = 0; axis < 2; axis++) {
        const range = document.createElement('input');
        range.type = 'range';
        range.min = min[axis];
        range.max = max[axis];
        range.step = (max[axis] - min[axis]) / 200;
        range.value = def[axis];
        range.style.flex = '1';

        range.addEventListener('input', () => {
          values[inp.NAME][axis] = parseFloat(range.value);
          onChange(values);
        });

        row.appendChild(range);
      }
    }

    container.appendChild(row);
  });

  return values;
}

function rgbToHex(r, g, b) {
  const c = (v) => Math.round(Math.max(0, Math.min(1, v)) * 255).toString(16).padStart(2, '0');
  return '#' + c(r) + c(g) + c(b);
}

function hexToRgb(hex) {
  const r = parseInt(hex.slice(1, 3), 16) / 255;
  const g = parseInt(hex.slice(3, 5), 16) / 255;
  const b = parseInt(hex.slice(5, 7), 16) / 255;
  return [r, g, b];
}

// ============================================================
// App Init
// ============================================================

(async function init() {
  const glCanvas = document.getElementById('gl-canvas');
  const threeCanvas = document.getElementById('three-canvas');
  const isfRenderer = new Renderer(glCanvas);
  const sceneRenderer = new SceneRenderer(threeCanvas);
  sceneRenderer._isfGL = isfRenderer.gl; // For audio uniform updates in scene mode
  const paramsPanel = document.getElementById('params-panel');
  const paramsBody = document.getElementById('params-body');
  const paramsHeader = document.getElementById('params-header');
  const errorBar = document.getElementById('error-bar');

  // Track which renderer is active: 'shader' or 'scene'
  let activeMode = 'shader';

  // Shader-as-background state
  let shaderBgActive = false;
  let shaderBgTexture = null;
  let shaderBgOriginalBackground = null;

  function getActiveRenderer() {
    return activeMode === 'scene' ? sceneRenderer : isfRenderer;
  }

  function getActiveCanvas() {
    return activeMode === 'scene' ? threeCanvas : glCanvas;
  }

  function switchToShader() {
    if (activeMode === 'scene') sceneRenderer.stop();
    removeShaderBackground();
    activeMode = 'shader';
    glCanvas.style.display = 'block';
    threeCanvas.style.display = 'none';
  }

  function switchToScene() {
    if (activeMode === 'shader') isfRenderer.stop();
    activeMode = 'scene';
    glCanvas.style.display = 'none';
    threeCanvas.style.display = 'block';
  }

  // Make params panel draggable
  const panelsContainer = document.getElementById('panels-container');
  makeDraggable(panelsContainer, paramsHeader);

  // CodeMirror editor
  const editor = CodeMirror.fromTextArea(document.getElementById('code'), {
    mode: 'x-shader/x-fragment',
    theme: 'material-darker',
    lineNumbers: true,
    matchBrackets: true,
    autoCloseBrackets: true,
    tabSize: 4,
    indentWithTabs: true
  });

  let currentInputValues = {};
  let lastErrors = null;
  let currentInputs = [];

  // --- Compile (ISF shaders only) ---
  function compile() {
    const source = editor.getValue();
    const { frag, parsed, headerLineCount } = buildFragmentShader(source);
    isfRenderer._headerLines = headerLineCount;
    const result = isfRenderer.compile(VERT_SHADER, frag);

    currentInputs = parsed.inputs || [];

    if (result.ok) {
      lastErrors = null;
      errorBar.textContent = '';
      errorBar.classList.remove('show');

      currentInputValues = generateControls(parsed.inputs, paramsBody, (vals) => {
        isfRenderer.inputValues = vals;
        if ('fontFamily' in vals) setVarFontFamily(vals.fontFamily);
        autoBindTextures();
      });
      isfRenderer.inputValues = currentInputValues;
      autoBindTextures();

      if (parsed.inputs.length > 0) {
        paramsPanel.classList.add('visible');
      }

      if (!isfRenderer.playing) isfRenderer.render();
    } else {
      lastErrors = result.errors;
      errorBar.textContent = result.errors;
      errorBar.classList.add('show');
    }

    return result;
  }

  // --- Load shader source into editor ---
  function loadSource(source) {
    editor.setValue(source);
    compile();
  }

  // --- Load a Three.js scene file ---
  async function loadScene(folder, file) {
    removeShaderBackground();
    switchToScene();
    errorBar.textContent = '';
    errorBar.classList.remove('show');
    lastErrors = null;

    try {
      const r = await fetch((folder || 'scenes') + '/' + file);
      const src = await r.text();
      const sceneDef = new Function('THREE', 'return (' + src + ')(THREE)')(THREE);
      sceneRenderer.load(sceneDef);

      currentInputs = sceneDef.INPUTS || [];
      currentInputValues = generateControls(currentInputs, paramsBody, (vals) => {
        sceneRenderer.inputValues = vals;
        autoBindTextures();
      });
      sceneRenderer.inputValues = currentInputValues;
      autoBindTextures();

      if (currentInputs.length > 0) {
        paramsPanel.classList.add('visible');
      } else {
        paramsPanel.classList.remove('visible');
      }

      sceneRenderer.resize();
      sceneRenderer.start();
      document.getElementById('play-btn').innerHTML = '&#9654;';
    } catch (e) {
      lastErrors = e.message;
      errorBar.textContent = 'Scene error: ' + e.message;
      errorBar.classList.add('show');
    }
  }

  // --- Shader as 3D Scene Background ---
  async function applyShaderBackground(folder, file) {
    if (activeMode !== 'scene' || !sceneRenderer.sceneDef) return;

    try {
      const r = await fetch((folder || 'shaders') + '/' + file);
      const src = await r.text();
      const { frag, parsed, headerLineCount } = buildFragmentShader(src);
      isfRenderer._headerLines = headerLineCount;
      const result = isfRenderer.compile(VERT_SHADER, frag);
      if (!result.ok) {
        console.warn('Shader bg compile failed:', result.errors);
        return;
      }

      // Set ISF inputs to defaults
      isfRenderer.inputValues = {};
      (parsed.inputs || []).forEach(inp => {
        if (inp.DEFAULT != null) isfRenderer.inputValues[inp.NAME] = inp.DEFAULT;
      });

      // Stop ISF's own animation loop — scene loop drives it
      isfRenderer.stop();

      // Store original background
      shaderBgOriginalBackground = sceneRenderer.sceneDef.scene.background;

      // Create CanvasTexture from ISF's WebGL canvas
      shaderBgTexture = new THREE.CanvasTexture(glCanvas);
      shaderBgTexture.minFilter = THREE.LinearFilter;
      shaderBgTexture.magFilter = THREE.LinearFilter;
      sceneRenderer.sceneDef.scene.background = shaderBgTexture;

      // Tell SceneRenderer to drive ISF each frame
      sceneRenderer._shaderBg = { isfRenderer, texture: shaderBgTexture };
      shaderBgActive = true;

      // Show remove button
      document.getElementById('remove-bg-btn').classList.add('visible');
    } catch (e) {
      console.warn('Failed to apply shader background:', e);
    }
  }

  function removeShaderBackground() {
    if (!shaderBgActive) return;

    // Restore original scene background
    if (sceneRenderer.sceneDef && shaderBgOriginalBackground) {
      sceneRenderer.sceneDef.scene.background = shaderBgOriginalBackground;
    }

    // Dispose texture
    if (shaderBgTexture) {
      shaderBgTexture.dispose();
      shaderBgTexture = null;
    }

    // Clear SceneRenderer's reference
    sceneRenderer._shaderBg = null;
    shaderBgActive = false;
    shaderBgOriginalBackground = null;

    // Hide remove button
    document.getElementById('remove-bg-btn').classList.remove('visible');
  }

  // Remove BG button handler
  document.getElementById('remove-bg-btn').addEventListener('click', removeShaderBackground);

  // Expose full API for MCP server bridge
  window.shaderClaw = {
    loadSource,
    loadScene,
    compile,
    getSource: () => editor.getValue(),
    getActiveMode: () => activeMode,

    getErrors: () => lastErrors,

    getInputs: () => {
      return currentInputs.map(inp => ({
        name: inp.NAME,
        type: inp.TYPE,
        value: currentInputValues[inp.NAME],
        min: inp.MIN,
        max: inp.MAX,
        default: inp.DEFAULT,
      }));
    },

    setParameter: (name, value) => {
      if (!(name in currentInputValues)) return { ok: false, error: `Unknown parameter: ${name}` };
      currentInputValues[name] = value;
      const r = getActiveRenderer();
      r.inputValues = currentInputValues;
      window.shaderClaw.updateControlUI(name, value);
      if (!r.playing) r.render();
      return { ok: true };
    },

    screenshot: () => {
      const r = getActiveRenderer();
      const c = getActiveCanvas();
      r.render();
      return c.toDataURL('image/png');
    },

    updateControlUI: (name, value) => {
      const rows = paramsBody.querySelectorAll('.control-row');
      for (const row of rows) {
        const label = row.querySelector('label');
        if (!label || label.textContent !== name) continue;

        const range = row.querySelector('input[type="range"]');
        if (range && typeof value === 'number') {
          range.value = value;
          const valSpan = row.querySelector('.val');
          if (valSpan) valSpan.textContent = value.toFixed(2);
        }

        const color = row.querySelector('input[type="color"]');
        if (color && Array.isArray(value)) {
          const cr = Math.round(Math.max(0, Math.min(1, value[0])) * 255).toString(16).padStart(2, '0');
          const cg = Math.round(Math.max(0, Math.min(1, value[1])) * 255).toString(16).padStart(2, '0');
          const cb = Math.round(Math.max(0, Math.min(1, value[2])) * 255).toString(16).padStart(2, '0');
          color.value = '#' + cr + cg + cb;
        }

        const cb = row.querySelector('input[type="checkbox"]');
        if (cb && typeof value === 'boolean') {
          cb.checked = value;
        }

        const sel = row.querySelector('select');
        if (sel && typeof value === 'number') {
          sel.value = value;
        }

        break;
      }
    },

    addMedia: async (name, dataUrl) => {
      const entry = await addMediaFromDataUrl(name, dataUrl);
      if (!entry) return { ok: false, error: 'Failed to load media' };
      return { ok: true, id: entry.id, name: entry.name, type: entry.type };
    },

    getMedia: () => {
      return mediaInputs.map(m => ({ id: m.id, name: m.name, type: m.type }));
    },

    removeMedia: (id) => {
      const exists = mediaInputs.find(m => m.id === id);
      if (!exists) return { ok: false, error: `Unknown media id: ${id}` };
      removeMedia(id);
      return { ok: true };
    },

    addWebcam: addMediaFromWebcam,

    applyShaderBackground,
    removeShaderBackground,

    getAudioLevels: () => ({
      level: audioLevel,
      bass: audioBass,
      mid: audioMid,
      high: audioHigh,
      hasAudio: !!activeAudioEntry,
    }),

    setVarFontWeight,
    setVarFontFamily,
  };

  // --- Auto-compile on change ---
  let compileTimeout = null;
  editor.on('change', () => {
    if (!document.getElementById('auto-compile').checked) return;
    clearTimeout(compileTimeout);
    compileTimeout = setTimeout(compile, 600);
  });

  // --- Buttons ---
  document.getElementById('compile-btn').addEventListener('click', compile);

  document.getElementById('play-btn').addEventListener('click', () => {
    const r = getActiveRenderer();
    const playing = r.togglePlay();
    document.getElementById('play-btn').innerHTML = playing ? '&#9654;' : '&#9646;&#9646;';
  });

  document.getElementById('fs-btn').addEventListener('click', () => {
    if (document.fullscreenElement) document.exitFullscreen();
    else document.getElementById('preview').requestFullscreen();
  });

  // Params panel toggle
  document.getElementById('params-toggle-btn').addEventListener('click', () => {
    paramsPanel.classList.toggle('visible');
  });

  // Params collapse
  document.getElementById('params-collapse').addEventListener('click', () => {
    paramsBody.classList.toggle('collapsed');
    document.getElementById('params-collapse').innerHTML =
      paramsBody.classList.contains('collapsed') ? '&#x25BC;' : '&#x25B2;';
  });

  // Params close
  document.getElementById('params-close').addEventListener('click', () => {
    paramsPanel.classList.remove('visible');
  });

  document.getElementById('new-btn').addEventListener('click', () => {
    switchToShader();
    loadSource(DEFAULT_SHADER);
    isfRenderer.start();
  });

  document.getElementById('copy-btn').addEventListener('click', () => {
    navigator.clipboard.writeText(editor.getValue()).then(() => {
      const btn = document.getElementById('copy-btn');
      btn.textContent = '\u2713';
      setTimeout(() => { btn.innerHTML = '&#x2398;'; }, 1200);
    });
  });

  document.getElementById('download-btn').addEventListener('click', () => {
    const blob = new Blob([editor.getValue()], { type: 'text/plain' });
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = 'shader.fs';
    a.click();
    URL.revokeObjectURL(a.href);
  });

  // --- Load Shader Library ---
  try {
    const resp = await fetch('shaders/manifest.json');
    const manifest = await resp.json();
    const list = document.getElementById('shader-list');

    // Separate into categories
    const scenes = manifest.filter(item => item.type === 'scene');
    const textShaders = manifest.filter(item => item.type !== 'scene' && (item.categories || []).includes('Text'));
    const otherShaders = manifest.filter(item => item.type !== 'scene' && !(item.categories || []).includes('Text'));

    function addSectionHeader(text) {
      const header = document.createElement('div');
      header.className = 'section-header';
      header.textContent = text;
      list.appendChild(header);
    }

    function addItem(item) {
      const div = document.createElement('div');
      div.className = 'shader-item';
      div.innerHTML = `<span class="name">${item.title}</span>`;

      // Make non-scene items draggable (for shader-as-background)
      if (item.type !== 'scene') {
        div.draggable = true;
        div.addEventListener('dragstart', (e) => {
          e.dataTransfer.setData('application/x-shaderclaw-shader', JSON.stringify({
            folder: item.folder || 'shaders',
            file: item.file,
            title: item.title
          }));
          e.dataTransfer.effectAllowed = 'copy';
        });
      }

      div.addEventListener('click', async () => {
        list.querySelectorAll('.shader-item').forEach(el => el.classList.remove('active'));
        div.classList.add('active');

        if (item.type === 'scene') {
          await loadScene(item.folder, item.file);
        } else {
          try {
            switchToShader();
            const r = await fetch((item.folder || 'shaders') + '/' + item.file);
            const src = await r.text();
            loadSource(src);
            isfRenderer.start();
            document.getElementById('play-btn').innerHTML = '&#9654;';
          } catch (e) {
            errorBar.textContent = 'Failed to load: ' + item.file;
            errorBar.classList.add('show');
          }
        }
      });

      list.appendChild(div);
    }

    if (scenes.length > 0) {
      addSectionHeader('3D Scenes');
      scenes.forEach(addItem);
    }
    if (otherShaders.length > 0) {
      addSectionHeader('Shaders');
      otherShaders.forEach(addItem);
    }
    if (textShaders.length > 0) {
      addSectionHeader('Text');
      textShaders.forEach(addItem);
    }

    // Populate background shader dropdown (non-scene shaders only)
    const bgSelect = document.getElementById('bg-select');
    const bgShaders = manifest.filter(item => item.type !== 'scene');
    bgShaders.forEach(item => {
      const opt = document.createElement('option');
      opt.value = JSON.stringify({ folder: item.folder || 'shaders', file: item.file });
      opt.textContent = item.title;
      bgSelect.appendChild(opt);
    });
    bgSelect.addEventListener('change', async () => {
      if (!bgSelect.value) {
        isfRenderer.compileBg(null, null);
        return;
      }
      try {
        const { folder, file } = JSON.parse(bgSelect.value);
        const r = await fetch(folder + '/' + file);
        const src = await r.text();
        const { frag, parsed } = buildFragmentShader(src);
        const result = isfRenderer.compileBg(VERT_SHADER, frag);
        if (result.ok) {
          // Store bg shader defaults
          const bgVals = {};
          (parsed.inputs || []).forEach(inp => {
            if (inp.DEFAULT != null) bgVals[inp.NAME] = inp.DEFAULT;
          });
          isfRenderer._bgInputValues = bgVals;
        } else {
          console.warn('BG shader compile failed:', result.errors);
          bgSelect.value = '';
        }
      } catch (e) {
        console.warn('Failed to load bg shader:', e);
        bgSelect.value = '';
      }
    });
  } catch (e) {
    console.warn('Could not load shader manifest:', e);
  }

  // --- Drop shader onto 3D scene as background ---
  const previewEl = document.getElementById('preview');

  previewEl.addEventListener('dragover', (e) => {
    if (activeMode !== 'scene') return;
    if (!e.dataTransfer.types.includes('application/x-shaderclaw-shader')) return;
    e.preventDefault();
    e.dataTransfer.dropEffect = 'copy';
    threeCanvas.classList.add('drag-over');
  });

  previewEl.addEventListener('dragleave', (e) => {
    // Only remove if leaving the preview area entirely
    if (!previewEl.contains(e.relatedTarget)) {
      threeCanvas.classList.remove('drag-over');
    }
  });

  previewEl.addEventListener('drop', async (e) => {
    e.preventDefault();
    threeCanvas.classList.remove('drag-over');
    const data = e.dataTransfer.getData('application/x-shaderclaw-shader');
    if (!data || activeMode !== 'scene') return;
    try {
      const { folder, file } = JSON.parse(data);
      await applyShaderBackground(folder, file);
    } catch (err) {
      console.warn('Drop failed:', err);
    }
  });

  // --- INPUTS Panel (Media) ---
  const mediaListContainer = document.getElementById('media-list');

  // File inputs for each type
  const imageFileInput = document.getElementById('image-file-input');
  const videoFileInput = document.getElementById('video-file-input');
  const modelFileInput = document.getElementById('model-file-input');
  const soundFileInput = document.getElementById('sound-file-input');
  const vectorFileInput = document.getElementById('vector-file-input');

  function wireFileInput(input) {
    input.addEventListener('change', async (e) => {
      for (const file of e.target.files) {
        await addMediaFromFile(file);
      }
      input.value = '';
    });
  }
  wireFileInput(imageFileInput);
  wireFileInput(videoFileInput);
  wireFileInput(modelFileInput);
  wireFileInput(soundFileInput);
  wireFileInput(vectorFileInput);

  // Tile click handlers
  document.getElementById('tile-image').addEventListener('click', () => imageFileInput.click());
  document.getElementById('tile-video').addEventListener('click', () => videoFileInput.click());
  document.getElementById('tile-model').addEventListener('click', () => modelFileInput.click());
  document.getElementById('tile-sound').addEventListener('click', () => soundFileInput.click());
  document.getElementById('tile-vector').addEventListener('click', () => vectorFileInput.click());

  document.getElementById('tile-webcam').addEventListener('click', async () => {
    try { await addMediaFromWebcam(); }
    catch (e) { console.warn('Webcam access denied:', e.message); }
  });

  // 3D Text tile — choose geometry or variable font
  document.getElementById('tile-text3d').addEventListener('click', async () => {
    const choice = prompt('Text mode:\n1 = 3D Geometry\n2 = Variable Font Texture\n\nEnter 1 or 2:');
    if (!choice) return;
    const mode = choice.trim();
    if (mode === '1') {
      const text = prompt('Enter text for 3D geometry:');
      if (!text || !text.trim()) return;
      try { await addText3D(text.trim()); }
      catch (e) { console.warn('3D Text failed:', e.message); }
    } else if (mode === '2') {
      const text = prompt('Enter text for variable font texture:');
      if (!text || !text.trim()) return;
      try { addVariableFontText(text.trim()); }
      catch (e) { console.warn('Variable font text failed:', e.message); }
    }
  });

  // Mic tile — directly starts live mic captions
  document.getElementById('tile-mic').addEventListener('click', () => {
    try { startMicCaptions(); }
    catch (e) { console.warn('Mic captions failed:', e.message); }
  });

  function renderMediaList() {
    mediaListContainer.innerHTML = '';
    mediaInputs.forEach(media => {
      const item = document.createElement('div');
      item.className = 'media-item';

      const icon = document.createElement('span');
      icon.className = 'media-icon';
      icon.textContent = mediaTypeIcon(media.type, media.name);

      const name = document.createElement('span');
      name.className = 'media-name';
      name.textContent = media.name;

      item.appendChild(icon);
      item.appendChild(name);

      // Webcam: H/V flip toggles
      if (media._webcamFlip !== undefined) {
        const flipH = document.createElement('button');
        flipH.className = 'flip-toggle' + (media._webcamFlip ? ' active' : '');
        flipH.textContent = 'H';
        flipH.title = 'Mirror horizontally';
        flipH.addEventListener('click', (e) => {
          e.stopPropagation();
          media._webcamFlip = !media._webcamFlip;
          flipH.classList.toggle('active', media._webcamFlip);
          if (media.threeTexture) {
            media.threeTexture.wrapS = media._webcamFlip ? THREE.RepeatWrapping : THREE.ClampToEdgeWrapping;
            media.threeTexture.repeat.x = media._webcamFlip ? -1 : 1;
            media.threeTexture.offset.x = media._webcamFlip ? 1 : 0;
            media.threeTexture.needsUpdate = true;
          }
          autoBindTextures();
        });
        const flipV = document.createElement('button');
        flipV.className = 'flip-toggle' + (media._webcamFlipV ? ' active' : '');
        flipV.textContent = 'V';
        flipV.title = 'Mirror vertically';
        flipV.addEventListener('click', (e) => {
          e.stopPropagation();
          media._webcamFlipV = !media._webcamFlipV;
          flipV.classList.toggle('active', media._webcamFlipV);
          if (media.threeTexture) {
            media.threeTexture.wrapT = media._webcamFlipV ? THREE.RepeatWrapping : THREE.ClampToEdgeWrapping;
            media.threeTexture.repeat.y = media._webcamFlipV ? -1 : 1;
            media.threeTexture.offset.y = media._webcamFlipV ? 1 : 0;
            media.threeTexture.needsUpdate = true;
          }
          autoBindTextures();
        });
        item.appendChild(flipH);
        item.appendChild(flipV);
      }

      // Audio: play/pause toggle + level bar
      if (media.type === 'audio') {
        const toggle = document.createElement('button');
        toggle.className = 'audio-toggle';
        toggle.textContent = (media.element && !media.element.paused) ? '\u23F8' : '\u25B6';
        toggle.title = 'Play/Pause';
        toggle.addEventListener('click', (e) => {
          e.stopPropagation();
          if (media.element) {
            if (media.element.paused) {
              if (audioCtx && audioCtx.state === 'suspended') audioCtx.resume();
              media.element.play().catch(() => {});
              toggle.textContent = '\u23F8';
            } else {
              media.element.pause();
              toggle.textContent = '\u25B6';
            }
          }
        });
        item.appendChild(toggle);

        const bar = document.createElement('div');
        bar.className = 'audio-bar';
        const fill = document.createElement('div');
        fill.className = 'audio-bar-fill';
        fill.dataset.audioId = media.id;
        bar.appendChild(fill);
        item.appendChild(bar);
      }

      const del = document.createElement('button');
      del.className = 'media-delete';
      del.textContent = '\u00D7';
      del.title = 'Remove';
      del.addEventListener('click', (e) => {
        e.stopPropagation();
        removeMedia(media.id);
      });

      item.appendChild(del);
      mediaListContainer.appendChild(item);
    });
  }

  function autoBindTextures() {
    // Auto-bind image/video media to ISF image inputs by order
    isfRenderer.textures = {};
    const imageInputs = currentInputs.filter(inp => inp.TYPE === 'image');
    const compatibleMedia = mediaInputs.filter(m => m.type === 'image' || m.type === 'video' || m.type === 'svg');

    imageInputs.forEach((inp, i) => {
      // Check if a specific media was selected via control UI
      let selectedId = currentInputValues[inp.NAME];
      let media = null;
      if (selectedId) {
        media = mediaInputs.find(m => String(m.id) === String(selectedId));
      }
      // Auto-assign first compatible media if nothing selected
      if (!media && i < compatibleMedia.length) {
        media = compatibleMedia[i];
        currentInputValues[inp.NAME] = media.id;
        getActiveRenderer().inputValues = currentInputValues;
      }
      if (media && media.glTexture) {
        isfRenderer.textures[inp.NAME] = {
          glTexture: media.glTexture,
          isVideo: media.type === 'video',
          element: media.element,
          flipH: !!media._webcamFlip,
          flipV: !!media._webcamFlipV,
        };
      }
    });

    // Update SceneRenderer media
    sceneRenderer.media = mediaInputs.map(m => ({
      id: m.id,
      name: m.name,
      type: m.type,
      threeTexture: m.threeTexture,
      threeModel: m.threeModel,
    }));

    // Refresh the image dropdowns in params panel to reflect current media
    const selects = paramsBody.querySelectorAll('.control-row select');
    selects.forEach(select => {
      const label = select.closest('.control-row')?.querySelector('label');
      if (!label) return;
      const inp = currentInputs.find(i => i.NAME === label.textContent && i.TYPE === 'image');
      if (!inp) return;
      // Rebuild options
      select.innerHTML = '';
      const noneOpt = document.createElement('option');
      noneOpt.value = '';
      noneOpt.textContent = '(none)';
      select.appendChild(noneOpt);
      compatibleMedia.forEach(m => {
        const opt = document.createElement('option');
        opt.value = m.id;
        opt.textContent = mediaTypeIcon(m.type) + ' ' + m.name;
        select.appendChild(opt);
      });
      const curVal = currentInputValues[inp.NAME];
      if (curVal) select.value = curVal;
    });

    // Replace placeholder text with dropdown if media now exists
    paramsBody.querySelectorAll('.control-row').forEach(row => {
      const label = row.querySelector('label');
      if (!label) return;
      const inp = currentInputs.find(i => i.NAME === label.textContent && i.TYPE === 'image');
      if (!inp) return;
      const placeholder = row.querySelector('span[style]');
      if (placeholder && compatibleMedia.length > 0) {
        placeholder.remove();
        const select = document.createElement('select');
        const noneOpt = document.createElement('option');
        noneOpt.value = '';
        noneOpt.textContent = '(none)';
        select.appendChild(noneOpt);
        compatibleMedia.forEach(m => {
          const opt = document.createElement('option');
          opt.value = m.id;
          opt.textContent = mediaTypeIcon(m.type) + ' ' + m.name;
          select.appendChild(opt);
        });
        const curVal = currentInputValues[inp.NAME];
        if (curVal) select.value = curVal;
        select.addEventListener('change', () => {
          currentInputValues[inp.NAME] = select.value || null;
          getActiveRenderer().inputValues = currentInputValues;
        });
        row.appendChild(select);
      }
    });

    // Update mask dropdown
    updateMaskUI();
  }

  function updateMaskUI() {
    const maskRow = document.getElementById('mask-row');
    const maskSelect = document.getElementById('mask-select');
    const compatibleMask = mediaInputs.filter(m => m.type === 'image' || m.type === 'video' || m.type === 'svg');
    if (compatibleMask.length === 0) {
      maskRow.style.display = 'none';
      _maskMediaId = null;
      _maskMode = 0;
      return;
    }
    maskRow.style.display = '';
    const prev = maskSelect.value;
    maskSelect.innerHTML = '<option value="">(none)</option>';
    compatibleMask.forEach(m => {
      const opt = document.createElement('option');
      opt.value = m.id;
      opt.textContent = mediaTypeIcon(m.type) + ' ' + m.name;
      maskSelect.appendChild(opt);
    });
    // Restore selection if still valid
    if (prev && compatibleMask.some(m => String(m.id) === prev)) {
      maskSelect.value = prev;
    } else {
      maskSelect.value = '';
      _maskMediaId = null;
      if (!maskSelect.value) _maskMode = 0;
    }
  }

  // Wire up mask controls once DOM is ready
  (function initMaskControls() {
    const maskSelect = document.getElementById('mask-select');
    const modeBtns = document.querySelectorAll('.mask-mode-btn');
    maskSelect.addEventListener('change', () => {
      _maskMediaId = maskSelect.value || null;
      _maskMode = _maskMediaId ? parseInt(document.querySelector('.mask-mode-btn.active').dataset.mode) : 0;
    });
    modeBtns.forEach(btn => {
      btn.addEventListener('click', () => {
        modeBtns.forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        _maskMode = _maskMediaId ? parseInt(btn.dataset.mode) : 0;
      });
    });
  })();

  async function addMediaFromFile(file) {
    const type = detectMediaType(file);
    const id = ++mediaIdCounter;
    const entry = { id, name: file.name, type, element: null, glTexture: null, threeTexture: null, threeModel: null };

    if (type === 'image') {
      const img = new Image();
      const url = URL.createObjectURL(file);
      await new Promise((resolve, reject) => {
        img.onload = resolve;
        img.onerror = reject;
        img.src = url;
      });
      entry.element = img;
      entry.glTexture = createGLTexture(isfRenderer.gl, img);
      const threeTex = new THREE.Texture(img);
      threeTex.needsUpdate = true;
      entry.threeTexture = threeTex;

    } else if (type === 'video') {
      const video = document.createElement('video');
      video.muted = true;
      video.loop = true;
      video.playsInline = true;
      video.preload = 'auto';
      // Keep video in the DOM so Chrome doesn't GC its decode pipeline
      video.style.cssText = 'position:fixed;top:-9999px;width:1px;height:1px;opacity:0;pointer-events:none';
      document.body.appendChild(video);
      // Auto-recover from unexpected pauses and stalls
      video.addEventListener('pause', () => {
        if (video.loop && !video.ended) video.play().catch(() => {});
      });
      video.addEventListener('stalled', () => { video.play().catch(() => {}); });
      // Set up listeners before assigning src to avoid race conditions
      const loaded = new Promise((resolve, reject) => {
        video.onloadeddata = () => resolve();
        video.onerror = () => reject(new Error('Video format not supported: ' + file.name));
      });
      video.src = URL.createObjectURL(file);
      video.load();
      await loaded;
      try {
        await video.play();
      } catch (e) {
        console.warn('Video autoplay blocked for', file.name, '— will retry on interaction');
        const retryPlay = () => {
          video.play().catch(() => {});
          document.removeEventListener('click', retryPlay);
        };
        document.addEventListener('click', retryPlay, { once: true });
      }
      entry.element = video;
      entry.glTexture = createGLTexture(isfRenderer.gl, video);
      const threeTex = new THREE.VideoTexture(video);
      threeTex.needsUpdate = true;
      entry.threeTexture = threeTex;

    } else if (type === 'model') {
      const ext = file.name.split('.').pop().toLowerCase();
      const url = URL.createObjectURL(file);

      if (ext === 'stl') {
        const loader = new THREE.STLLoader();
        const geometry = await new Promise((resolve, reject) => {
          loader.load(url, resolve, undefined, reject);
        });
        geometry.computeVertexNormals();
        const mat = new THREE.MeshStandardMaterial({ color: 0xcccccc, roughness: 0.4, metalness: 0.1 });
        const mesh = new THREE.Mesh(geometry, mat);
        const group = new THREE.Group();
        group.add(mesh);
        entry.threeModel = group;

      } else if (ext === 'obj') {
        const loader = new THREE.OBJLoader();
        const group = await new Promise((resolve, reject) => {
          loader.load(url, resolve, undefined, reject);
        });
        entry.threeModel = group;

      } else if (ext === 'fbx') {
        if (window.fflate) THREE.fflate = window.fflate;
        const loader = new THREE.FBXLoader();
        const group = await new Promise((resolve, reject) => {
          loader.load(url, resolve, undefined, reject);
        });
        entry.threeModel = group;

      } else {
        // GLTF/GLB
        if (typeof THREE.GLTFLoader === 'undefined') {
          console.warn('GLTFLoader not available');
          return null;
        }
        const loader = new THREE.GLTFLoader();
        const gltf = await new Promise((resolve, reject) => {
          loader.load(url, resolve, undefined, reject);
        });
        entry.threeModel = gltf.scene;
      }

    } else if (type === 'audio') {
      // Audio-reactive sound
      if (!audioCtx) {
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        audioAnalyser = audioCtx.createAnalyser();
        audioAnalyser.fftSize = 256;
        audioAnalyser.smoothingTimeConstant = 0.8;
        audioAnalyser.connect(audioCtx.destination);
        audioDataArray = new Uint8Array(audioAnalyser.frequencyBinCount); // 128 bins
      }

      // Disconnect previous audio source
      if (activeAudioEntry && activeAudioEntry._sourceNode) {
        try { activeAudioEntry._sourceNode.disconnect(); } catch(e) {}
        if (activeAudioEntry.element) activeAudioEntry.element.pause();
      }

      const audio = document.createElement('audio');
      audio.loop = true;
      audio.preload = 'auto';
      audio.crossOrigin = 'anonymous';
      audio.style.cssText = 'position:fixed;top:-9999px;width:1px;height:1px;opacity:0;pointer-events:none';
      document.body.appendChild(audio);

      const loaded = new Promise((resolve, reject) => {
        audio.oncanplaythrough = () => resolve();
        audio.onerror = () => reject(new Error('Audio format not supported: ' + file.name));
      });
      audio.src = URL.createObjectURL(file);
      audio.load();
      await loaded;

      if (audioCtx.state === 'suspended') await audioCtx.resume();
      const sourceNode = audioCtx.createMediaElementSource(audio);
      sourceNode.connect(audioAnalyser);

      entry.element = audio;
      entry._sourceNode = sourceNode;
      activeAudioEntry = entry;

      try { await audio.play(); }
      catch (e) {
        console.warn('Audio autoplay blocked — retry on interaction');
        const retryPlay = () => { audio.play().catch(() => {}); };
        document.addEventListener('click', retryPlay, { once: true });
      }

    } else if (type === 'svg') {
      // SVG — render to canvas texture
      const text = await file.text();
      const blob = new Blob([text], { type: 'image/svg+xml;charset=utf-8' });
      const url = URL.createObjectURL(blob);
      const img = new Image();
      await new Promise((resolve, reject) => {
        img.onload = resolve;
        img.onerror = reject;
        img.src = url;
      });
      const canvas = document.createElement('canvas');
      canvas.width = 2048;
      canvas.height = 2048;
      const ctx = canvas.getContext('2d');
      ctx.drawImage(img, 0, 0, 2048, 2048);
      URL.revokeObjectURL(url);

      entry.element = canvas;
      entry.glTexture = createGLTexture(isfRenderer.gl, canvas);
      const threeTex = new THREE.CanvasTexture(canvas);
      threeTex.needsUpdate = true;
      entry.threeTexture = threeTex;
    }

    mediaInputs.push(entry);
    renderMediaList();
    autoBindTextures();

    // Auto-switch to "Custom" shape when a model is added in scene mode
    if (type === 'model' && activeMode === 'scene') {
      currentInputValues['shape'] = 6;
      getActiveRenderer().inputValues = currentInputValues;
      window.shaderClaw.updateControlUI('shape', 6);
    }

    return entry;
  }

  async function addMediaFromWebcam() {
    const stream = await navigator.mediaDevices.getUserMedia({ video: true, audio: false });
    const id = ++mediaIdCounter;
    const entry = { id, name: 'Webcam', type: 'video', element: null, glTexture: null, threeTexture: null, threeModel: null, stream };

    const video = document.createElement('video');
    video.muted = true;
    video.playsInline = true;
    video.style.cssText = 'position:fixed;top:-9999px;width:1px;height:1px;opacity:0;pointer-events:none';
    document.body.appendChild(video);
    video.addEventListener('pause', () => { video.play().catch(() => {}); });
    video.addEventListener('stalled', () => { video.play().catch(() => {}); });

    const loaded = new Promise((resolve, reject) => {
      video.onloadeddata = () => resolve();
      video.onerror = () => reject(new Error('Webcam video failed'));
    });
    video.srcObject = stream;
    await loaded;
    await video.play();

    entry.element = video;
    entry.glTexture = createGLTexture(isfRenderer.gl, video);
    const threeTex = new THREE.VideoTexture(video);
    // Mirror webcam horizontally + vertically
    threeTex.wrapS = THREE.RepeatWrapping;
    threeTex.wrapT = THREE.RepeatWrapping;
    threeTex.repeat.x = -1;
    threeTex.repeat.y = -1;
    threeTex.offset.x = 1;
    threeTex.offset.y = 1;
    threeTex.needsUpdate = true;
    entry.threeTexture = threeTex;
    entry._webcamFlip = true; // Flag for GL horizontal flip in ISF renderer
    entry._webcamFlipV = true; // Flag for GL vertical flip

    mediaInputs.push(entry);
    renderMediaList();
    autoBindTextures();
    return entry;
  }

  async function addMediaFromDataUrl(name, dataUrl) {
    const resp = await fetch(dataUrl);
    const blob = await resp.blob();
    const file = new File([blob], name, { type: blob.type });
    return addMediaFromFile(file);
  }

  // 3D Text — generates TextGeometry mesh from user string
  async function addText3D(text) {
    const fontLoader = new THREE.FontLoader();
    const fontUrl = 'https://cdn.jsdelivr.net/npm/three@0.128.0/examples/fonts/helvetiker_regular.typeface.json';
    const font = await new Promise((resolve, reject) => {
      fontLoader.load(fontUrl, resolve, undefined, reject);
    });
    const geometry = new THREE.TextGeometry(text, {
      font: font,
      size: 0.5,
      height: 0.15,
      curveSegments: 12,
      bevelEnabled: true,
      bevelThickness: 0.02,
      bevelSize: 0.01,
      bevelSegments: 3
    });
    geometry.computeBoundingBox();
    const center = geometry.boundingBox.getCenter(new THREE.Vector3());
    geometry.translate(-center.x, -center.y, -center.z);

    const mat = new THREE.MeshStandardMaterial({ color: 0xcccccc, roughness: 0.3, metalness: 0.15 });
    const mesh = new THREE.Mesh(geometry, mat);
    const group = new THREE.Group();
    group.add(mesh);

    const id = ++mediaIdCounter;
    const entry = { id, name: '"' + text + '"', type: 'model', element: null, glTexture: null, threeTexture: null, threeModel: group };
    mediaInputs.push(entry);
    renderMediaList();
    autoBindTextures();

    if (activeMode === 'scene') {
      currentInputValues['shape'] = 6;
      getActiveRenderer().inputValues = currentInputValues;
      window.shaderClaw.updateControlUI('shape', 6);
    }
    return entry;
  }

  // Variable Font Text — renders text to canvas with animatable weight
  let _varFontEntry = null;
  let _varFontCanvas = null;
  let _varFontCtx = null;
  let _varFontText = '';
  let _varFontWeight = 400;
  let _varFontFamilyIdx = 0;

  function _renderVarFontCanvas() {
    if (!_varFontCtx || !_varFontText) return;
    const c = _varFontCanvas;
    const ctx = _varFontCtx;
    ctx.clearRect(0, 0, c.width, c.height);
    ctx.save();
    ctx.translate(0, c.height);
    ctx.scale(1, -1);
    const w = Math.round(_varFontWeight);
    const stack = _fontFamilies[_varFontFamilyIdx] || _fontFamilies[0];
    ctx.font = `${w} ${Math.round(c.height * 0.35)}px ${stack}`;
    ctx.fillStyle = '#ffffff';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(_varFontText, c.width / 2, c.height / 2);
    ctx.restore();
    // Update textures
    if (_varFontEntry) {
      if (_varFontEntry.glTexture) {
        const gl = isfRenderer.gl;
        gl.bindTexture(gl.TEXTURE_2D, _varFontEntry.glTexture);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, c);
      }
      if (_varFontEntry.threeTexture) {
        _varFontEntry.threeTexture.needsUpdate = true;
      }
    }
  }

  function addVariableFontText(text) {
    _varFontText = text;
    _varFontCanvas = document.createElement('canvas');
    _varFontCanvas.width = 2048;
    _varFontCanvas.height = 512;
    _varFontCtx = _varFontCanvas.getContext('2d');
    _renderVarFontCanvas();

    const id = ++mediaIdCounter;
    const entry = {
      id, name: 'VarFont: ' + text, type: 'image',
      element: _varFontCanvas, glTexture: createGLTexture(isfRenderer.gl, _varFontCanvas),
      threeTexture: new THREE.CanvasTexture(_varFontCanvas), threeModel: null,
      _isVarFont: true
    };
    entry.threeTexture.needsUpdate = true;
    _varFontEntry = entry;

    mediaInputs.push(entry);
    renderMediaList();
    autoBindTextures();
    return entry;
  }

  // Update variable font weight externally (called from ISF parameter or API)
  function setVarFontWeight(w) {
    _varFontWeight = Math.max(100, Math.min(900, w));
    _vfWeight = _varFontWeight; // Also update global var font texture weight
    _renderVarFontCanvas();
  }

  function setVarFontFamily(idx) {
    _varFontFamilyIdx = Math.round(idx) || 0;
    _renderVarFontCanvas();
  }

  // Mic Captions — real-time speech-to-text → canvas texture
  let _micCaptionEntry = null;
  let _micCaptionCanvas = null;
  let _micCaptionCtx = null;
  let _micCaptionText = '';
  let _micRecognition = null;

  function _renderMicCaptionCanvas() {
    if (!_micCaptionCtx) return;
    const c = _micCaptionCanvas;
    const ctx = _micCaptionCtx;
    ctx.clearRect(0, 0, c.width, c.height);
    ctx.save();
    ctx.translate(0, c.height);
    ctx.scale(1, -1);
    ctx.font = `500 ${Math.round(c.height * 0.18)}px "Inter", "Segoe UI", sans-serif`;
    ctx.fillStyle = '#ffffff';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    // Word-wrap for longer text
    const words = _micCaptionText.split(' ');
    const maxWidth = c.width * 0.9;
    const lines = [];
    let line = '';
    for (const word of words) {
      const test = line ? line + ' ' + word : word;
      if (ctx.measureText(test).width > maxWidth && line) {
        lines.push(line);
        line = word;
      } else {
        line = test;
      }
    }
    if (line) lines.push(line);
    const lineHeight = c.height * 0.22;
    const startY = c.height / 2 - ((lines.length - 1) * lineHeight) / 2;
    lines.forEach((l, i) => {
      ctx.fillText(l, c.width / 2, startY + i * lineHeight);
    });
    ctx.restore();
    // Update textures
    if (_micCaptionEntry) {
      if (_micCaptionEntry.glTexture) {
        const gl = isfRenderer.gl;
        gl.bindTexture(gl.TEXTURE_2D, _micCaptionEntry.glTexture);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, c);
      }
      if (_micCaptionEntry.threeTexture) {
        _micCaptionEntry.threeTexture.needsUpdate = true;
      }
    }
  }

  // Push mic transcription text into text-type ISF inputs (e.g. "msg")
  function _pushMicTextToShader(text) {
    const textInputs = currentInputs.filter(inp => inp.TYPE === 'text');
    if (textInputs.length === 0) return;

    function charToCode(ch) {
      if (!ch || ch === ' ') return 26;
      const c = ch.toUpperCase().charCodeAt(0) - 65;
      return (c >= 0 && c <= 25) ? c : 26;
    }

    for (const inp of textInputs) {
      const maxLen = inp.MAX_LENGTH || 12;
      // Take last maxLen chars so latest speech is visible
      const str = text.toUpperCase().slice(-maxLen);
      for (let i = 0; i < maxLen; i++) {
        currentInputValues[inp.NAME + '_' + i] = charToCode(str[i]);
      }
      currentInputValues[inp.NAME + '_len'] = str.replace(/\s+$/, '').length;

      // Update the text input field in the UI
      const rows = paramsBody.querySelectorAll('.control-row');
      for (const row of rows) {
        const label = row.querySelector('label');
        if (label && label.textContent === inp.NAME) {
          const field = row.querySelector('input[type="text"]');
          if (field) field.value = str;
          break;
        }
      }
    }
    getActiveRenderer().inputValues = currentInputValues;
  }

  function startMicCaptions() {
    const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
    if (!SpeechRecognition) {
      alert('Speech Recognition not supported in this browser. Use Chrome.');
      return;
    }

    _micCaptionCanvas = document.createElement('canvas');
    _micCaptionCanvas.width = 2048;
    _micCaptionCanvas.height = 512;
    _micCaptionCtx = _micCaptionCanvas.getContext('2d');
    _micCaptionText = '(listening...)';
    _renderMicCaptionCanvas();

    const id = ++mediaIdCounter;
    const entry = {
      id, name: 'Mic Captions', type: 'image',
      element: _micCaptionCanvas, glTexture: createGLTexture(isfRenderer.gl, _micCaptionCanvas),
      threeTexture: new THREE.CanvasTexture(_micCaptionCanvas), threeModel: null,
      _isMicCaption: true
    };
    entry.threeTexture.needsUpdate = true;
    _micCaptionEntry = entry;

    mediaInputs.push(entry);
    renderMediaList();
    autoBindTextures();

    // Start speech recognition
    _micRecognition = new SpeechRecognition();
    _micRecognition.continuous = true;
    _micRecognition.interimResults = true;

    _micRecognition.onresult = (event) => {
      let interim = '';
      let final = '';
      for (let i = event.resultIndex; i < event.results.length; i++) {
        if (event.results[i].isFinal) {
          final += event.results[i][0].transcript;
        } else {
          interim += event.results[i][0].transcript;
        }
      }
      _micCaptionText = (final || interim).trim() || '...';
      _renderMicCaptionCanvas();

      // Push transcription into any text-type ISF inputs (e.g. "msg" on the Text shader)
      _pushMicTextToShader(_micCaptionText);
    };

    _micRecognition.onerror = (e) => {
      console.warn('Speech recognition error:', e.error);
      if (e.error === 'not-allowed') {
        _micCaptionText = '(mic access denied)';
        _renderMicCaptionCanvas();
      }
    };

    _micRecognition.onend = () => {
      // Auto-restart if still in media list
      if (_micCaptionEntry && mediaInputs.includes(_micCaptionEntry)) {
        try { _micRecognition.start(); } catch(e) {}
      }
    };

    _micRecognition.start();
    return entry;
  }

  // Audio-reactive per-frame update
  function removeMedia(id) {
    const idx = mediaInputs.findIndex(m => m.id === id);
    if (idx === -1) return;
    const entry = mediaInputs[idx];
    // Cleanup GL texture
    if (entry.glTexture) {
      isfRenderer.gl.deleteTexture(entry.glTexture);
    }
    // Cleanup THREE texture
    if (entry.threeTexture) {
      entry.threeTexture.dispose();
    }
    // Cleanup webcam stream
    if (entry.stream) {
      entry.stream.getTracks().forEach(t => t.stop());
    }
    // Cleanup video element
    if (entry.type === 'video' && entry.element) {
      entry.element.pause();
      if (entry.element.src) URL.revokeObjectURL(entry.element.src);
      entry.element.src = '';
      entry.element.load();
      if (entry.element.parentNode) entry.element.parentNode.removeChild(entry.element);
    }
    // Cleanup mic captions
    if (entry._isMicCaption && _micRecognition) {
      try { _micRecognition.stop(); } catch(e) {}
      _micRecognition = null;
      _micCaptionEntry = null;
      _micCaptionText = '';
    }
    // Cleanup variable font
    if (entry._isVarFont) {
      _varFontEntry = null;
      _varFontText = '';
    }
    // Cleanup audio element
    if (entry.type === 'audio') {
      if (entry._sourceNode) {
        try { entry._sourceNode.disconnect(); } catch(e) {}
      }
      if (entry.element) {
        entry.element.pause();
        if (entry.element.src) URL.revokeObjectURL(entry.element.src);
        entry.element.src = '';
        if (entry.element.parentNode) entry.element.parentNode.removeChild(entry.element);
      }
      if (activeAudioEntry === entry) {
        activeAudioEntry = null;
        audioLevel = audioBass = audioMid = audioHigh = 0;
      }
    }
    // If removing last model while shape is "Custom", revert to Cube
    if (entry.type === 'model' && activeMode === 'scene' && currentInputValues['shape'] === 6) {
      const hasOtherModel = mediaInputs.some((m, i) => i !== idx && m.type === 'model');
      if (!hasOtherModel) {
        currentInputValues['shape'] = 0;
        getActiveRenderer().inputValues = currentInputValues;
        window.shaderClaw.updateControlUI('shape', 0);
      }
    }
    mediaInputs.splice(idx, 1);
    renderMediaList();
    autoBindTextures();
  }

  // (file input change listeners wired above via wireFileInput)

  // Restart video/audio playback when tab regains focus (Chrome pauses muted background videos)
  document.addEventListener('visibilitychange', () => {
    if (!document.hidden) {
      mediaInputs.forEach(m => {
        if (m.type === 'video' && m.element && m.element.paused) {
          m.element.play().catch(() => {});
        }
        if (m.type === 'audio' && m.element && m.element.paused && m === activeAudioEntry) {
          if (audioCtx && audioCtx.state === 'suspended') audioCtx.resume();
          m.element.play().catch(() => {});
        }
      });
    }
  });

  // --- Load default scene and start ---
  loadScene('scenes', 'spinning_cube.scene.js');

  // Handle canvas resize on panel resize
  const resizeObs = new ResizeObserver(() => {
    isfRenderer.resize();
    if (activeMode === 'scene') sceneRenderer.resize();
  });
  resizeObs.observe(document.getElementById('preview'));

  // ============================================================
  // WebSocket Client — connects to MCP server bridge
  // ============================================================

  if (location.protocol !== 'file:') {
    let ws = null;
    let reconnectTimer = null;

    function wsConnect() {
      const wsUrl = `ws://${location.host}`;
      ws = new WebSocket(wsUrl);

      ws.onopen = () => {
        if (reconnectTimer) { clearInterval(reconnectTimer); reconnectTimer = null; }
      };

      ws.onclose = () => {
        if (!reconnectTimer) {
          reconnectTimer = setInterval(() => wsConnect(), 2000);
        }
      };

      ws.onerror = () => {};

      ws.onmessage = async (evt) => {
        let msg;
        try { msg = JSON.parse(evt.data); } catch { return; }

        const { id, action, params } = msg;
        let result = null;
        let error = null;

        try {
          switch (action) {
            case 'load_shader': {
              switchToShader();
              window.shaderClaw.loadSource(params.code);
              isfRenderer.start();
              const compileResult = window.shaderClaw.getErrors();
              result = {
                ok: compileResult === null,
                errors: compileResult,
                inputs: window.shaderClaw.getInputs(),
              };
              break;
            }

            case 'load_scene': {
              await window.shaderClaw.loadScene(params.folder, params.file);
              result = {
                ok: window.shaderClaw.getErrors() === null,
                errors: window.shaderClaw.getErrors(),
                inputs: window.shaderClaw.getInputs(),
              };
              break;
            }

            case 'get_shader': {
              result = { code: window.shaderClaw.getSource() };
              break;
            }

            case 'set_parameter': {
              result = window.shaderClaw.setParameter(params.name, params.value);
              break;
            }

            case 'get_parameters': {
              result = { inputs: window.shaderClaw.getInputs() };
              break;
            }

            case 'screenshot': {
              const dataUrl = window.shaderClaw.screenshot();
              result = { dataUrl };
              break;
            }

            case 'get_errors': {
              const errs = window.shaderClaw.getErrors();
              result = { hasErrors: errs !== null, errors: errs };
              break;
            }

            case 'add_media': {
              result = await window.shaderClaw.addMedia(params.name, params.dataUrl);
              break;
            }

            case 'get_media': {
              result = { media: window.shaderClaw.getMedia() };
              break;
            }

            case 'remove_media': {
              result = window.shaderClaw.removeMedia(params.id);
              break;
            }

            case 'get_audio_levels': {
              result = window.shaderClaw.getAudioLevels();
              break;
            }

            default:
              error = `Unknown action: ${action}`;
          }
        } catch (e) {
          error = e.message;
        }

        ws.send(JSON.stringify({ id, result, error }));
      };
    }

    wsConnect();
  }

})();
</script>
</body>
</html>

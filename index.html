<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>ShaderClaw</title>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/codemirror.min.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/theme/material-darker.min.css">
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@100..900&family=Libre+Caslon+Text:ital,wght@0,400;0,700;1,400&family=Outfit:wght@100..900&display=swap" rel="stylesheet">
<style>
:root {
  --bg: #09090f;
  --panel: #111119;
  --panel-alt: #14141d;
  --border: #1c1c2a;
  --text: #c8c8d4;
  --text-dim: #555570;
  --accent: #e63946;
  --accent-dim: #e6394622;
  --green: #4ecdc4;
  --font: 'SF Mono', 'Cascadia Code', 'Fira Code', 'Consolas', monospace;
  --radius: 5px;
}

* { margin: 0; padding: 0; box-sizing: border-box; }

body {
  font-family: var(--font);
  background: var(--bg);
  color: var(--text);
  height: 100vh;
  overflow: hidden;
}

#app {
  display: grid;
  grid-template-columns: 1fr 5px 300px;
  height: 100vh;
}

/* ===== SIDEBAR ===== */
#sidebar-resize {
  width: 5px;
  cursor: col-resize;
  background: transparent;
  order: 2;
  position: relative;
  z-index: 10;
  margin-right: -5px;
  transition: background 0.15s;
}
#sidebar-resize:hover,
#sidebar-resize.active {
  background: rgba(232, 64, 87, 0.4);
}

#sidebar {
  background: var(--panel);
  border-left: 1px solid var(--border);
  border-right: none;
  display: flex;
  flex-direction: column;
  overflow: hidden;
  order: 3;
}
#sidebar-scroll {
  flex: 1;
  overflow-y: auto;
  overflow-x: hidden;
  min-height: 0;
}
#sidebar-scroll::-webkit-scrollbar { width: 4px; }
#sidebar-scroll::-webkit-scrollbar-thumb { background: var(--border); border-radius: 2px; }

#canvas-logo {
  position: absolute;
  top: 12px;
  left: 12px;
  z-index: 10;
  display: flex;
  align-items: center;
  gap: 6px;
  pointer-events: none;
  opacity: 0.7;
  transition: opacity 0.2s;
}
#canvas-logo img {
  object-fit: contain;
  border-radius: 0;
  filter: drop-shadow(0 1px 3px rgba(0,0,0,0.6));
}
#canvas-logo span {
  font-size: 13px;
  font-weight: 700;
  letter-spacing: 1px;
  color: var(--text);
  text-shadow: 0 1px 4px rgba(0,0,0,0.7);
}
#canvas-logo em {
  font-style: normal;
  color: var(--accent);
}

/* ===== LAYER PANEL ===== */
#layer-panel {
  padding: 12px;
  display: flex;
  flex-direction: column;
  gap: 10px;
}

#layer-panel::-webkit-scrollbar { width: 4px; }
#layer-panel::-webkit-scrollbar-thumb { background: var(--border); border-radius: 2px; }

.layer-card {
  background: var(--panel-alt);
  border: 1px solid var(--border);
  border-radius: var(--radius);
  overflow: hidden;
  transition: border-color 0.2s, opacity 0.2s;
}

.layer-card.focused { border-left: 2px solid var(--accent); }
.layer-card.dragging { opacity: 0.4; cursor: grabbing; z-index: 10; }
.layer-card.drag-over-top { border-top: 2px solid var(--accent); }
.layer-card.drag-over-bottom { border-bottom: 2px solid var(--accent); }

.layer-header {
  display: flex;
  align-items: center;
  gap: 10px;
  padding: 10px 14px;
  cursor: pointer;
  user-select: none;
  border-bottom: 1px solid transparent;
  transition: background 0.15s;
}

.layer-header:hover { background: rgba(255,255,255,0.02); }

.layer-card.open .layer-header { border-bottom-color: var(--border); }

.layer-chevron {
  font-size: 9px;
  color: var(--text-dim);
  transition: transform 0.2s ease-out;
  transform: rotate(-90deg);
  flex-shrink: 0;
  line-height: 1;
}

.layer-card.open .layer-chevron { transform: rotate(0deg); }

.layer-vis {
  background: none;
  border: none;
  color: var(--text);
  cursor: pointer;
  font-size: 14px;
  padding: 2px 4px;
  opacity: 0.8;
  transition: opacity 0.15s;
  line-height: 1;
  display: inline-flex;
  align-items: center;
  justify-content: center;
  width: 28px;
  height: 28px;
  flex-shrink: 0;
}

.layer-vis svg {
  width: 14px;
  height: 14px;
  flex-shrink: 0;
}

.layer-vis:hover { opacity: 1; }
.layer-vis.hidden { opacity: 0.3; }
.layer-vis.active { color: #ff4444; opacity: 1; }

.layer-name {
  font-size: 11px;
  font-weight: 600;
  letter-spacing: 1px;
  text-transform: uppercase;
  color: var(--text-dim);
  flex: 1;
}

.layer-preset-row {
  display: none;
  padding: 8px 14px;
  align-items: center;
  gap: 8px;
  border-bottom: 1px solid var(--border);
}
.layer-preset-row label {
  font-size: 11px;
  color: var(--text-dim);
  text-transform: uppercase;
  letter-spacing: 0.5px;
  white-space: nowrap;
}
.layer-card.open .layer-preset-row { display: flex; }

.layer-shader-select {
  background: var(--bg);
  color: var(--text);
  border: 1px solid var(--border);
  border-radius: 4px;
  padding: 3px 16px 3px 6px;
  font-size: 11px;
  font-family: inherit;
  cursor: pointer;
  flex: 1;
  min-width: 0;
  -webkit-appearance: none;
  -moz-appearance: none;
  appearance: none;
  background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='8' height='5' viewBox='0 0 8 5'%3E%3Cpath d='M0 0l4 4 4-4' fill='none' stroke='%23555570' stroke-width='1.2'/%3E%3C/svg%3E");
  background-repeat: no-repeat;
  background-position: right 5px center;
}

.layer-controls {
  padding: 10px 14px 0;
  display: none;
}

.layer-card.open .layer-controls { display: block; }

.layer-control-row {
  display: flex;
  align-items: center;
  gap: 10px;
  margin-bottom: 12px;
  min-height: 28px;
  font-size: 11px;
}

.layer-control-row label {
  width: 52px;
  flex-shrink: 0;
  color: var(--text-dim);
  font-size: 11px;
  text-transform: uppercase;
  letter-spacing: 1px;
}

.layer-control-row input[type="range"] {
  flex: 1;
  accent-color: var(--accent);
  height: 4px;
}

.layer-control-row .val {
  width: 36px;
  text-align: right;
  color: var(--text-dim);
  font-size: 10px;
  font-variant-numeric: tabular-nums;
}

.layer-control-row select {
  flex: 1;
  min-width: 0;
  background: var(--bg);
  color: var(--text);
  border: 1px solid var(--border);
  border-radius: 4px;
  padding: 3px 16px 3px 6px;
  font-size: 11px;
  font-family: inherit;
  cursor: pointer;
  -webkit-appearance: none;
  -moz-appearance: none;
  appearance: none;
  background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='8' height='5' viewBox='0 0 8 5'%3E%3Cpath d='M0 0l4 4 4-4' fill='none' stroke='%23555570' stroke-width='1.2'/%3E%3C/svg%3E");
  background-repeat: no-repeat;
  background-position: right 5px center;
}

.layer-params {
  max-height: 0;
  overflow: hidden;
  transition: max-height 0.2s ease-out;
  padding: 0 14px;
}

.layer-card.open .layer-params {
  max-height: 400px;
  overflow-y: auto;
  padding: 0 14px 10px;
}

.layer-params::-webkit-scrollbar { width: 4px; }
.layer-params::-webkit-scrollbar-thumb { background: var(--border); border-radius: 2px; }

.layer-params .control-row:first-child { margin-top: 0; }

/* ===== INPUTS SECTION (sidebar bottom) ===== */
#inputs-section {
  border-top: 1px solid var(--border);
}

#inputs-section .section-header {
  padding: 12px 14px;
  display: flex;
  align-items: center;
  gap: 8px;
  cursor: pointer;
  user-select: none;
  font-size: 11px;
  font-weight: 600;
  letter-spacing: 1px;
  text-transform: uppercase;
  color: var(--text-dim);
  transition: background 0.15s;
}

#inputs-section .section-header:hover { background: rgba(255,255,255,0.02); }

#inputs-section .section-chevron {
  font-size: 8px;
  color: var(--text-dim);
  transition: transform 0.2s ease-out;
  transform: rotate(-90deg);
  flex-shrink: 0;
  line-height: 1;
}

#inputs-section.open .section-chevron { transform: rotate(0deg); }

#inputs-section .section-body {
  max-height: 0;
  overflow: hidden;
  transition: max-height 0.25s ease-out;
}

#inputs-section.open .section-body {
  max-height: 500px;
  overflow-y: auto;
}

/* ===== CANVAS PANEL ===== */
#canvas-panel {
  border-bottom: 1px solid var(--border);
}

#canvas-panel .section-header {
  padding: 12px 14px;
  display: flex;
  align-items: center;
  gap: 8px;
  user-select: none;
  font-size: 11px;
  font-weight: 600;
  letter-spacing: 1px;
  text-transform: uppercase;
  color: var(--text-dim);
}

#canvas-panel .section-body {
  max-height: 0;
  overflow: hidden;
  transition: max-height 0.25s ease-out;
}

#canvas-panel.open .section-body {
  max-height: 300px;
  overflow-y: auto;
}

/* Export hub popup */
#export-hub {
  display: none;
  padding: 8px 14px 10px;
  border-bottom: 1px solid var(--border);
  background: rgba(17, 17, 25, 0.96);
}
#export-hub.show { display: block; }
.export-hub-grid {
  display: grid;
  grid-template-columns: repeat(4, 1fr);
  gap: 6px;
}
.export-tile {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 4px;
  padding: 8px 4px;
  background: rgba(255,255,255,0.03);
  border: 1px solid var(--border);
  border-radius: 6px;
  color: var(--text-dim);
  font-size: 9px;
  font-family: inherit;
  letter-spacing: 0.3px;
  cursor: pointer;
  transition: background 0.15s, color 0.15s, border-color 0.15s;
}
.export-tile:hover {
  background: rgba(255,255,255,0.07);
  color: var(--text);
  border-color: var(--text-dim);
}
.export-tile svg { opacity: 0.7; }
.export-tile:hover svg { opacity: 1; }

.canvas-option-row {
  display: flex;
  align-items: center;
  gap: 10px;
  padding: 0 14px;
  margin-bottom: 10px;
  font-size: 11px;
}
.canvas-option-row:first-child { margin-top: 8px; }
.canvas-option-row:last-child { margin-bottom: 6px; }

.canvas-option-row label {
  flex: 1;
  flex-shrink: 0;
  color: var(--text-dim);
  font-size: 11px;
  text-transform: uppercase;
  letter-spacing: 0.5px;
}

.canvas-option-row select {
  flex: 0 0 auto;
  max-width: 100px;
  background: var(--bg);
  color: var(--text);
  border: 1px solid var(--border);
  border-radius: 4px;
  padding: 4px 16px 4px 6px;
  font-size: 11px;
  font-family: inherit;
  cursor: pointer;
  margin-left: auto;
  -webkit-appearance: none;
  -moz-appearance: none;
  appearance: none;
  background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='8' height='5' viewBox='0 0 8 5'%3E%3Cpath d='M0 0l4 4 4-4' fill='none' stroke='%23555570' stroke-width='1.2'/%3E%3C/svg%3E");
  background-repeat: no-repeat;
  background-position: right 5px center;
}

.canvas-toggle-btn {
  flex: 1;
  background: var(--bg);
  color: var(--text-dim);
  border: 1px solid var(--border);
  border-radius: 10px;
  padding: 4px 12px;
  font-size: 10px;
  font-weight: 600;
  font-family: inherit;
  letter-spacing: 0.5px;
  text-transform: uppercase;
  cursor: pointer;
  transition: all 0.15s;
}

.canvas-toggle-btn:hover { border-color: var(--text-dim); color: var(--text); }
.canvas-toggle-btn.active {
  color: var(--green);
  border-color: var(--green);
}

.ndi-status-dot {
  width: 8px;
  height: 8px;
  border-radius: 50%;
  background: var(--accent);
  transition: all 0.2s;
  cursor: pointer;
  flex-shrink: 0;
  box-shadow: 0 0 4px var(--accent), 0 0 10px var(--accent);
}
.ndi-status-dot.active {
  background: var(--accent);
  box-shadow: 0 0 6px var(--accent), 0 0 14px var(--accent);
  background: rgba(78,205,196,0.08);
}
.ndi-indicator {
  display: flex; align-items: center; gap: 5px;
  padding: 3px 8px; border-radius: 10px;
  background: rgba(0,0,0,0.55); border: 1px solid var(--border);
  font-size: 9px; text-transform: uppercase; letter-spacing: 0.5px;
  color: var(--text-dim); transition: border-color 0.3s, color 0.3s;
  pointer-events: none; user-select: none;
}
.ndi-indicator.active { border-color: #4ecdc4; }
.ndi-indicator.active .ndi-label { color: #4ecdc4; }
.ndi-indicator.active .ndi-dot {
  background: #4ecdc4;
  box-shadow: 0 0 4px #4ecdc4, 0 0 8px rgba(78,205,196,0.4);
}
.ndi-dot {
  width: 6px; height: 6px; border-radius: 50%;
  background: #555; transition: background 0.3s, box-shadow 0.3s;
}

.canvas-bg-extra {
  padding: 0 10px 6px 80px;
}

.canvas-bg-extra input[type="color"] {
  width: 32px;
  height: 22px;
  border: 1px solid var(--border);
  border-radius: 3px;
  background: var(--bg);
  cursor: pointer;
  padding: 0;
}

.canvas-bg-extra select {
  width: 100%;
  background: var(--bg);
  color: var(--text);
  border: 1px solid var(--border);
  border-radius: 3px;
  padding: 2px 4px;
  font-size: 10px;
  font-family: inherit;
  cursor: pointer;
}

/* ===== SHADER BROWSER OVERLAY ===== */
#shader-browser {
  display: none;
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  width: 480px;
  max-height: 70vh;
  background: rgba(17, 17, 25, 0.96);
  backdrop-filter: blur(16px);
  -webkit-backdrop-filter: blur(16px);
  border: 1px solid var(--border);
  border-radius: 10px;
  box-shadow: 0 16px 64px rgba(0,0,0,0.6);
  z-index: 1000;
  overflow: hidden;
}

#shader-browser.visible { display: flex; flex-direction: column; }

#shader-browser .browser-header {
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 10px 14px;
  border-bottom: 1px solid var(--border);
}

#shader-browser .browser-search {
  flex: 1;
  background: var(--bg);
  color: var(--text);
  border: 1px solid var(--border);
  border-radius: 4px;
  padding: 5px 8px;
  font-size: 12px;
  font-family: inherit;
  outline: none;
}

#shader-browser .browser-search:focus { border-color: var(--accent); }

#shader-browser .browser-close {
  background: none;
  border: none;
  color: var(--text-dim);
  cursor: pointer;
  font-size: 16px;
  padding: 2px 4px;
}

#shader-browser .browser-close:hover { color: var(--text); }

#shader-browser .browser-body {
  overflow-y: auto;
  padding: 8px;
  flex: 1;
}

#shader-browser .browser-body::-webkit-scrollbar { width: 4px; }
#shader-browser .browser-body::-webkit-scrollbar-thumb { background: var(--border); border-radius: 2px; }

.browser-category {
  margin-bottom: 8px;
}

.browser-category-title {
  font-size: 9px;
  font-weight: 700;
  letter-spacing: 1.5px;
  color: var(--text-dim);
  text-transform: uppercase;
  padding: 4px 4px 2px;
}

.browser-grid {
  display: grid;
  grid-template-columns: repeat(3, 1fr);
  gap: 4px;
}

.browser-item {
  background: rgba(30, 30, 42, 0.6);
  border: 1px solid var(--border);
  border-radius: 5px;
  padding: 6px 8px;
  cursor: pointer;
  font-size: 11px;
  color: var(--text);
  transition: background 0.15s, border-color 0.15s;
  text-align: center;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.browser-item:hover {
  background: rgba(40, 40, 56, 0.8);
  border-color: var(--text-dim);
}

.browser-item.active {
  background: var(--accent-dim);
  border-color: var(--accent);
}

#shader-browser-backdrop {
  display: none;
  position: fixed;
  inset: 0;
  background: rgba(0,0,0,0.4);
  z-index: 999;
}

#shader-browser-backdrop.visible { display: block; }

/* ===== MEDIAPIPE LOADING ===== */
.mp-loading {
  display: flex;
  align-items: center;
  gap: 6px;
  padding: 6px 10px;
  font-size: 10px;
  color: var(--text-dim);
}

.mp-loading .spinner {
  width: 12px;
  height: 12px;
  border: 2px solid var(--border);
  border-top-color: var(--accent);
  border-radius: 50%;
  animation: spin 0.8s linear infinite;
}

@keyframes spin {
  to { transform: rotate(360deg); }
}


/* ===== MAIN PANEL ===== */
#main {
  display: flex;
  flex-direction: column;
  overflow: hidden;
  position: relative;
  order: 1;
}

#preview {
  position: relative;
  flex: 1;
  background: #000;
}

#gl-canvas, #three-canvas {
  width: 100%;
  height: 100%;
  display: block;
  position: absolute;
  top: 0;
  left: 0;
}

#three-canvas { display: none; }
#overlay-gizmo {
  position: absolute;
  top: 0; left: 0;
  width: 100%; height: 100%;
  pointer-events: none;
  z-index: 5;
}

.canvas-controls {
  position: absolute;
  top: 8px;
  right: 8px;
  display: flex;
  gap: 4px;
}

.canvas-btn {
  background: #000000aa;
  border: 1px solid var(--border);
  color: var(--text);
  width: 28px;
  height: 28px;
  border-radius: 4px;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 14px;
  transition: background 0.15s;
}

.canvas-btn:hover { background: #000000dd; }

#error-bar {
  position: absolute;
  bottom: 0;
  left: 0;
  right: 0;
  background: #e6394620;
  border-top: 1px solid var(--accent);
  color: var(--accent);
  font-size: 11px;
  padding: 6px 12px;
  display: none;
  max-height: 80px;
  overflow-y: auto;
  white-space: pre-wrap;
  font-family: var(--font);
}

#error-bar.show { display: block; }

/* Params panels are now inline in layer cards — no floating panel styles needed */

.control-row {
  display: flex;
  align-items: center;
  gap: 10px;
  margin-bottom: 12px;
  min-height: 28px;
  font-size: 11px;
}

.control-row:last-child { margin-bottom: 0; }

.control-row label {
  width: 80px;
  flex-shrink: 0;
  color: var(--text-dim);
  text-overflow: ellipsis;
  overflow: hidden;
  white-space: nowrap;
  font-size: 11px;
  text-transform: uppercase;
  letter-spacing: 1px;
}

.control-row input[type="range"] {
  flex: 1;
  accent-color: var(--accent);
  height: 4px;
}

.control-row input[type="color"] {
  width: 34px;
  height: 28px;
  border: 1px solid var(--border);
  border-radius: 4px;
  background: none;
  cursor: pointer;
  padding: 0;
}

.control-row select {
  flex: 0 0 auto;
  margin-left: auto;
  background: var(--bg);
  color: var(--text);
  border: 1px solid var(--border);
  border-radius: 4px;
  padding: 4px 16px 4px 8px;
  font-size: 11px;
  font-family: inherit;
  cursor: pointer;
  -webkit-appearance: none;
  -moz-appearance: none;
  appearance: none;
  background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='8' height='5' viewBox='0 0 8 5'%3E%3Cpath d='M0 0l4 4 4-4' fill='none' stroke='%23555570' stroke-width='1.2'/%3E%3C/svg%3E");
  background-repeat: no-repeat;
  background-position: right 5px center;
  max-width: 130px;
}

.control-row input[type="text"] {
  flex: 1;
  min-width: 0;
  background: var(--bg);
  color: var(--text);
  border: 1px solid var(--border);
  border-radius: 4px;
  padding: 5px 10px;
  font-size: 12px;
  font-family: monospace;
  letter-spacing: 1px;
  text-transform: uppercase;
  max-width: 200px;
}

.text-msg-bar, .voice-transcript-bar {
  display: none;
}
.layer-card.open .text-msg-bar,
.layer-card.open .voice-transcript-bar {
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 8px 14px;
  border-bottom: 1px solid var(--border);
}
.text-msg-bar input[type="text"] {
  flex: 1;
  min-width: 0;
  background: var(--bg);
  color: #fff;
  border: 1px solid var(--border);
  border-radius: var(--radius);
  padding: 5px 10px;
  font-size: 13px;
  font-family: monospace;
  font-weight: 600;
  letter-spacing: 2px;
  text-transform: uppercase;
}
.text-msg-bar input[type="text"]:focus {
  outline: none;
  border-color: var(--accent);
  box-shadow: 0 0 4px var(--accent-dim);
}
.voice-transcript-bar input[type="text"] {
  flex: 1;
  min-width: 0;
  background: var(--bg);
  color: var(--text-dim);
  border: 1px solid var(--border);
  border-radius: var(--radius);
  padding: 5px 10px;
  font-size: 11px;
  font-family: monospace;
  letter-spacing: 1px;
  text-transform: uppercase;
  cursor: default;
}
.overlay-upload-btn, .overlay-clear-btn {
  background: var(--bg);
  color: var(--text-dim);
  border: 1px solid var(--border);
  border-radius: 4px;
  padding: 3px 10px;
  font-size: 10px;
  font-family: inherit;
  cursor: pointer;
  text-transform: uppercase;
  letter-spacing: 0.5px;
  transition: color 0.15s, border-color 0.15s;
}
.overlay-upload-btn:hover, .overlay-clear-btn:hover {
  color: var(--text);
  border-color: var(--text-dim);
}
#scene-model-btn {
  width: 100%;
  padding: 8px;
  font-size: 10px;
  text-transform: uppercase;
  letter-spacing: 0.5px;
  border: 1px dashed var(--border);
  border-radius: 4px;
  background: transparent;
  color: var(--text-dim);
  cursor: pointer;
  transition: border-color 0.15s, color 0.15s;
}
#scene-model-btn:hover {
  border-color: var(--text-dim);
  color: var(--text);
}
.cam-toggle-row {
  display: flex;
  align-items: center;
  justify-content: space-between;
  min-height: 28px;
  margin-bottom: 12px;
}
.cam-toggle-row label {
  font-size: 11px;
  color: var(--text-dim);
  text-transform: uppercase;
  letter-spacing: 1px;
}
.cam-switch {
  position: relative;
  width: 32px;
  height: 16px;
  background: var(--border);
  border-radius: 8px;
  cursor: pointer;
  transition: background 0.2s;
  border: none;
  padding: 0;
}
.cam-switch::after {
  content: '';
  position: absolute;
  top: 2px;
  left: 2px;
  width: 12px;
  height: 12px;
  background: var(--text-dim);
  border-radius: 50%;
  transition: transform 0.2s, background 0.2s;
}
.cam-switch.active {
  background: rgba(78, 205, 196, 0.3);
}
.cam-switch.active::after {
  transform: translateX(16px);
  background: #4ecdc4;
}

.mp-modes-row {
  gap: 4px;
  padding: 2px 8px 6px;
}
.mp-mode-btn {
  flex: 1;
  display: flex; flex-direction: column; align-items: center; gap: 3px;
  background: var(--bg);
  color: var(--text-dim);
  border: 1px solid var(--border);
  border-radius: 4px;
  padding: 6px 4px 4px;
  font-size: 9px;
  font-family: inherit;
  cursor: pointer;
  text-transform: uppercase;
  letter-spacing: 0.3px;
  transition: color 0.15s, border-color 0.15s, background 0.15s;
}
.mp-mode-btn svg { stroke: currentColor; transition: stroke 0.15s; }
.mp-mode-btn:hover {
  color: var(--text);
  border-color: var(--text-dim);
}
.mp-mode-btn.active {
  color: #4ecdc4;
  border-color: #4ecdc4;
  background: rgba(78, 205, 196, 0.08);
}
.mp-mode-btn.active svg { stroke: #4ecdc4; }

.mp-map-btn {
  width: 20px; height: 20px; padding: 0; margin-left: 2px;
  background: none; border: 1px solid transparent; border-radius: 3px;
  cursor: pointer; opacity: 0.35; transition: opacity 0.15s, border-color 0.15s;
  display: flex; align-items: center; justify-content: center; flex-shrink: 0;
}
.mp-map-btn svg { stroke: var(--text-dim); }
.mp-map-btn:hover { opacity: 0.7; border-color: var(--border); }
.mp-map-btn.linked {
  opacity: 1; border-color: #4ecdc4;
}
.mp-map-btn.linked svg { stroke: #4ecdc4; filter: drop-shadow(0 0 3px rgba(78,205,196,0.5)); }

.mp-picker {
  position: fixed; z-index: 1000; width: 180px; max-height: 290px;
  background: var(--bg-dark, #1a1a2e); border: 1px solid var(--border);
  border-radius: 6px; box-shadow: 0 4px 16px rgba(0,0,0,0.5);
  display: flex; flex-direction: column; overflow: hidden;
  font-size: 10px;
}
.mp-picker-tabs {
  display: flex; border-bottom: 1px solid var(--border);
}
.mp-picker-tab {
  flex: 1; padding: 5px 4px; text-align: center; cursor: pointer;
  background: none; border: none; color: var(--text-dim);
  font-size: 9px; text-transform: uppercase; letter-spacing: 0.3px;
  font-family: inherit; transition: color 0.15s, background 0.15s;
}
.mp-picker-tab:hover { color: var(--text); }
.mp-picker-tab.active { color: #4ecdc4; background: rgba(78,205,196,0.08); }
.mp-picker-list {
  flex: 1; overflow-y: auto; padding: 2px 0;
}
.mp-picker-list-item {
  padding: 4px 8px; cursor: pointer; color: var(--text-dim);
  transition: background 0.1s, color 0.1s;
}
.mp-picker-list-item:hover { background: rgba(255,255,255,0.05); color: var(--text); }
.mp-picker-list-item.selected { color: #4ecdc4; background: rgba(78,205,196,0.1); }
.mp-picker-axis {
  display: flex; gap: 2px; padding: 5px 8px; border-top: 1px solid var(--border);
}
.mp-picker-axis label {
  flex: 1; display: flex; align-items: center; justify-content: center;
  gap: 3px; cursor: pointer; padding: 3px; border-radius: 3px;
  color: var(--text-dim); font-size: 9px; text-transform: uppercase;
  transition: color 0.15s, background 0.15s;
}
.mp-picker-axis input[type="radio"] { display: none; }
.mp-picker-axis input[type="radio"]:checked + span {
  color: #4ecdc4;
}
.mp-picker-axis label:has(input:checked) {
  background: rgba(78,205,196,0.1); color: #4ecdc4;
}
.mp-picker-clear {
  margin: 4px 8px 6px; padding: 4px; background: none;
  border: 1px solid rgba(255,80,80,0.4); border-radius: 3px;
  color: #ff5050; font-size: 9px; cursor: pointer; font-family: inherit;
  text-transform: uppercase; letter-spacing: 0.3px;
  transition: background 0.15s, border-color 0.15s;
}
.mp-picker-clear:hover { background: rgba(255,80,80,0.1); border-color: #ff5050; }

/* === Body Tracking Panel — expanded styles === */
.bt-section-header {
  display: flex; align-items: center; gap: 6px; padding: 6px 8px;
  cursor: pointer; font-size: 10px; text-transform: uppercase; letter-spacing: 0.5px;
  color: var(--text-dim); user-select: none; transition: color 0.15s;
}
.bt-section-header:hover { color: var(--text); }
.bt-section-header .bt-chevron {
  font-size: 8px; transition: transform 0.2s; display: inline-block;
}
.bt-section-header.open .bt-chevron { transform: rotate(90deg); }
.bt-section-body { display: none; padding: 0 8px 6px; }
.bt-section-header.open + .bt-section-body { display: block; }

/* Signal bars */
.bt-signal-row {
  display: flex; align-items: center; gap: 4px; height: 18px; margin-bottom: 3px;
}
.bt-signal-label {
  width: 76px; font-size: 9px; color: var(--text-dim); overflow: hidden;
  text-overflow: ellipsis; white-space: nowrap; flex-shrink: 0;
}
.bt-signal-bar {
  flex: 1; height: 8px; background: rgba(255,255,255,0.06); border-radius: 4px;
  overflow: hidden; position: relative;
}
.bt-signal-fill {
  height: 100%; border-radius: 4px; transition: width 0.08s linear;
  min-width: 1px;
}
.bt-signal-fill.hand { background: rgba(78,205,196,0.6); }
.bt-signal-fill.face { background: rgba(255,127,80,0.6); }
.bt-signal-fill.pose { background: rgba(255,215,0,0.5); }
.bt-signal-val {
  width: 30px; font-size: 9px; color: var(--text-dim); text-align: right;
  font-variant-numeric: tabular-nums; flex-shrink: 0;
}
.bt-signal-link {
  width: 16px; height: 16px; padding: 0; background: none; border: none;
  cursor: pointer; opacity: 0.3; font-size: 10px; color: var(--text-dim);
  flex-shrink: 0; transition: opacity 0.15s;
}
.bt-signal-link:hover { opacity: 0.8; color: #4ecdc4; }

/* Link rows */
.bt-link-row {
  display: flex; align-items: center; gap: 4px; padding: 3px 0;
  font-size: 9px; border-bottom: 1px solid rgba(255,255,255,0.04);
}
.bt-link-source { color: #4ecdc4; flex-shrink: 0; }
.bt-link-arrow { color: var(--text-dim); margin: 0 2px; }
.bt-link-target { color: var(--text); flex: 1; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
.bt-link-value {
  width: 34px; text-align: right; color: var(--text-dim);
  font-variant-numeric: tabular-nums; flex-shrink: 0;
}
.bt-link-remove {
  width: 16px; height: 16px; padding: 0; background: none; border: none;
  cursor: pointer; color: rgba(255,80,80,0.5); font-size: 12px;
  flex-shrink: 0; transition: color 0.15s;
}
.bt-link-remove:hover { color: #ff5050; }

/* Action buttons */
.bt-actions { display: flex; gap: 4px; margin-top: 6px; }
.bt-action-btn {
  flex: 1; padding: 4px 6px; background: rgba(255,255,255,0.04);
  border: 1px solid var(--border); border-radius: 4px;
  color: var(--text-dim); font-size: 9px; font-family: inherit;
  cursor: pointer; text-transform: uppercase; letter-spacing: 0.3px;
  transition: background 0.15s, color 0.15s, border-color 0.15s;
  text-align: center;
}
.bt-action-btn:hover { background: rgba(255,255,255,0.08); color: var(--text); }
.bt-map-btn.active {
  color: #4ecdc4; border-color: #4ecdc4;
  animation: bt-pulse 1.2s ease-in-out infinite;
}

/* Link count badge */
.bt-link-count {
  background: rgba(78,205,196,0.25); color: #4ecdc4;
  font-size: 8px; padding: 1px 5px; border-radius: 8px;
  margin-left: auto; font-variant-numeric: tabular-nums;
}

/* Recording UI */
.bt-rec-row {
  display: flex; align-items: center; gap: 4px; margin-top: 6px;
}
.bt-rec-btn {
  width: 28px; height: 22px; padding: 0; border-radius: 4px;
  font-size: 9px; font-family: inherit; cursor: pointer;
  border: 1px solid var(--border); background: rgba(255,255,255,0.04);
  color: var(--text-dim); transition: all 0.15s; text-align: center;
}
.bt-rec-btn:hover { background: rgba(255,255,255,0.08); color: var(--text); }
.bt-rec-btn:disabled { opacity: 0.3; cursor: default; }
.bt-rec-btn.recording {
  background: rgba(255,60,60,0.15); border-color: #ff3c3c; color: #ff3c3c;
  animation: bt-pulse 0.8s ease-in-out infinite;
}
.bt-rec-btn.playing {
  background: rgba(78,205,196,0.15); border-color: #4ecdc4; color: #4ecdc4;
}
.bt-rec-timer {
  font-size: 10px; color: var(--text-dim); font-variant-numeric: tabular-nums;
  margin-left: 4px;
}

@keyframes bt-pulse {
  0%, 100% { opacity: 1; }
  50% { opacity: 0.5; }
}

/* Quick-link mode: pulse all mp-map buttons */
.quicklink-active .mp-map-btn {
  animation: bt-pulse 1s ease-in-out infinite;
  opacity: 0.7; border-color: rgba(78,205,196,0.4);
}

.control-row .val {
  width: 44px;
  text-align: right;
  color: var(--text-dim);
  font-size: 10px;
  font-variant-numeric: tabular-nums;
}

.no-params {
  color: var(--text-dim);
  font-size: 11px;
  text-align: center;
  padding: 12px 0;
}

/* mask/bg rows removed — layers replace background system */

/* ===== SECTION HEADERS ===== */
.section-header {
  font-size: 10px;
  font-weight: 700;
  letter-spacing: 1.5px;
  color: var(--text-dim);
  text-transform: uppercase;
  padding: 14px 14px 6px;
}

.section-header:first-child { padding-top: 6px; }

.import-grid {
  display: grid;
  grid-template-columns: repeat(3, 1fr);
  gap: 8px;
  padding: 10px 14px;
  border-bottom: 1px solid var(--border);
}

.import-tile {
  background: rgba(30, 30, 42, 0.6);
  border: 1px solid var(--border);
  color: var(--text-dim);
  border-radius: 6px;
  cursor: pointer;
  padding: 10px 6px 8px;
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 4px;
  transition: color 0.15s, border-color 0.15s, background 0.15s;
  font-family: inherit;
}

.import-tile:hover {
  color: var(--text);
  border-color: var(--text-dim);
  background: rgba(40, 40, 56, 0.8);
}

.import-tile svg { opacity: 0.7; }
.import-tile:hover svg { opacity: 1; }

.import-tile span {
  font-size: 9px;
  letter-spacing: 0.3px;
  text-transform: uppercase;
}

.import-tile.active {
  border-color: var(--accent);
  background: rgba(230, 57, 70, 0.12);
  color: var(--accent);
}

.import-tile.active svg { opacity: 1; stroke: var(--accent); }

.media-item {
  padding: 8px 12px;
  border-radius: 5px;
  cursor: pointer;
  font-size: 11px;
  display: flex;
  align-items: center;
  gap: 8px;
  transition: background 0.15s;
}

.media-item:hover { background: var(--panel-alt); }

.media-item .media-icon {
  font-size: 12px;
  flex-shrink: 0;
  width: 16px;
  text-align: center;
}

.media-item .media-name {
  flex: 1;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
  color: var(--text);
}

.media-item .media-delete {
  background: none;
  border: none;
  color: var(--text-dim);
  cursor: pointer;
  font-size: 11px;
  padding: 0 2px;
  opacity: 0;
  transition: opacity 0.15s, color 0.15s;
}

.media-item:hover .media-delete { opacity: 1; }
.media-item .media-delete:hover { color: var(--accent); }

.media-item .flip-toggle {
  background: none;
  border: 1px solid var(--border);
  color: var(--text-dim);
  border-radius: 3px;
  padding: 0 4px;
  font-size: 9px;
  font-family: inherit;
  cursor: pointer;
  transition: all 0.15s;
  flex-shrink: 0;
  line-height: 16px;
}
.media-item .flip-toggle:hover { color: var(--text); border-color: var(--text-dim); }
.media-item .flip-toggle.active { color: var(--green); border-color: var(--green); background: rgba(78,205,196,0.1); }

.layer-control-row .flip-toggle {
  background: none;
  border: 1px solid var(--border);
  color: var(--text-dim);
  border-radius: 3px;
  padding: 2px 8px;
  font-size: 9px;
  font-family: inherit;
  cursor: pointer;
  transition: all 0.15s;
  line-height: 20px;
  margin-right: 4px;
}
.layer-control-row .flip-toggle:hover { color: var(--text); border-color: var(--text-dim); }
.layer-control-row .flip-toggle.active { color: var(--green); border-color: var(--green); background: rgba(78,205,196,0.1); }

.text-mic-btn {
  background: none;
  border: 1px solid var(--border);
  color: var(--text-dim);
  border-radius: 3px;
  cursor: pointer;
  font-size: 11px;
  padding: 1px 4px;
  margin-left: 4px;
  transition: color 0.15s, border-color 0.15s, background 0.15s;
  flex-shrink: 0;
}
.text-mic-btn:hover { color: var(--text); border-color: var(--text-dim); }
.text-mic-btn.active { color: #ff4444; border-color: #ff4444; background: rgba(255,68,68,0.1); }

.media-item .audio-bar {
  width: 30px;
  height: 6px;
  background: rgba(40, 40, 56, 0.8);
  border-radius: 3px;
  overflow: hidden;
  flex-shrink: 0;
}

.media-item .audio-bar-fill {
  height: 100%;
  width: 0%;
  background: #4ecdc4;
  border-radius: 3px;
  transition: width 0.05s;
}

.media-item .audio-toggle {
  background: none;
  border: none;
  color: var(--text-dim);
  cursor: pointer;
  font-size: 10px;
  padding: 0 2px;
  flex-shrink: 0;
}

.media-item .audio-toggle:hover { color: var(--text); }

/* Inputs section is now in the sidebar, not floating */
#inputs-section .media-list {
  padding: 4px 0;
  max-height: 200px;
  overflow-y: auto;
}

#inputs-section .media-list:empty {
  padding: 8px 12px;
}

#inputs-section .media-list:empty::after {
  content: 'No media';
  color: var(--text-dim);
  font-size: 10px;
}

/* Drag/BG styles removed — layers replace background system */

#ndi-source-picker {
  position: fixed;
  top: 0; left: 0; right: 0; bottom: 0;
  z-index: 9999;
  background: rgba(0,0,0,0.6);
  backdrop-filter: blur(4px);
  display: none;
  align-items: center;
  justify-content: center;
}

#ndi-source-picker.visible { display: flex; }

#ndi-source-picker .picker-box {
  background: var(--panel);
  border: 1px solid var(--border);
  border-radius: 8px;
  min-width: 280px;
  max-width: 400px;
  box-shadow: 0 12px 48px rgba(0,0,0,0.6);
  overflow: hidden;
}

#ndi-source-picker .picker-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 10px 14px;
  border-bottom: 1px solid var(--border);
  background: rgba(22, 22, 31, 0.6);
}

#ndi-source-picker .picker-header .title {
  font-size: 11px;
  font-weight: 600;
  letter-spacing: 0.5px;
  color: var(--text);
}

#ndi-source-picker .picker-close {
  background: none;
  border: none;
  color: var(--text-dim);
  cursor: pointer;
  font-size: 14px;
}

#ndi-source-picker .picker-close:hover { color: var(--text); }

#ndi-source-picker .picker-body {
  padding: 6px 0;
  max-height: 300px;
  overflow-y: auto;
}

#ndi-source-picker .picker-body:empty::after {
  content: 'Searching for NDI sources...';
  display: block;
  padding: 16px;
  color: var(--text-dim);
  font-size: 11px;
  text-align: center;
}

.ndi-source-item {
  padding: 8px 14px;
  font-size: 12px;
  cursor: pointer;
  display: flex;
  align-items: center;
  gap: 8px;
  transition: background 0.15s;
  color: var(--text);
}

.ndi-source-item:hover { background: var(--panel-alt); }

.ndi-source-item .ndi-dot {
  width: 6px;
  height: 6px;
  border-radius: 50%;
  background: var(--green);
  flex-shrink: 0;
}

.ndi-source-item .ndi-src-name {
  flex: 1;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}

.ndi-source-item .ndi-src-addr {
  font-size: 9px;
  color: var(--text-dim);
}

.ndi-refresh-btn {
  display: block;
  width: calc(100% - 16px);
  margin: 4px 8px 8px;
  padding: 6px;
  background: rgba(30, 30, 42, 0.6);
  border: 1px solid var(--border);
  color: var(--text-dim);
  border-radius: 4px;
  cursor: pointer;
  font-size: 10px;
  font-family: inherit;
  transition: color 0.15s, border-color 0.15s;
}

.ndi-refresh-btn:hover { color: var(--text); border-color: var(--text-dim); }

/* Editor — hidden, kept functional for MCP */
#editor-area {
  display: none;
}

/* Scrollbar global */
::-webkit-scrollbar { width: 6px; }
::-webkit-scrollbar-track { background: transparent; }
::-webkit-scrollbar-thumb { background: var(--border); border-radius: 3px; }

/* ===== MOBILE RESPONSIVE ===== */
#mobile-drag-handle { display: none; }

@media (max-width: 768px) {
  #app {
    grid-template-columns: 1fr;
    grid-template-rows: 36vh auto 1fr;
    height: 100vh;
    height: 100dvh;
  }

  #sidebar-resize { display: none; }

  #mobile-drag-handle {
    display: flex;
    align-items: center;
    justify-content: center;
    height: 20px;
    background: var(--bg);
    border-top: 1px solid var(--border);
    border-bottom: 1px solid var(--border);
    cursor: row-resize;
    touch-action: none;
    z-index: 10;
    order: 2;
    flex-shrink: 0;
  }
  .drag-pill {
    width: 36px;
    height: 4px;
    border-radius: 2px;
    background: rgba(255,255,255,0.25);
  }

  #sidebar {
    order: 3;
    border-left: none;
    border-top: 1px solid var(--border);
    overflow-y: auto;
    -webkit-overflow-scrolling: touch;
  }

  #sidebar-scroll {
    padding-bottom: env(safe-area-inset-bottom, 0);
  }

  #preview {
    order: 1;
    min-height: 0;
  }

  #main {
    order: 1;
    min-height: 0;
  }


  /* Canvas controls — touch-friendly */
  .canvas-controls {
    gap: 6px;
    top: 6px;
    right: 6px;
  }

  .canvas-btn {
    width: 36px;
    height: 36px;
    font-size: 15px;
    border-radius: 6px;
  }

  /* Layer panel spacing */
  #layer-panel {
    padding: 10px;
    gap: 8px;
  }

  .layer-card {
    border-radius: 8px;
  }

  .layer-header {
    padding: 10px 12px;
    gap: 8px;
    min-height: 44px;
  }

  .layer-name {
    font-size: 11px;
  }

  .layer-vis {
    font-size: 16px;
    padding: 4px 6px;
    min-width: 32px;
    min-height: 32px;
    display: flex;
    align-items: center;
    justify-content: center;
  }

  .layer-shader-select {
    font-size: 12px;
    padding: 6px 20px 6px 8px;
    min-height: 32px;
  }

  .layer-preset-row {
    padding: 8px 12px;
  }

  .layer-controls {
    padding: 10px 12px;
  }

  .layer-control-row {
    gap: 10px;
    margin-bottom: 12px;
    min-height: 36px;
  }

  .layer-control-row label {
    font-size: 11px;
    width: 56px;
  }

  .layer-control-row input[type="range"] {
    height: 6px;
  }

  .layer-control-row select {
    font-size: 12px;
    padding: 6px 20px 6px 8px;
    min-height: 32px;
  }

  /* Params controls — breathing room */
  .layer-card.open .layer-params {
    padding: 10px 12px;
  }

  .control-row {
    gap: 8px;
    margin-bottom: 14px;
    min-height: 36px;
  }

  .control-row label {
    width: 72px;
    font-size: 10px;
  }

  .control-row input[type="range"] {
    height: 6px;
  }

  .control-row select {
    font-size: 12px;
    padding: 6px 20px 6px 8px;
    min-height: 32px;
  }

  .control-row input[type="text"] {
    font-size: 13px;
    padding: 8px 10px;
    min-height: 36px;
  }

  /* Text / Voice bars */
  .layer-card.open .text-msg-bar,
  .layer-card.open .voice-transcript-bar {
    padding: 10px 12px;
  }

  .text-msg-bar input[type="text"],
  .voice-transcript-bar input[type="text"] {
    font-size: 14px;
    padding: 8px 12px;
    min-height: 40px;
  }

  /* Overlay buttons */
  .overlay-upload-btn, .overlay-clear-btn {
    padding: 6px 14px;
    font-size: 11px;
    min-height: 32px;
  }

  /* Canvas panel */
  .canvas-option-row {
    padding: 0 12px;
    margin-bottom: 12px;
    min-height: 36px;
  }

  .canvas-option-row select {
    font-size: 12px;
    padding: 6px 20px 6px 8px;
    min-height: 32px;
  }

  #canvas-panel .section-header,
  #inputs-section .section-header {
    padding: 14px;
    font-size: 11px;
  }

  /* Import grid — larger touch targets */
  .import-grid {
    grid-template-columns: repeat(auto-fill, minmax(64px, 1fr));
    gap: 6px;
    padding: 8px 12px;
  }

  .import-tile {
    padding: 10px 6px 8px;
    border-radius: 8px;
    min-height: 56px;
  }

  .import-tile svg {
    width: 20px;
    height: 20px;
  }

  .import-tile span {
    font-size: 8px;
  }

  /* Popups */
  #ndi-source-picker .picker-box {
    min-width: 240px;
    max-width: 90vw;
  }

  #shader-browser {
    width: 92vw;
    max-height: 60vh;
    border-radius: 12px;
  }

  .browser-grid {
    grid-template-columns: repeat(2, 1fr);
    gap: 6px;
  }

  .browser-item {
    padding: 10px 8px;
    font-size: 12px;
    border-radius: 8px;
  }
}

@media (max-width: 480px) {
  #app {
    grid-template-rows: 32vh auto 1fr;
  }

  .layer-name {
    font-size: 10px;
  }

  .canvas-controls {
    flex-wrap: wrap;
  }

  .canvas-btn {
    width: 32px;
    height: 32px;
    font-size: 13px;
  }

  .layer-shader-select {
    font-size: 11px;
  }

  .import-grid {
    grid-template-columns: repeat(auto-fill, minmax(52px, 1fr));
  }
}

/* Touch device enhancements */
@media (hover: none) and (pointer: coarse) {
  input[type="range"] {
    height: 8px;
  }

  input[type="range"]::-webkit-slider-thumb {
    width: 20px;
    height: 20px;
  }

  .layer-vis, .canvas-btn, .overlay-upload-btn, .overlay-clear-btn,
  .import-tile, .flip-toggle, .canvas-toggle-btn {
    -webkit-tap-highlight-color: transparent;
  }

  /* Prevent zoom on input focus */
  input[type="text"], select {
    font-size: 16px !important;
  }
}
</style>
</head>
<body>

<div id="app">
  <!-- SIDEBAR -->
  <div id="sidebar-resize"></div>
  <div id="sidebar">
    <div id="sidebar-scroll">
    <!-- Canvas Panel -->
    <div id="canvas-panel" class="open">
      <div class="section-header">Canvas <span style="flex:1"></span><button id="export-hub-btn" style="font-size:10px;padding:3px 12px;letter-spacing:0.8px;font-weight:600;font-family:inherit;background:transparent;color:#e84057;border:1.5px solid #e84057;border-radius:4px;cursor:pointer;text-transform:uppercase;transition:background 0.15s,color 0.15s">EXPORT</button></div>
      <div class="section-body">
        <div class="canvas-option-row">
          <label>Background</label>
          <select id="canvas-bg-select">
            <option value="none">Black</option>
            <option value="transparent">Transparent</option>
            <option value="color">Color</option>
            <option value="image">Image</option>
            <option value="video">Video</option>
            <option value="shader">Shader</option>
            <option value="webcam">Webcam</option>
            <option value="ndi">NDI Input</option>
          </select>
        </div>
        <div class="canvas-bg-extra" id="bg-color-row" style="display:none">
          <input type="color" id="bg-color-picker" value="#000000">
        </div>
        <div class="canvas-bg-extra" id="bg-shader-row" style="display:none">
          <select id="bg-shader-select"></select>
        </div>
      </div>
    </div>

    <!-- Export Hub Popup -->
    <div id="export-hub">
      <div class="export-hub-grid">
        <button data-action="window" class="export-tile">
          <svg viewBox="0 0 24 24" width="20" height="20" fill="none" stroke="currentColor" stroke-width="1.5"><rect x="2" y="3" width="20" height="14" rx="2"/><line x1="8" y1="21" x2="16" y2="21"/><line x1="12" y1="17" x2="12" y2="21"/></svg>
          <span>Window</span>
        </button>
        <button data-action="screenshot" class="export-tile">
          <svg viewBox="0 0 24 24" width="20" height="20" fill="none" stroke="currentColor" stroke-width="1.5"><rect x="3" y="3" width="18" height="18" rx="2"/><circle cx="12" cy="13" r="4"/><path d="M5 3L3 5"/></svg>
          <span>Screenshot</span>
        </button>
        <button data-action="gif" class="export-tile">
          <svg viewBox="0 0 24 24" width="20" height="20" fill="none" stroke="currentColor" stroke-width="1.5"><rect x="2" y="2" width="20" height="20" rx="2"/><text x="12" y="15" text-anchor="middle" font-size="8" fill="currentColor" stroke="none">GIF</text></svg>
          <span>GIF</span>
        </button>
        <button data-action="video" class="export-tile">
          <svg viewBox="0 0 24 24" width="20" height="20" fill="none" stroke="currentColor" stroke-width="1.5"><polygon points="23 7 16 12 23 17 23 7"/><rect x="1" y="5" width="15" height="14" rx="2"/></svg>
          <span>Video</span>
        </button>
        <button data-action="ndi" class="export-tile">
          <svg viewBox="0 0 24 24" width="20" height="20" fill="none" stroke="currentColor" stroke-width="1.5"><path d="M4 12h4l3-9 3 18 3-9h4"/></svg>
          <span>NDI</span>
        </button>
        <button data-action="copy" class="export-tile">
          <svg viewBox="0 0 24 24" width="20" height="20" fill="none" stroke="currentColor" stroke-width="1.5"><rect x="9" y="9" width="13" height="13" rx="2"/><path d="M5 15H4a2 2 0 01-2-2V4a2 2 0 012-2h9a2 2 0 012 2v1"/></svg>
          <span>Copy .fs</span>
        </button>
        <button data-action="download" class="export-tile">
          <svg viewBox="0 0 24 24" width="20" height="20" fill="none" stroke="currentColor" stroke-width="1.5"><path d="M21 15v4a2 2 0 01-2 2H5a2 2 0 01-2-2v-4"/><polyline points="7 10 12 15 17 10"/><line x1="12" y1="15" x2="12" y2="3"/></svg>
          <span>Download</span>
        </button>
      </div>
    </div>

    <!-- Layer Panel -->
    <div id="layer-panel">
      <!-- Voice Controls (top) -->
      <div class="layer-card" data-layer="voice">
        <div class="layer-header">
          <button id="canvas-mic-btn" class="layer-vis" title="Toggle voice input"><svg viewBox="0 0 24 24" width="14" height="14" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 1a3 3 0 00-3 3v8a3 3 0 006 0V4a3 3 0 00-3-3z"/><path d="M19 10v2a7 7 0 01-14 0v-2"/><line x1="12" y1="19" x2="12" y2="23"/><line x1="8" y1="23" x2="16" y2="23"/></svg></button>
          <span class="layer-name">Voice</span>
        </div>
        <div class="voice-transcript-bar">
          <input type="text" id="voice-transcript" readonly value="" placeholder="Start Talking.." spellcheck="false">
        </div>
        <div class="layer-controls">
          <div class="cam-toggle-row">
            <label>Mic</label>
            <button class="cam-switch" id="voice-mic-toggle" title="Toggle microphone on/off"></button>
          </div>
          <div class="layer-control-row">
            <label>Decay</label>
            <input type="range" id="voice-decay-slider" min="0.1" max="6.0" step="0.1" value="3.0" title="Fade time after 2s hold" style="flex:1">
            <span id="voice-decay-val" class="val" style="min-width:32px; text-align:right">3.0s</span>
          </div>
        </div>
      </div>

      <!-- Camera -->
      <div class="layer-card" data-layer="camera">
        <div class="layer-header">
          <button class="layer-vis" id="cam-vis-btn" title="Toggle camera">
            <svg viewBox="0 0 24 24" width="14" height="14" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M23 7l-7 5 7 5V7z"/><rect x="1" y="5" width="15" height="14" rx="2"/></svg>
          </button>
          <span class="layer-name">Camera</span>
        </div>
        <div class="layer-controls">
          <div class="cam-toggle-row">
            <label>Webcam</label>
            <button class="cam-switch" id="cam-webcam-btn" title="Toggle webcam"></button>
          </div>
          <div class="layer-control-row">
            <label>Opacity</label>
            <input type="range" class="layer-opacity" data-layer="media" min="0" max="1" step="0.01" value="1">
            <span class="val">1.00</span>
          </div>
          <div class="layer-control-row">
            <label>Blend</label>
            <select class="layer-blend" data-layer="media">
              <option value="normal">Normal</option>
              <option value="add">Add</option>
              <option value="multiply">Multiply</option>
              <option value="screen">Screen</option>
              <option value="overlay">Overlay</option>
            </select>
          </div>
        </div>
      </div>

      <!-- Body Tracking -->
      <div class="layer-card" data-layer="bodytracking">
        <div class="layer-header">
          <span class="layer-vis" style="cursor:default;opacity:0.6"><svg viewBox="0 0 24 24" width="14" height="14" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="4.5" r="2.5"/><path d="M12 7v5m0 0l-4 6m4-6l4 6"/><path d="M7 11h10"/></svg></span>
          <span class="layer-name">Body Tracking</span>
        </div>
        <div class="layer-controls">
          <div class="layer-control-row" id="bt-preset-row" style="display:none">
            <label>Preset</label>
            <select id="bt-preset-select" class="layer-shader-select" style="flex:1"></select>
          </div>
          <div class="cam-toggle-row">
            <label>MediaPipe</label>
            <button class="cam-switch" id="cam-mediapipe-btn" title="Toggle MediaPipe"></button>
          </div>
          <div class="layer-control-row mp-modes-row" id="mp-modes-row" style="display:none">
            <button class="mp-mode-btn active" data-mp-mode="hand" title="Hand tracking"><svg width="22" height="22" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5"><path d="M12 22c-1-2-4-4-4-8V7a1 1 0 0 1 2 0v5"/><path d="M10 12V5a1 1 0 0 1 2 0v7"/><path d="M14 12V6a1 1 0 0 1 2 0v6"/><path d="M18 14v-3a1 1 0 0 0-2 0v3"/><path d="M18 14c0 4-2 6-4 8"/><path d="M8 14V7"/></svg><span>Hand</span></button>
            <button class="mp-mode-btn" data-mp-mode="face" title="Face mesh"><svg width="22" height="22" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5"><ellipse cx="12" cy="13" rx="7" ry="8.5"/><circle cx="9.5" cy="11" r="0.8" fill="currentColor"/><circle cx="14.5" cy="11" r="0.8" fill="currentColor"/><path d="M10 15.5q2 1.5 4 0"/></svg><span>Face</span></button>
            <button class="mp-mode-btn" data-mp-mode="pose" title="Pose detection"><svg width="22" height="22" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5"><circle cx="12" cy="4.5" r="2"/><path d="M12 7v5m0 0l-4 6m4-6l4 6"/><path d="M7 11h10"/></svg><span>Pose</span></button>
            <button class="mp-mode-btn" data-mp-mode="segment" title="Segmentation mask"><svg width="22" height="22" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-dasharray="2 1.5"><circle cx="12" cy="5" r="2.5"/><path d="M12 8c-3 0-5 2-5 4v2c0 1 0 3 1 5h8c1-2 1-4 1-5v-2c0-2-2-4-5-4z"/></svg><span>Seg</span></button>
          </div>
          <div class="cam-toggle-row" id="gesture-toggle-row" style="display:none">
            <label>Body Tracking</label>
            <button class="cam-switch" id="gesture-ctrl-btn" title="Map body tracking to shader parameters"></button>
          </div>
          <div class="cam-toggle-row" id="hand-as-mouse-row" style="display:none">
            <label>Hand as Mouse</label>
            <button class="cam-switch" id="hand-as-mouse-btn" title="Use hand position as mouse input"></button>
          </div>
          <div class="layer-control-row" id="bt-texture-scale-row" style="display:none">
            <label>Scale</label>
            <input type="range" id="bt-texture-scale" min="0.5" max="3.0" step="0.01" value="1.0">
            <span class="val" id="bt-texture-scale-val">1.00</span>
          </div>
          <!-- Skeleton Overlay toggle -->
          <div class="cam-toggle-row" id="bt-overlay-row" style="display:none">
            <label>Skeleton Overlay</label>
            <button class="cam-switch" id="bt-overlay-btn" title="Show skeleton overlay on canvas"></button>
          </div>
          <!-- Live Signals (collapsible) -->
          <div id="bt-signals-section" style="display:none">
            <div class="bt-section-header" id="bt-signals-header">
              <span class="bt-chevron">&#x25B6;</span> Live Signals
            </div>
            <div class="bt-section-body" id="bt-signals-body"></div>
          </div>
          <!-- Live Links (collapsible) -->
          <div id="bt-links-section" style="display:none">
            <div class="bt-section-header" id="bt-links-header">
              <span class="bt-chevron">&#x25B6;</span> Live Links <span class="bt-link-count" id="bt-link-count" style="display:none">0</span>
            </div>
            <div class="bt-section-body" id="bt-links-body">
              <div id="bt-links-list"></div>
              <div class="bt-actions">
                <button class="bt-action-btn" id="bt-add-link-btn">+ Link</button>
                <button class="bt-action-btn" id="bt-map-btn">Map</button>
              </div>
            </div>
          </div>
          <!-- Recording -->
          <div id="bt-recording-section" style="display:none">
            <div class="bt-section-header" id="bt-recording-header">
              <span class="bt-chevron">&#x25B6;</span> Recording
            </div>
            <div class="bt-section-body" id="bt-recording-body">
              <div class="bt-rec-row">
                <button class="bt-rec-btn" id="bt-rec-btn" title="Record">&#x23FA;</button>
                <button class="bt-rec-btn" id="bt-play-btn" title="Play" disabled>&#x25B6;</button>
                <button class="bt-rec-btn" id="bt-json-btn" title="Export JSON" disabled>{ }</button>
                <span class="bt-rec-timer" id="bt-rec-timer">0:00</span>
              </div>
            </div>
          </div>
        </div>
      </div>

      <!-- Overlay Layer -->
      <div class="layer-card" data-layer="overlay">
        <div class="layer-header">
          <button class="layer-vis" data-layer="overlay" title="Toggle visibility">&#x1F441;</button>
          <span class="layer-name">Overlay</span>
        </div>
        <div class="layer-controls">
          <div class="layer-control-row">
            <button class="overlay-upload-btn" id="overlay-upload-btn" title="Upload image or GIF" style="width:100%">+ Add Image</button>
          </div>
          <div class="layer-control-row">
            <label>X</label>
            <input type="range" id="overlay-tx" min="-1" max="1" step="0.01" value="0">
            <span class="val" id="overlay-tx-val">0.00</span>
          </div>
          <div class="layer-control-row">
            <label>Y</label>
            <input type="range" id="overlay-ty" min="-1" max="1" step="0.01" value="0">
            <span class="val" id="overlay-ty-val">0.00</span>
          </div>
          <div class="layer-control-row">
            <label>Scale</label>
            <input type="range" id="overlay-scale" min="0.1" max="5" step="0.01" value="0.3">
            <span class="val" id="overlay-scale-val">0.30</span>
          </div>
          <div class="layer-control-row">
            <label>Rotate</label>
            <input type="range" id="overlay-rotate" min="-180" max="180" step="1" value="0">
            <span class="val" id="overlay-rotate-val">0&#176;</span>
          </div>
          <div class="layer-control-row">
            <label>Opacity</label>
            <input type="range" class="layer-opacity" data-layer="overlay" min="0" max="1" step="0.01" value="1">
            <span class="val">1.00</span>
          </div>
          <div class="layer-control-row">
            <label>Blend</label>
            <select class="layer-blend" data-layer="overlay">
              <option value="normal">Normal</option>
              <option value="add">Add</option>
              <option value="multiply">Multiply</option>
              <option value="screen">Screen</option>
              <option value="overlay">Overlay</option>
            </select>
          </div>
        </div>
      </div>

      <!-- Text Layer -->
      <div class="layer-card" data-layer="text">
        <div class="layer-header">
          <button class="layer-vis" data-layer="text" title="Toggle visibility">&#x1F441;</button>
          <span class="layer-name">Text</span>
        </div>
        <div class="layer-preset-row">
          <label>Preset</label>
          <select class="layer-shader-select" data-layer="text"></select>
        </div>
        <div class="text-msg-bar">
          <input type="text" id="text-msg-input" maxlength="24" value="ETHEREA" spellcheck="false" placeholder="TYPE HERE">
        </div>
        <div class="layer-controls">
          <div class="layer-control-row">
            <label>Opacity</label>
            <input type="range" class="layer-opacity" data-layer="text" min="0" max="1" step="0.01" value="1">
            <span class="val">1.00</span>
          </div>
          <div class="layer-control-row">
            <label>Blend</label>
            <select class="layer-blend" data-layer="text">
              <option value="normal">Normal</option>
              <option value="add">Add</option>
              <option value="multiply">Multiply</option>
              <option value="screen">Screen</option>
              <option value="overlay">Overlay</option>
            </select>
          </div>
        </div>
        <div class="layer-params" data-layer="text"></div>
      </div>

      <!-- Scene Layer (middle) -->
      <div class="layer-card" data-layer="scene">
        <div class="layer-header">
          <button class="layer-vis" data-layer="scene" title="Toggle visibility">&#x1F441;</button>
          <span class="layer-name">Shape</span>
        </div>
        <div class="layer-preset-row">
          <label>Preset</label>
          <select class="layer-shader-select" data-layer="scene"></select>
        </div>
        <div class="layer-controls">
          <div class="layer-control-row">
            <label>Opacity</label>
            <input type="range" class="layer-opacity" data-layer="scene" min="0" max="1" step="0.01" value="1">
            <span class="val">1.00</span>
          </div>
          <div class="layer-control-row">
            <label>Blend</label>
            <select class="layer-blend" data-layer="scene">
              <option value="normal">Normal</option>
              <option value="add">Add</option>
              <option value="multiply">Multiply</option>
              <option value="screen">Screen</option>
              <option value="overlay">Overlay</option>
            </select>
          </div>
          <div class="layer-control-row">
            <label>Flip</label>
            <button class="flip-toggle scene-flip-h" data-layer="scene" title="Flip Horizontal">H</button>
            <button class="flip-toggle scene-flip-v active" data-layer="scene" title="Flip Vertical">V</button>
          </div>
          <div class="layer-control-row">
            <button id="scene-model-btn" title="Import 3D model (.glb, .gltf, .stl, .fbx, .obj)">+ Add 3D Model</button>
          </div>
        </div>
        <div class="layer-params" data-layer="scene"></div>
      </div>

      <!-- Shader Layer (bottom = backmost) -->
      <div class="layer-card focused" data-layer="shader">
        <div class="layer-header">
          <button class="layer-vis" data-layer="shader" title="Toggle visibility">&#x1F441;</button>
          <span class="layer-name">Shader</span>
        </div>
        <div class="layer-preset-row">
          <label>Preset</label>
          <select class="layer-shader-select" data-layer="shader"></select>
        </div>
        <div class="layer-controls">
          <div class="layer-control-row">
            <label>Opacity</label>
            <input type="range" class="layer-opacity" data-layer="shader" min="0" max="1" step="0.01" value="1">
            <span class="val">1.00</span>
          </div>
          <div class="layer-control-row">
            <label>Blend</label>
            <select class="layer-blend" data-layer="shader">
              <option value="normal">Normal</option>
              <option value="add">Add</option>
              <option value="multiply">Multiply</option>
              <option value="screen">Screen</option>
              <option value="overlay">Overlay</option>
            </select>
          </div>
          <div class="layer-control-row">
            <label>Background</label>
            <input type="color" id="shader-bg-color" value="#000000" style="width:28px;height:20px;padding:0;border:1px solid var(--border);border-radius:3px;background:none;cursor:pointer;">
          </div>
          <div class="cam-toggle-row">
            <label>Transparent BG</label>
            <button class="cam-switch" id="shader-transparent-bg-btn" title="Convert luminance to alpha for compositing"></button>
          </div>
        </div>
        <div class="layer-params" data-layer="shader"></div>
      </div>
    </div>

    <!-- Inputs Section -->
    <div id="inputs-section">
      <div class="section-header"><span class="section-chevron">&#x25BC;</span> Inputs</div>
      <div class="section-body">
      <div class="import-grid">
        <button class="import-tile" id="tile-image" title="Import image">
          <svg viewBox="0 0 24 24" width="18" height="18" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="3" width="18" height="18" rx="2"/><circle cx="8.5" cy="8.5" r="1.5"/><path d="M21 15l-5-5L5 21"/></svg>
          <span>Image</span>
        </button>
        <button class="import-tile" id="tile-video" title="Import video">
          <svg viewBox="0 0 24 24" width="18" height="18" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><polygon points="5,3 19,12 5,21"/></svg>
          <span>Video</span>
        </button>
        <button class="import-tile" id="tile-model" title="Import 3D model">
          <svg viewBox="0 0 24 24" width="18" height="18" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><path d="M12 2L2 7l10 5 10-5-10-5z"/><path d="M2 17l10 5 10-5"/><path d="M2 12l10 5 10-5"/></svg>
          <span>3D Model</span>
        </button>
        <button class="import-tile" id="tile-sound" title="Import audio">
          <svg viewBox="0 0 24 24" width="18" height="18" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><polygon points="11,5 6,9 2,9 2,15 6,15 11,19"/><path d="M19.07 4.93a10 10 0 010 14.14"/><path d="M15.54 8.46a5 5 0 010 7.07"/></svg>
          <span>Sound</span>
        </button>
        <button class="import-tile" id="tile-webcam" title="Webcam input">
          <svg viewBox="0 0 24 24" width="18" height="18" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><path d="M23 7l-7 5 7 5V7z"/><rect x="1" y="5" width="15" height="14" rx="2"/></svg>
          <span>Webcam</span>
        </button>
        <button class="import-tile" id="tile-mediapipe" title="MediaPipe ML inputs">
          <svg viewBox="0 0 24 24" width="18" height="18" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="5" r="3"/><path d="M12 8v4"/><circle cx="6" cy="16" r="2"/><circle cx="18" cy="16" r="2"/><path d="M12 12l-6 4M12 12l6 4"/><circle cx="12" cy="20" r="2"/><path d="M12 14v6"/></svg>
          <span>MediaPipe</span>
        </button>
        <button class="import-tile" id="tile-ndi" title="NDI input">
          <svg viewBox="0 0 24 24" width="18" height="18" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="3"/><path d="M12 1v4"/><path d="M12 19v4"/><path d="M1 12h4"/><path d="M19 12h4"/><path d="M4.22 4.22l2.83 2.83"/><path d="M16.95 16.95l2.83 2.83"/><path d="M4.22 19.78l2.83-2.83"/><path d="M16.95 7.05l2.83-2.83"/></svg>
          <span>NDI</span>
        </button>
      </div>
      <div class="media-list" id="media-list"></div>
      </div><!-- /section-body -->
    </div>
    </div><!-- /sidebar-scroll -->
  </div>

  <!-- Shader Browser Overlay -->
  <div id="shader-browser-backdrop"></div>
  <div id="shader-browser">
    <div class="browser-header">
      <input class="browser-search" type="text" placeholder="Search shaders...">
      <button class="browser-close">&#x2715;</button>
    </div>
    <div class="browser-body"></div>
  </div>

  <!-- MOBILE DRAG HANDLE -->
  <div id="mobile-drag-handle"><span class="drag-pill"></span></div>

  <!-- MAIN -->
  <div id="main">
    <div id="preview">
      <div id="canvas-logo">
        <img src="logo.png" alt="ShaderClaw" width="28" height="28" loading="lazy" decoding="async">
        <span>SHADER<em>CLAW</em></span>
      </div>
      <canvas id="gl-canvas"></canvas>
      <canvas id="three-canvas"></canvas>
      <canvas id="overlay-gizmo"></canvas>
      <div class="canvas-controls">
        <div class="ndi-indicator" id="ndi-indicator"><span class="ndi-dot"></span><span class="ndi-label">NDI</span></div>
        <button class="canvas-btn" id="play-btn" title="Play/Pause">&#9654;</button>
        <button class="canvas-btn" id="fs-btn" title="Fullscreen">&#x26F6;</button>
      </div>
      <div id="error-bar"></div>
      <div id="debug-overlay" style="display:none;position:absolute;top:50px;left:12px;z-index:999;color:#999;font:11px monospace;background:rgba(0,0,0,0.7);padding:8px;border-radius:4px;pointer-events:none;white-space:pre;max-width:60%;overflow:hidden"></div>
      <input type="file" id="image-file-input" accept="image/jpeg,image/png,image/gif,image/webp" multiple style="display:none">
      <input type="file" id="video-file-input" accept="video/mp4,video/webm" multiple style="display:none">
      <input type="file" id="model-file-input" accept=".glb,.gltf,.stl,.fbx,.obj" multiple style="display:none">
      <input type="file" id="sound-file-input" accept="audio/mpeg,audio/wav,audio/ogg,.mp3,.wav,.ogg" multiple style="display:none">
      <input type="file" id="vector-file-input" accept=".svg,image/svg+xml" style="display:none">
      <input type="file" id="bg-image-input" accept="image/*" style="display:none">
      <input type="file" id="bg-video-input" accept="video/*" style="display:none">

      <!-- NDI Source Picker -->
      <div id="ndi-source-picker">
        <div class="picker-box">
          <div class="picker-header">
            <span class="title">NDI Sources</span>
            <button class="picker-close" id="ndi-picker-close">&times;</button>
          </div>
          <div class="picker-body" id="ndi-picker-body"></div>
          <button class="ndi-refresh-btn" id="ndi-refresh-btn">Refresh Sources</button>
        </div>
      </div>
    </div>

    <div id="editor-area">
      <div id="editor-toolbar">
        <button id="compile-btn">Compile</button>
        <label id="auto-compile-label"><input type="checkbox" id="auto-compile" checked> Auto</label>
        <div class="spacer"></div>
        <button id="new-btn">New</button>
        <button id="download-btn">Save .fs</button>
      </div>
      <div id="editor-wrap"><textarea id="code"></textarea></div>
    </div>
  </div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/codemirror.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/mode/clike/clike.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/addon/edit/matchbrackets.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/addon/edit/closebrackets.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="js/gesture.js"></script>
<!-- Defer non-critical loaders: loaded after page init -->
<script>
// Lazy-load 3D model loaders + MediaPipe after first paint
window._deferredLoaders = false;
function loadDeferredScripts() {
  if (window._deferredLoaders) return Promise.resolve();
  window._deferredLoaders = true;
  const urls = [
    'https://cdn.jsdelivr.net/npm/fflate@0.6.10/umd/index.min.js',
    'https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js',
    'https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/STLLoader.js',
    'https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/OBJLoader.js',
    'https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/FBXLoader.js',
    'https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/FontLoader.js',
    'https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/geometries/TextGeometry.js',
  ];
  return new Promise(resolve => {
    let loaded = 0;
    function next() {
      if (loaded >= urls.length) {
        // Shim fflate for FBXLoader
        if (window.fflate && typeof THREE !== 'undefined') THREE.fflate = window.fflate;
        resolve();
        return;
      }
      const s = document.createElement('script');
      s.src = urls[loaded];
      s.onload = s.onerror = () => { loaded++; next(); };
      document.head.appendChild(s);
    }
    next();
  });
}
// Load MediaPipe lazily (only when user enables it)
function loadMediaPipeVision() {
  if (window.MediaPipeVision) return Promise.resolve();
  return import('https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.32/vision_bundle.mjs').then(m => {
    window.MediaPipeVision = { FilesetResolver: m.FilesetResolver, HandLandmarker: m.HandLandmarker, FaceLandmarker: m.FaceLandmarker, PoseLandmarker: m.PoseLandmarker, ImageSegmenter: m.ImageSegmenter };
  });
}
</script>
<script>
// ============================================================
// ShaderClaw — ISF Shader Builder
// ============================================================

const DEFAULT_SHADER = `/*{
  "DESCRIPTION": "Particle network — drifting points connected by proximity lines",
  "CATEGORIES": ["Generator"],
  "INPUTS": [
    { "NAME": "particleCount", "TYPE": "float", "DEFAULT": 40.0, "MIN": 10.0, "MAX": 80.0 },
    { "NAME": "speed", "TYPE": "float", "DEFAULT": 0.4, "MIN": 0.0, "MAX": 2.0 },
    { "NAME": "connectDist", "TYPE": "float", "DEFAULT": 0.25, "MIN": 0.05, "MAX": 0.5 },
    { "NAME": "lineWidth", "TYPE": "float", "DEFAULT": 1.0, "MIN": 0.3, "MAX": 3.0 },
    { "NAME": "dotSize", "TYPE": "float", "DEFAULT": 3.0, "MIN": 1.0, "MAX": 8.0 },
    { "NAME": "color1", "TYPE": "color", "DEFAULT": [1.0, 1.0, 1.0, 1.0] },
    { "NAME": "bgColor", "TYPE": "color", "DEFAULT": [0.02, 0.02, 0.05, 1.0] }
  ]
}*/

// Stable hash for particle seeding
vec2 particleHash(float id) {
    return vec2(
        fract(sin(id * 127.1 + 311.7) * 43758.5453),
        fract(sin(id * 269.5 + 183.3) * 28001.8384)
    );
}

// Particle position: drifts with unique velocity, wraps around [0,1]
vec2 particlePos(float id, float t) {
    vec2 seed = particleHash(id);
    vec2 vel = (particleHash(id + 100.0) - 0.5) * 0.5;
    return fract(seed + vel * t);
}

// Distance from point p to line segment a-b
float segDist(vec2 p, vec2 a, vec2 b) {
    vec2 ab = b - a;
    float len2 = dot(ab, ab);
    if (len2 < 0.000001) return length(p - a);
    float t = clamp(dot(p - a, ab) / len2, 0.0, 1.0);
    vec2 proj = a + ab * t;
    return length(p - proj);
}

void main() {
    vec2 uv = gl_FragCoord.xy / RENDERSIZE.xy;
    float aspect = RENDERSIZE.x / RENDERSIZE.y;
    vec2 p = vec2(uv.x * aspect, uv.y);
    float t = TIME * speed;
    float px = 1.0 / RENDERSIZE.y; // pixel size in UV space

    int N = int(particleCount);
    vec3 col = bgColor.rgb;

    // Precompute particle positions (store aspect-corrected)
    // GLSL ES 1.0 doesn't support variable arrays, so we compute on the fly

    // Draw connection lines (additive)
    float lineAccum = 0.0;
    for (int i = 0; i < 80; i++) {
        if (i >= N) break;
        vec2 pi = particlePos(float(i), t);
        pi.x *= aspect;

        for (int j = 0; j < 80; j++) {
            if (j >= N || j <= i) break;
            vec2 pj = particlePos(float(j), t);
            pj.x *= aspect;

            float d = length(pi - pj);
            if (d > connectDist) continue;

            // Quick AABB cull: skip if pixel is far from the segment
            vec2 mn = min(pi, pj) - vec2(connectDist * 0.1);
            vec2 mx = max(pi, pj) + vec2(connectDist * 0.1);
            if (p.x < mn.x || p.x > mx.x || p.y < mn.y || p.y > mx.y) continue;

            float sd = segDist(p, pi, pj);
            float lw = lineWidth * px;
            float alpha = (1.0 - d / connectDist);
            alpha *= smoothstep(lw, lw * 0.3, sd);
            lineAccum += alpha * 0.5;
        }
    }
    col += color1.rgb * min(lineAccum, 1.0);

    // Draw particles (additive glow)
    float dotAccum = 0.0;
    for (int i = 0; i < 80; i++) {
        if (i >= N) break;
        vec2 pi = particlePos(float(i), t);
        pi.x *= aspect;

        float d = length(p - pi);
        float r = dotSize * px;
        dotAccum += smoothstep(r, r * 0.15, d);
    }
    col += color1.rgb * min(dotAccum, 1.5);

    gl_FragColor = vec4(col, 1.0);
}`;

// ============================================================
// ISF Parser
// ============================================================

function parseISF(source) {
  const match = source.match(/\/\*\s*(\{[\s\S]*?\})\s*\*\//);
  if (!match) return { meta: null, glsl: source.trim(), inputs: [] };
  try {
    const meta = JSON.parse(match[1]);
    const glsl = source.slice(source.indexOf(match[0]) + match[0].length).trim();
    return { meta, glsl, inputs: meta.INPUTS || [] };
  } catch (e) {
    return { meta: null, glsl: source.trim(), inputs: [] };
  }
}

function isfInputToUniform(input) {
  const t = input.TYPE;
  if (t === 'float') return `uniform float ${input.NAME};`;
  if (t === 'color') return `uniform vec4 ${input.NAME};`;
  if (t === 'bool') return `uniform bool ${input.NAME};`;
  if (t === 'point2D') return `uniform vec2 ${input.NAME};`;
  if (t === 'image') return `uniform sampler2D ${input.NAME};`;
  if (t === 'long') return `uniform float ${input.NAME};`;
  if (t === 'text') {
    const maxLen = input.MAX_LENGTH || 12;
    const lines = [];
    for (let i = 0; i < maxLen; i++) lines.push(`uniform float ${input.NAME}_${i};`);
    lines.push(`uniform float ${input.NAME}_len;`);
    return lines.join('\n');
  }
  return `// unknown type: ${t} ${input.NAME}`;
}

function buildFragmentShader(source) {
  const parsed = parseISF(source);
  const uniformLines = (parsed.inputs || []).map(isfInputToUniform);

  const headerParts = [
    'precision highp float;',
    'uniform float TIME;',
    'uniform vec2 RENDERSIZE;',
    'uniform int PASSINDEX;',
    'uniform int FRAMEINDEX;',
    'varying vec2 isf_FragNormCoord;',
    '#define IMG_NORM_PIXEL(img, coord) texture2D(img, coord)',
    '#define IMG_PIXEL(img, coord) texture2D(img, coord / RENDERSIZE)',
    '#define IMG_THIS_PIXEL(img) texture2D(img, isf_FragNormCoord)',
    '#define IMG_THIS_NORM_PIXEL(img) texture2D(img, isf_FragNormCoord)',
    // Mouse uniforms
    'uniform vec2 mousePos;',
    'uniform vec2 mouseDelta;',
    // Audio-reactive uniforms (always declared, zero when no audio)
    'uniform sampler2D audioFFT;',
    'uniform float audioLevel;',
    'uniform float audioBass;',
    'uniform float audioMid;',
    'uniform float audioHigh;',
    // Variable font texture (for Text shader effect 20)
    'uniform sampler2D varFontTex;',
    // Font atlas texture (for bitmap effects 0-19 with web fonts)
    'uniform sampler2D fontAtlasTex;',
    'uniform float useFontAtlas;',
    // Voice decay glitch (0 = none, 1 = full glitch)
    'uniform float _voiceGlitch;',
    // MediaPipe uniforms
    'uniform sampler2D mpHandLandmarks;',
    'uniform sampler2D mpFaceLandmarks;',
    'uniform sampler2D mpPoseLandmarks;',
    'uniform sampler2D mpSegMask;',
    'uniform float mpHandCount;',
    'uniform vec3 mpHandPos;',
    // Layer compositing
    'uniform float _transparentBg;',
    ...uniformLines,
    ''
  ];

  // Inject TARGET sampler declarations from PASSES metadata
  if (parsed.meta && Array.isArray(parsed.meta.PASSES)) {
    for (const pass of parsed.meta.PASSES) {
      if (pass.TARGET) {
        headerParts.push(`uniform sampler2D ${pass.TARGET};`);
      }
    }
    headerParts.push('');
  }

  const header = headerParts.join('\n');

  const cleaned = parsed.glsl.replace(/#version\s+\d+.*/g, '');

  // Wrap shader main() to inject transparent background support for layer compositing
  // Skip wrapper if the shader already declares a 'transparentBg' input (it handles alpha itself)
  const shaderHandlesTransparency = (parsed.inputs || []).some(inp => inp.NAME === 'transparentBg');
  let body = header + cleaned;
  const mainRe = /void\s+main\s*\(\s*\)/;
  if (mainRe.test(body) && !shaderHandlesTransparency) {
    body = body.replace(mainRe, 'void _shaderMain()');
    body += `
void main() {
    _shaderMain();
    if (_transparentBg > 0.5) {
        float _lum = dot(gl_FragColor.rgb, vec3(0.299, 0.587, 0.114));
        gl_FragColor.a = smoothstep(0.02, 0.15, _lum);
    }
}
`;
  }

  return { frag: body, parsed, headerLineCount: headerParts.length };
}

const VERT_SHADER = `
attribute vec2 position;
varying vec2 isf_FragNormCoord;
void main() {
    isf_FragNormCoord = position * 0.5 + 0.5;
    gl_Position = vec4(position, 0.0, 1.0);
}`;

// ============================================================
// Media Inputs Store
// ============================================================

const mediaInputs = [];
let mediaIdCounter = 0;

// Global mask state (persists across shader switches)
let _maskMediaId = null;
let _maskMode = 0; // 0=off, 1=multiply, 2=invert

// Audio-reactive system
let audioCtx = null;
let audioAnalyser = null;
let audioDataArray = null;
let audioFFTGLTexture = null;
let audioFFTThreeTexture = null;
let audioLevel = 0, audioBass = 0, audioMid = 0, audioHigh = 0;
let activeAudioEntry = null;

// Variable font texture system (for Text shader "Variable Font" effect)
let _vfCanvas = null;
let _vfCtx = null;
let _vfGLTexture = null;
let _vfLastMsg = '';
let _vfWeight = 400;
const _fontFamilies = [
  '"Inter", "Segoe UI Variable", "SF Pro", sans-serif',
  '"Times New Roman", "Times", Georgia, serif',
  '"Libre Caslon Text", "Palatino Linotype", "Book Antiqua", serif',
  '"Outfit", "Inter", "Segoe UI Variable", sans-serif',
];

function _getFontStack(inputValues) {
  const idx = Math.round(inputValues['fontFamily'] || 0);
  return _fontFamilies[idx] || _fontFamilies[0];
}

// Invalidate font texture cache when Google Fonts finish loading
if (typeof document !== 'undefined' && document.fonts) {
  document.fonts.ready.then(() => { _vfLastMsg = ''; _fontAtlasLastKey = ''; });
}

function updateVarFontTexture(gl, inputValues) {
  // Build msg from character uniforms
  const maxLen = 24;
  let msg = '';
  const msgLen = inputValues['msg_len'];
  const len = (msgLen != null && msgLen > 0) ? Math.min(msgLen, maxLen) : 0;
  for (let i = 0; i < len; i++) {
    const code = inputValues['msg_' + i];
    if (code == null || code === 26) msg += ' ';
    else if (code >= 0 && code <= 25) msg += String.fromCharCode(65 + code);
    else msg += ' ';
  }
  msg = msg.trim() || 'ETHEREA';

  // Sync weight from ISF param if available
  const iw = inputValues['fontWeight'];
  if (iw != null) _vfWeight = Math.max(100, Math.min(900, iw));

  // Only re-render canvas if text, weight, or font changed
  const fontStack = _getFontStack(inputValues);
  const key = msg + '|' + _vfWeight + '|' + fontStack;
  if (key === _vfLastMsg && _vfGLTexture) return;
  _vfLastMsg = key;

  if (!_vfCanvas) {
    _vfCanvas = document.createElement('canvas');
    _vfCanvas.width = 2048;
    _vfCanvas.height = 512;
    _vfCtx = _vfCanvas.getContext('2d');
  }

  const c = _vfCanvas;
  const ctx = _vfCtx;
  ctx.clearRect(0, 0, c.width, c.height);
  ctx.save();
  // Flip vertically for GL coord system
  ctx.translate(0, c.height);
  ctx.scale(1, -1);
  const w = Math.round(_vfWeight);
  ctx.font = w + ' ' + Math.round(c.height * 0.35) + 'px ' + fontStack;
  ctx.fillStyle = '#ffffff';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText(msg, c.width / 2, c.height / 2);
  ctx.restore();

  if (!_vfGLTexture) {
    _vfGLTexture = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, _vfGLTexture);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
  } else {
    gl.bindTexture(gl.TEXTURE_2D, _vfGLTexture);
  }
  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, c);
}

// Breathing texture: per-character variable font weight wave (effect 22)
// Renders each character at a staggered weight based on time, creating a
// "breathing" wave across the text (inspired by Splitting.js + variable fonts)
let _breatheStartTime = performance.now();

function updateBreathingTexture(gl, inputValues) {
  const maxLen = 24;
  let msg = '';
  const msgLen = inputValues['msg_len'];
  const len = (msgLen != null && msgLen > 0) ? Math.min(msgLen, maxLen) : 0;
  for (let i = 0; i < len; i++) {
    const code = inputValues['msg_' + i];
    if (code == null || code === 26) msg += ' ';
    else if (code >= 0 && code <= 25) msg += String.fromCharCode(65 + code);
    else msg += ' ';
  }
  msg = msg.trim() || 'ETHEREA';

  const fontStack = _getFontStack(inputValues);
  const spd = inputValues['speed'] != null ? inputValues['speed'] : 0.5;
  const intens = inputValues['intensity'] != null ? inputValues['intensity'] : 0.5;
  const elapsed = (performance.now() - _breatheStartTime) / 1000;

  // Weight range driven by intensity: center ± spread
  const baseWeight = inputValues['fontWeight'] != null ? inputValues['fontWeight'] : 400;
  const spread = intens * 400; // 0..400 range from center
  const minW = Math.max(100, baseWeight - spread);
  const maxW = Math.min(900, baseWeight + spread);

  // Stagger delay per char driven by density
  const dens = inputValues['density'] != null ? inputValues['density'] : 0.5;
  const charDelay = 0.15 + (1.0 - dens) * 0.85; // 0.15s (tight wave) to 1.0s (wide wave)

  if (!_vfCanvas) {
    _vfCanvas = document.createElement('canvas');
    _vfCanvas.width = 2048;
    _vfCanvas.height = 512;
    _vfCtx = _vfCanvas.getContext('2d');
  }

  const c = _vfCanvas;
  const ctx = _vfCtx;
  ctx.clearRect(0, 0, c.width, c.height);
  ctx.save();
  ctx.translate(0, c.height);
  ctx.scale(1, -1);

  const fontSize = Math.round(c.height * 0.35);
  ctx.fillStyle = '#ffffff';
  ctx.textAlign = 'left';
  ctx.textBaseline = 'middle';

  // Measure total width at mid-weight to center the text
  const midWeight = Math.round((minW + maxW) / 2);
  ctx.font = midWeight + ' ' + fontSize + 'px ' + fontStack;
  const totalWidth = ctx.measureText(msg).width;
  let x = (c.width - totalWidth) / 2;

  // Draw each character with its own staggered weight
  for (let i = 0; i < msg.length; i++) {
    const phase = elapsed * spd * Math.PI * 2 - i * charDelay;
    const t = (Math.sin(phase) + 1) / 2; // 0..1
    const w = Math.round(minW + t * (maxW - minW));

    ctx.font = w + ' ' + fontSize + 'px ' + fontStack;
    ctx.fillText(msg[i], x, c.height / 2);
    x += ctx.measureText(msg[i]).width;
  }

  ctx.restore();

  if (!_vfGLTexture) {
    _vfGLTexture = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, _vfGLTexture);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
  } else {
    gl.bindTexture(gl.TEXTURE_2D, _vfGLTexture);
  }
  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, c);
  // Invalidate varfont cache so switching back to effect 20 re-renders
  _vfLastMsg = '';
}

// Font atlas for bitmap effects (0-19) using web fonts
let _fontAtlasCanvas = null;
let _fontAtlasCtx = null;
let _fontAtlasGLTexture = null;
let _fontAtlasLastKey = '';

function updateFontAtlas(gl, inputValues) {
  const fontFamilyIdx = Math.round(inputValues['fontFamily'] || 0);
  // Always generate atlas (even for fontFamily=0) to avoid 26-branch charData() in shader
  const fontStack = _fontFamilies[fontFamilyIdx] || _fontFamilies[0];
  const weight = Math.round(inputValues['fontWeight'] || 400);
  const key = fontStack + '|' + weight + '|192';
  if (key === _fontAtlasLastKey && _fontAtlasGLTexture) return;
  _fontAtlasLastKey = key;

  const cellW = 192, cellH = 180;
  const totalW = 27 * cellW;

  if (!_fontAtlasCanvas || _fontAtlasCanvas.width !== totalW) {
    _fontAtlasCanvas = document.createElement('canvas');
    _fontAtlasCanvas.width = totalW;
    _fontAtlasCanvas.height = cellH;
    _fontAtlasCtx = _fontAtlasCanvas.getContext('2d');
  }

  const c = _fontAtlasCanvas;
  const ctx = _fontAtlasCtx;
  ctx.clearRect(0, 0, c.width, c.height);
  ctx.save();
  // Flip vertically for GL coord system
  ctx.translate(0, c.height);
  ctx.scale(1, -1);

  const fontSize = Math.round(cellH * 0.85);
  ctx.font = weight + ' ' + fontSize + 'px ' + fontStack;
  ctx.fillStyle = '#ffffff';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';

  for (let i = 0; i < 26; i++) {
    ctx.fillText(String.fromCharCode(65 + i), (i + 0.5) * cellW, cellH / 2);
  }
  // Index 26 = space (leave blank)

  ctx.restore();

  if (!_fontAtlasGLTexture) {
    _fontAtlasGLTexture = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, _fontAtlasGLTexture);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
  } else {
    gl.bindTexture(gl.TEXTURE_2D, _fontAtlasGLTexture);
  }
  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, c);
}

// Audio-reactive per-frame update (global scope — called from Renderer.render)
function updateAudioUniforms(gl) {
  if (!audioAnalyser || !activeAudioEntry) {
    audioLevel = audioBass = audioMid = audioHigh = 0;
    return;
  }
  audioAnalyser.getByteFrequencyData(audioDataArray);
  const len = audioDataArray.length; // 128 bins

  // Compute RMS level
  let sum = 0;
  for (let i = 0; i < len; i++) sum += audioDataArray[i] * audioDataArray[i];
  audioLevel = Math.sqrt(sum / len) / 255.0;

  // Bass (bins 0-15), Mid (16-80), High (81-127)
  let bassSum = 0, midSum = 0, highSum = 0;
  for (let i = 0; i < 16; i++) bassSum += audioDataArray[i];
  for (let i = 16; i < 81; i++) midSum += audioDataArray[i];
  for (let i = 81; i < len; i++) highSum += audioDataArray[i];
  audioBass = bassSum / (16 * 255);
  audioMid = midSum / (65 * 255);
  audioHigh = highSum / (47 * 255);

  // Upload FFT data to GL texture (256x1 LUMINANCE)
  if (!audioFFTGLTexture) {
    audioFFTGLTexture = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, audioFFTGLTexture);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
  }
  gl.bindTexture(gl.TEXTURE_2D, audioFFTGLTexture);
  gl.texImage2D(gl.TEXTURE_2D, 0, gl.LUMINANCE, len, 1, 0, gl.LUMINANCE, gl.UNSIGNED_BYTE, audioDataArray);

  // Update THREE DataTexture
  if (!audioFFTThreeTexture) {
    audioFFTThreeTexture = new THREE.DataTexture(audioDataArray, len, 1, THREE.LuminanceFormat);
    audioFFTThreeTexture.needsUpdate = true;
  } else {
    audioFFTThreeTexture.needsUpdate = true;
  }

  // Update audio level bar in media list
  if (activeAudioEntry) {
    const bar = document.querySelector('.audio-bar-fill[data-audio-id="' + activeAudioEntry.id + '"]');
    if (bar) bar.style.width = (audioLevel * 100) + '%';
  }
}

function detectMediaType(file) {
  const ext = file.name.split('.').pop().toLowerCase();
  if (['glb', 'gltf', 'stl', 'fbx', 'obj'].includes(ext)) return 'model';
  if (['mp3', 'wav', 'ogg'].includes(ext)) return 'audio';
  if (ext === 'svg') return 'svg';
  if (file.type.startsWith('video/')) return 'video';
  return 'image';
}

function mediaTypeIcon(type, name) {
  if (type === 'video' && name === 'Webcam') return '\u{1F4F9}';
  if (type === 'video') return '\u{1F3AC}';
  if (type === 'model') return '\u{1F9CA}';
  if (type === 'audio') return '\u{1F50A}';
  if (type === 'svg') return '\u{2712}';
  return '\u{1F5BC}';
}

function createGLTexture(gl, source) {
  const tex = gl.createTexture();
  gl.bindTexture(gl.TEXTURE_2D, tex);
  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, source);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
  gl.bindTexture(gl.TEXTURE_2D, null);
  return tex;
}

// ============================================================
// WebGL Renderer
// ============================================================

function _tryGetWebGL(canvas) {
  return canvas.getContext('webgl', { antialias: false, preserveDrawingBuffer: true, powerPreference: 'high-performance', failIfMajorPerformanceCaveat: false })
      || canvas.getContext('webgl', { antialias: false, preserveDrawingBuffer: true, failIfMajorPerformanceCaveat: false })
      || canvas.getContext('experimental-webgl', { antialias: false, preserveDrawingBuffer: true });
}

async function _getWebGLWithRetry(canvas, maxRetries, dbg) {
  for (let attempt = 0; attempt <= maxRetries; attempt++) {
    const gl = _tryGetWebGL(canvas);
    if (gl) return gl;
    if (dbg) dbg('WebGL attempt ' + (attempt + 1) + ' failed, retrying in ' + (500 * (attempt + 1)) + 'ms...');
    await new Promise(r => setTimeout(r, 500 * (attempt + 1)));
  }
  return null;
}

class Renderer {
  constructor(canvas, gl) {
    this.canvas = canvas;
    this.gl = gl;
    if (!this.gl) throw new Error('WebGL not supported — close other tabs and refresh');
    this.program = null;
    this.uniformLocs = {};
    this.inputValues = {};
    this.startTime = performance.now();
    this.frameIndex = 0;
    this.playing = true;
    this.animId = null;
    this.textures = {}; // name → { glTexture, isVideo, element }
    this._bgProgram = null;
    this._bgUniformLocs = {};
    // Mouse state for interactive shaders
    this.mousePos = [0.5, 0.5];
    this.mouseDelta = [0, 0];
    this._lastMousePos = [0.5, 0.5];
    this._initGeometry();
    this.resize();
    window.addEventListener('resize', () => this.resize());
    // Default 1x1 black texture (avoids sampling null)
    this._defaultTex = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, this._defaultTex);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, new Uint8Array([0,0,0,255]));
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
  }

  _initGeometry() {
    const gl = this.gl;
    const buf = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, buf);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1,-1, 3,-1, -1,3]), gl.STATIC_DRAW);
    this.posBuf = buf;
  }

  resize() {
    // Fixed 1920x1080 render resolution — CSS handles display scaling
    this.canvas.width = 1920;
    this.canvas.height = 1080;
    this.gl.viewport(0, 0, 1920, 1080);
  }

  // Reinitialize GL resources after context restore
  reinitGL() {
    const gl = this.gl;
    this._initGeometry();
    // Recreate default 1x1 black texture
    this._defaultTex = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, this._defaultTex);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, new Uint8Array([0,0,0,255]));
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    this.program = null;
    this.uniformLocs = {};
    this._ppFloatChecked = undefined; // re-check half-float support
    this.resize();
  }

  compile(vertSrc, fragSrc) {
    const gl = this.gl;
    const vs = this._compileShader(gl.VERTEX_SHADER, vertSrc);
    if (!vs.shader) return { ok: false, errors: 'Vertex: ' + vs.log };

    const fs = this._compileShader(gl.FRAGMENT_SHADER, fragSrc);
    if (!fs.shader) {
      gl.deleteShader(vs.shader);
      return { ok: false, errors: this._prettyErrors(fs.log) };
    }

    const prog = gl.createProgram();
    gl.attachShader(prog, vs.shader);
    gl.attachShader(prog, fs.shader);
    gl.bindAttribLocation(prog, 0, 'position');
    gl.linkProgram(prog);

    gl.deleteShader(vs.shader);
    gl.deleteShader(fs.shader);

    if (!gl.getProgramParameter(prog, gl.LINK_STATUS)) {
      const log = gl.getProgramInfoLog(prog);
      gl.deleteProgram(prog);
      return { ok: false, errors: 'Link: ' + log };
    }

    if (this.program) gl.deleteProgram(this.program);
    this.program = prog;
    this.uniformLocs = {};
    return { ok: true, errors: null };
  }

  _compileShader(type, src) {
    const gl = this.gl;
    if (gl.isContextLost()) return { shader: null, log: 'WebGL context lost' };
    const s = gl.createShader(type);
    if (!s) return { shader: null, log: 'WebGL context lost (createShader returned null)' };
    gl.shaderSource(s, src);
    gl.compileShader(s);
    if (!gl.getShaderParameter(s, gl.COMPILE_STATUS)) {
      const log = gl.getShaderInfoLog(s);
      gl.deleteShader(s);
      return { shader: null, log };
    }
    return { shader: s, log: null };
  }

  _prettyErrors(log) {
    if (!log) return '';
    const headerLines = this._headerLines || 14;
    return log.replace(/ERROR:\s*\d+:(\d+)/g, (m, line) => {
      const adjusted = Math.max(1, parseInt(line) - headerLines);
      return `Line ${adjusted}`;
    });
  }

  _getLoc(name) {
    if (!(name in this.uniformLocs)) {
      this.uniformLocs[name] = this.gl.getUniformLocation(this.program, name);
    }
    return this.uniformLocs[name];
  }

  _getBgLoc(name) {
    if (!(name in this._bgUniformLocs)) {
      this._bgUniformLocs[name] = this.gl.getUniformLocation(this._bgProgram, name);
    }
    return this._bgUniformLocs[name];
  }

  compileBg(vertSrc, fragSrc) {
    const gl = this.gl;
    if (this._bgProgram) { gl.deleteProgram(this._bgProgram); this._bgProgram = null; }
    this._bgUniformLocs = {};
    if (!fragSrc) return { ok: true }; // clearing bg

    const vs = this._compileShader(gl.VERTEX_SHADER, vertSrc);
    if (!vs.shader) return { ok: false, errors: 'BG Vertex: ' + vs.log };
    const fs = this._compileShader(gl.FRAGMENT_SHADER, fragSrc);
    if (!fs.shader) { gl.deleteShader(vs.shader); return { ok: false, errors: 'BG: ' + fs.log }; }
    const prog = gl.createProgram();
    gl.attachShader(prog, vs.shader);
    gl.attachShader(prog, fs.shader);
    gl.bindAttribLocation(prog, 0, 'position');
    gl.linkProgram(prog);
    gl.deleteShader(vs.shader);
    gl.deleteShader(fs.shader);
    if (!gl.getProgramParameter(prog, gl.LINK_STATUS)) {
      gl.deleteProgram(prog);
      return { ok: false, errors: 'BG Link failed' };
    }
    this._bgProgram = prog;
    return { ok: true };
  }

  _renderBg() {
    const gl = this.gl;
    if (!this._bgProgram) return;

    gl.useProgram(this._bgProgram);
    const elapsed = (performance.now() - this.startTime) / 1000;
    const tLoc = this._getBgLoc('TIME');
    if (tLoc) gl.uniform1f(tLoc, elapsed);
    const rLoc = this._getBgLoc('RENDERSIZE');
    if (rLoc) gl.uniform2f(rLoc, this.canvas.width, this.canvas.height);
    const pLoc = this._getBgLoc('PASSINDEX');
    if (pLoc) gl.uniform1i(pLoc, 0);
    const fLoc = this._getBgLoc('FRAMEINDEX');
    if (fLoc) gl.uniform1i(fLoc, this.frameIndex);

    // Set bg shader's own input defaults (stored on renderer)
    if (this._bgInputValues) {
      for (const [name, val] of Object.entries(this._bgInputValues)) {
        const loc = this._getBgLoc(name);
        if (!loc) continue;
        if (typeof val === 'number') gl.uniform1f(loc, val);
        else if (typeof val === 'boolean') gl.uniform1i(loc, val ? 1 : 0);
        else if (Array.isArray(val)) {
          if (val.length === 2) gl.uniform2f(loc, val[0], val[1]);
          else if (val.length === 4) gl.uniform4f(loc, val[0], val[1], val[2], val[3]);
        }
      }
    }

    // Audio uniforms for bg shader
    if (audioFFTGLTexture) {
      gl.activeTexture(gl.TEXTURE0);
      gl.bindTexture(gl.TEXTURE_2D, audioFFTGLTexture);
      const aLoc = this._getBgLoc('audioFFT');
      if (aLoc) gl.uniform1i(aLoc, 0);
    }
    const bgAl = this._getBgLoc('audioLevel');
    if (bgAl) gl.uniform1f(bgAl, audioLevel);
    const bgAb = this._getBgLoc('audioBass');
    if (bgAb) gl.uniform1f(bgAb, audioBass);
    const bgAm = this._getBgLoc('audioMid');
    if (bgAm) gl.uniform1f(bgAm, audioMid);
    const bgAh = this._getBgLoc('audioHigh');
    if (bgAh) gl.uniform1f(bgAh, audioHigh);

    gl.bindBuffer(gl.ARRAY_BUFFER, this.posBuf);
    gl.enableVertexAttribArray(0);
    gl.vertexAttribPointer(0, 2, gl.FLOAT, false, 0, 0);
    gl.drawArrays(gl.TRIANGLES, 0, 3);
  }

  render() {
    const gl = this.gl;
    if (gl.isContextLost()) return;
    if (!this.program) return;

    // Render background shader first (if set)
    if (this._bgProgram) {
      gl.disable(gl.BLEND);
      this._renderBg();
      // Now enable blending so foreground composites on top
      gl.enable(gl.BLEND);
      gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
    } else {
      gl.disable(gl.BLEND);
    }

    gl.useProgram(this.program);

    const elapsed = (performance.now() - this.startTime) / 1000;
    const timeLoc = this._getLoc('TIME');
    if (timeLoc) gl.uniform1f(timeLoc, elapsed);

    const resLoc = this._getLoc('RENDERSIZE');
    if (resLoc) gl.uniform2f(resLoc, this.canvas.width, this.canvas.height);

    const piLoc = this._getLoc('PASSINDEX');
    if (piLoc) gl.uniform1i(piLoc, 0);

    const fiLoc = this._getLoc('FRAMEINDEX');
    if (fiLoc) gl.uniform1i(fiLoc, this.frameIndex);

    for (const [name, val] of Object.entries(this.inputValues)) {
      const loc = this._getLoc(name);
      if (!loc) continue;
      if (typeof val === 'number') gl.uniform1f(loc, val);
      else if (typeof val === 'boolean') gl.uniform1i(loc, val ? 1 : 0);
      else if (Array.isArray(val)) {
        if (val.length === 2) gl.uniform2f(loc, val[0], val[1]);
        else if (val.length === 4) gl.uniform4f(loc, val[0], val[1], val[2], val[3]);
      }
    }

    // Bind textures
    let texUnit = 0;
    for (const [name, tex] of Object.entries(this.textures)) {
      gl.activeTexture(gl.TEXTURE0 + texUnit);
      gl.bindTexture(gl.TEXTURE_2D, tex.glTexture);
      if (tex.isVideo && tex.element && (tex.element.readyState >= 2 || tex.element instanceof HTMLCanvasElement)) {
        if (tex._isNdi) gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
        if (tex.flipH || tex.flipV) {
          // Mirror webcam: draw flipped to offscreen canvas
          if (!tex._flipCanvas) {
            tex._flipCanvas = document.createElement('canvas');
            tex._flipCtx = tex._flipCanvas.getContext('2d');
          }
          const v = tex.element;
          const fc = tex._flipCanvas;
          const vw = v.videoWidth || v.width || 640;
          const vh = v.videoHeight || v.height || 480;
          if (fc.width !== vw || fc.height !== vh) {
            fc.width = vw;
            fc.height = vh;
          }
          const ctx = tex._flipCtx;
          ctx.save();
          ctx.translate(tex.flipH ? fc.width : 0, tex.flipV ? fc.height : 0);
          ctx.scale(tex.flipH ? -1 : 1, tex.flipV ? -1 : 1);
          ctx.drawImage(v, 0, 0);
          ctx.restore();
          gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, fc);
        } else {
          gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, tex.element);
        }
        if (tex._isNdi) gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
      }
      gl.uniform1i(this._getLoc(name), texUnit);
      texUnit++;
    }

    // Audio-reactive uniforms
    updateAudioUniforms(gl);
    if (audioFFTGLTexture) {
      gl.activeTexture(gl.TEXTURE0 + texUnit);
      gl.bindTexture(gl.TEXTURE_2D, audioFFTGLTexture);
      gl.uniform1i(this._getLoc('audioFFT'), texUnit);
      texUnit++;
    }
    const alLoc = this._getLoc('audioLevel');
    if (alLoc) gl.uniform1f(alLoc, audioLevel);
    const abLoc = this._getLoc('audioBass');
    if (abLoc) gl.uniform1f(abLoc, audioBass);
    const amLoc = this._getLoc('audioMid');
    if (amLoc) gl.uniform1f(amLoc, audioMid);
    const ahLoc = this._getLoc('audioHigh');
    if (ahLoc) gl.uniform1f(ahLoc, audioHigh);

    // Audio reactivity: modulate shader params with audio levels
    if (this.inputValues['audioReactive']) {
      const sp = this.inputValues['speed'];
      const spLoc = this._getLoc('speed');
      if (sp != null && spLoc) gl.uniform1f(spLoc, sp + audioLevel * 1.5);

      const int_ = this.inputValues['intensity'];
      const intLoc = this._getLoc('intensity');
      if (int_ != null && intLoc) gl.uniform1f(intLoc, Math.min(1, int_ + audioBass * 0.7));

      const ts = this.inputValues['textScale'];
      const tsLoc = this._getLoc('textScale');
      if (ts != null && tsLoc) gl.uniform1f(tsLoc, ts * (1 + audioBass * 0.3));
    }

    // Variable font texture (for Text shader effects 20 + 22)
    const vfLoc = this._getLoc('varFontTex');
    if (vfLoc) {
      const _effectIdx = Math.round(this.inputValues['effect'] || 0);
      if (_effectIdx === 22) {
        updateBreathingTexture(gl, this.inputValues);
      } else {
        updateVarFontTexture(gl, this.inputValues);
      }
      if (_vfGLTexture) {
        gl.activeTexture(gl.TEXTURE0 + texUnit);
        gl.bindTexture(gl.TEXTURE_2D, _vfGLTexture);
        gl.uniform1i(vfLoc, texUnit);
        texUnit++;
      }
    }

    // Font atlas texture — always enabled to avoid 26-branch charData() in shader
    const _useFontAtlasLoc = this._getLoc('useFontAtlas');
    if (_useFontAtlasLoc) gl.uniform1f(_useFontAtlasLoc, 1.0);
    updateFontAtlas(gl, this.inputValues);
    if (_fontAtlasGLTexture) {
      const faLoc = this._getLoc('fontAtlasTex');
      if (faLoc) {
        gl.activeTexture(gl.TEXTURE0 + texUnit);
        gl.bindTexture(gl.TEXTURE_2D, _fontAtlasGLTexture);
        gl.uniform1i(faLoc, texUnit);
        texUnit++;
      }
    }

    // Global mask texture
    const _maskModeLoc = this._getLoc('_maskMode');
    if (_maskModeLoc) gl.uniform1f(_maskModeLoc, _maskMode);
    const _maskFlipLoc = this._getLoc('_maskFlip');
    const _maskFlipVLoc = this._getLoc('_maskFlipV');
    if (_maskFlipLoc) gl.uniform1f(_maskFlipLoc, 0.0);
    if (_maskFlipVLoc) gl.uniform1f(_maskFlipVLoc, 0.0);
    if (_maskMediaId && _maskMode > 0) {
      const maskMedia = mediaInputs.find(m => String(m.id) === String(_maskMediaId));
      if (maskMedia && maskMedia.glTexture) {
        gl.activeTexture(gl.TEXTURE0 + texUnit);
        gl.bindTexture(gl.TEXTURE_2D, maskMedia.glTexture);
        if (maskMedia.type === 'video' && maskMedia.element && maskMedia.element.readyState >= 2) {
          gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, maskMedia.element);
        }
        if (_maskFlipLoc && maskMedia._webcamFlip) gl.uniform1f(_maskFlipLoc, 1.0);
        if (_maskFlipVLoc && maskMedia._webcamFlipV) gl.uniform1f(_maskFlipVLoc, 1.0);
        gl.uniform1i(this._getLoc('_maskTex'), texUnit);
        texUnit++;
      }
    }

    gl.bindBuffer(gl.ARRAY_BUFFER, this.posBuf);
    gl.enableVertexAttribArray(0);
    gl.vertexAttribPointer(0, 2, gl.FLOAT, false, 0, 0);
    gl.drawArrays(gl.TRIANGLES, 0, 3);

    this.frameIndex++;
  }

  start() {
    if (this.playing && this.animId) return;
    this.playing = true;
    const loop = () => {
      if (!this.playing) return;
      this.render();
      this.animId = requestAnimationFrame(loop);
    };
    loop();
  }

  stop() {
    this.playing = false;
    if (this.animId) cancelAnimationFrame(this.animId);
    this.animId = null;
  }

  togglePlay() {
    if (this.playing) this.stop();
    else this.start();
    return this.playing;
  }

  resetTime() {
    this.startTime = performance.now();
    this.frameIndex = 0;
  }

  // ===== LAYER COMPOSITION EXTENSIONS =====

  createFBO(w, h) {
    const gl = this.gl;
    const fbo = gl.createFramebuffer();
    const tex = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, tex);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, w, h, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);
    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, tex, 0);
    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    return { fbo, texture: tex, width: w, height: h };
  }

  createPingPongFBO(w, h) {
    // Check half-float FBO support once (needed for simulations with negative values)
    if (this._ppFloatChecked === undefined) {
      this._ppFloatChecked = true;
      this._halfFloatExt = this.gl.getExtension('OES_texture_half_float');
      this._halfFloatLinear = this.gl.getExtension('OES_texture_half_float_linear');
      this.gl.getExtension('EXT_color_buffer_half_float');
      this._useHalfFloat = false;
      if (this._halfFloatExt) {
        const test = this._createHalfFloatFBO(4, 4);
        if (test) {
          this._useHalfFloat = true;
          this.gl.deleteTexture(test.texture);
          this.gl.deleteFramebuffer(test.fbo);
        }
      }
    }
    if (this._useHalfFloat) {
      return { a: this._createHalfFloatFBO(w, h), b: this._createHalfFloatFBO(w, h), current: 0 };
    }
    return { a: this.createFBO(w, h), b: this.createFBO(w, h), current: 0 };
  }

  _createHalfFloatFBO(w, h) {
    const gl = this.gl;
    const fbo = gl.createFramebuffer();
    const tex = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, tex);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, w, h, 0, gl.RGBA, this._halfFloatExt.HALF_FLOAT_OES, null);
    const filter = this._halfFloatLinear ? gl.LINEAR : gl.NEAREST;
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, filter);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, filter);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);
    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, tex, 0);
    if (gl.checkFramebufferStatus(gl.FRAMEBUFFER) !== gl.FRAMEBUFFER_COMPLETE) {
      gl.deleteTexture(tex);
      gl.deleteFramebuffer(fbo);
      gl.bindFramebuffer(gl.FRAMEBUFFER, null);
      return null;
    }
    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    return { fbo, texture: tex, width: w, height: h };
  }

  destroyFBO(fboObj) {
    if (!fboObj) return;
    const gl = this.gl;
    if (fboObj.texture) gl.deleteTexture(fboObj.texture);
    if (fboObj.fbo) gl.deleteFramebuffer(fboObj.fbo);
  }

  destroyPingPongFBO(pp) {
    if (!pp) return;
    this.destroyFBO(pp.a);
    this.destroyFBO(pp.b);
  }

  compileForLayer(layer, vertSrc, fragSrc, precompiledProg) {
    const gl = this.gl;
    if (gl.isContextLost()) return { ok: false, errors: 'WebGL context lost' };
    let prog;
    if (precompiledProg) {
      prog = precompiledProg;
    } else {
      const vs = this._compileShader(gl.VERTEX_SHADER, vertSrc);
      if (!vs.shader) return { ok: false, errors: 'Vertex: ' + vs.log };
      const fs = this._compileShader(gl.FRAGMENT_SHADER, fragSrc);
      if (!fs.shader) { gl.deleteShader(vs.shader); return { ok: false, errors: this._prettyErrors(fs.log) }; }
      prog = gl.createProgram();
      gl.attachShader(prog, vs.shader);
      gl.attachShader(prog, fs.shader);
      gl.bindAttribLocation(prog, 0, 'position');
      gl.linkProgram(prog);
      gl.deleteShader(vs.shader);
      gl.deleteShader(fs.shader);
      if (!gl.getProgramParameter(prog, gl.LINK_STATUS)) {
        const log = gl.getProgramInfoLog(prog);
        gl.deleteProgram(prog);
        return { ok: false, errors: 'Link: ' + log };
      }
    }
    if (layer.program) gl.deleteProgram(layer.program);
    layer.program = prog;
    layer.uniformLocs = {};
    return { ok: true, errors: null };
  }

  // Async shader compilation using KHR_parallel_shader_compile
  startAsyncCompile(vertSrc, fragSrc) {
    const gl = this.gl;
    if (gl.isContextLost()) return null;
    if (this._parallelExt === undefined) this._parallelExt = gl.getExtension('KHR_parallel_shader_compile') || null;

    const vs = gl.createShader(gl.VERTEX_SHADER);
    gl.shaderSource(vs, vertSrc);
    gl.compileShader(vs);
    const fs = gl.createShader(gl.FRAGMENT_SHADER);
    gl.shaderSource(fs, fragSrc);
    gl.compileShader(fs);

    const prog = gl.createProgram();
    gl.attachShader(prog, vs);
    gl.attachShader(prog, fs);
    gl.bindAttribLocation(prog, 0, 'position');
    gl.linkProgram(prog);

    const ext = this._parallelExt;
    let _resolved = false;
    const self = this;

    return {
      program: prog,
      isReady() {
        if (_resolved) return true;
        if (ext && !gl.getProgramParameter(prog, ext.COMPLETION_STATUS_KHR)) return false;
        _resolved = true;
        return true;
      },
      finalize() {
        const errors = [];
        if (!gl.getShaderParameter(vs, gl.COMPILE_STATUS))
          errors.push('Vertex: ' + gl.getShaderInfoLog(vs));
        if (!gl.getShaderParameter(fs, gl.COMPILE_STATUS))
          errors.push('Fragment: ' + self._prettyErrors(gl.getShaderInfoLog(fs)));
        gl.deleteShader(vs);
        gl.deleteShader(fs);
        if (errors.length) { gl.deleteProgram(prog); return { ok: false, errors: errors.join('\n') }; }
        if (!gl.getProgramParameter(prog, gl.LINK_STATUS)) {
          const log = gl.getProgramInfoLog(prog);
          gl.deleteProgram(prog); return { ok: false, errors: 'Link: ' + log };
        }
        return { ok: true, program: prog };
      },
      dispose() { gl.deleteShader(vs); gl.deleteShader(fs); gl.deleteProgram(prog); }
    };
  }

  _getLayerLoc(layer, name) {
    if (!(name in layer.uniformLocs)) {
      layer.uniformLocs[name] = this.gl.getUniformLocation(layer.program, name);
    }
    return layer.uniformLocs[name];
  }

  renderLayerToFBO(layer, mediaPipeMgr) {
    const gl = this.gl;
    if (gl.isContextLost()) return;
    if (!layer.program || !layer.fbo) return;
    if (!layer.visible) return;

    // Multi-pass branch
    if (layer.passes && layer.passes.length > 0) {
      this._renderMultiPass(layer, mediaPipeMgr);
      return;
    }

    gl.bindFramebuffer(gl.FRAMEBUFFER, layer.fbo.fbo);
    gl.viewport(0, 0, layer.fbo.width, layer.fbo.height);
    const bgC = layer._bgColor;
    gl.clearColor(bgC ? bgC[0] : 0, bgC ? bgC[1] : 0, bgC ? bgC[2] : 0, bgC ? 1 : 0);
    gl.clear(gl.COLOR_BUFFER_BIT);
    gl.disable(gl.BLEND);

    gl.useProgram(layer.program);

    const elapsed = (performance.now() - this.startTime) / 1000;
    const tLoc = this._getLayerLoc(layer, 'TIME');
    if (tLoc) gl.uniform1f(tLoc, elapsed);
    const rLoc = this._getLayerLoc(layer, 'RENDERSIZE');
    if (rLoc) gl.uniform2f(rLoc, layer.fbo.width, layer.fbo.height);
    const piLoc = this._getLayerLoc(layer, 'PASSINDEX');
    if (piLoc) gl.uniform1i(piLoc, 0);
    const fiLoc = this._getLayerLoc(layer, 'FRAMEINDEX');
    if (fiLoc) gl.uniform1i(fiLoc, this.frameIndex);

    // Transparent background flag
    const tbLoc = this._getLayerLoc(layer, '_transparentBg');
    if (tbLoc) gl.uniform1f(tbLoc, layer.transparentBg ? 1.0 : 0.0);

    // Voice decay glitch amount
    const vgLoc = this._getLayerLoc(layer, '_voiceGlitch');
    if (vgLoc) gl.uniform1f(vgLoc, layer._voiceGlitch || 0.0);

    // Resolve MediaPipe bindings before setting input values
    if (layer.mpBindings && layer.mpBindings.length > 0 && mediaPipeMgr && mediaPipeMgr.active) {
      resolveBindings(layer, mediaPipeMgr);
    }

    // Set layer input values
    for (const [name, val] of Object.entries(layer.inputValues || {})) {
      const loc = this._getLayerLoc(layer, name);
      if (!loc) continue;
      if (typeof val === 'number') gl.uniform1f(loc, val);
      else if (typeof val === 'boolean') gl.uniform1i(loc, val ? 1 : 0);
      else if (Array.isArray(val)) {
        if (val.length === 2) gl.uniform2f(loc, val[0], val[1]);
        else if (val.length === 4) gl.uniform4f(loc, val[0], val[1], val[2], val[3]);
      }
    }

    // Direct msg uniform override for text layer — reads prominent bar value
    // and sets msg_0..msg_23 every frame, bypassing inputValues
    if (layer.id === 'text') {
      if (!layer._msgBar) layer._msgBar = document.getElementById('text-msg-input');
      if (layer._msgBar) {
        const raw = layer._msgBar.value;
        if (raw !== layer._msgCached) {
          layer._msgCached = raw;
          const str = raw.trim().toUpperCase();
          layer._msgCodes = new Float32Array(24);
          for (let j = 0; j < 24; j++) {
            const ch = str[j];
            if (!ch) { layer._msgCodes[j] = 26; continue; }
            const cc = ch.charCodeAt(0) - 65;
            layer._msgCodes[j] = (cc >= 0 && cc <= 25) ? cc : 26;
          }
        }
        if (layer._msgCodes) {
          for (let j = 0; j < 24; j++) {
            const loc = this._getLayerLoc(layer, 'msg_' + j);
            if (loc) gl.uniform1f(loc, layer._msgCodes[j]);
          }
        }
      }
    }

    // Bind layer textures
    let texUnit = 0;
    for (const [name, tex] of Object.entries(layer.textures || {})) {
      gl.activeTexture(gl.TEXTURE0 + texUnit);
      gl.bindTexture(gl.TEXTURE_2D, tex.glTexture);
      if (tex.isVideo && tex.element && (tex.element.readyState >= 2 || tex.element instanceof HTMLCanvasElement)) {
        if (tex._isNdi) gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
        if (tex.flipH || tex.flipV) {
          if (!tex._flipCanvas) { tex._flipCanvas = document.createElement('canvas'); tex._flipCtx = tex._flipCanvas.getContext('2d'); }
          const v = tex.element, fc = tex._flipCanvas;
          const vw = v.videoWidth || v.width || 640;
          const vh = v.videoHeight || v.height || 480;
          if (fc.width !== vw || fc.height !== vh) { fc.width = vw; fc.height = vh; }
          const ctx = tex._flipCtx;
          ctx.save();
          ctx.translate(tex.flipH ? fc.width : 0, tex.flipV ? fc.height : 0);
          ctx.scale(tex.flipH ? -1 : 1, tex.flipV ? -1 : 1);
          ctx.drawImage(v, 0, 0);
          ctx.restore();
          gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, fc);
        } else {
          gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, tex.element);
        }
        if (tex._isNdi) gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
      }
      gl.uniform1i(this._getLayerLoc(layer, name), texUnit);
      texUnit++;
    }

    // Bind extras (audio, font, mediapipe) and draw
    texUnit = this._bindLayerExtras(layer, mediaPipeMgr, texUnit);

    // Mouse uniforms — hand-as-mouse override when enabled
    let mx = this.mousePos[0], my = this.mousePos[1];
    if (layer.handAsMouse && mediaPipeMgr && mediaPipeMgr.active && mediaPipeMgr.handCount > 0) {
      mx = mediaPipeMgr.handPos[0];
      my = mediaPipeMgr.handPos[1];
    }
    const mousePLoc = this._getLayerLoc(layer, 'mousePos');
    if (mousePLoc) gl.uniform2f(mousePLoc, mx, my);
    const mouseDLoc = this._getLayerLoc(layer, 'mouseDelta');
    if (mouseDLoc) gl.uniform2f(mouseDLoc, this.mouseDelta[0], this.mouseDelta[1]);

    gl.bindBuffer(gl.ARRAY_BUFFER, this.posBuf);
    gl.enableVertexAttribArray(0);
    gl.vertexAttribPointer(0, 2, gl.FLOAT, false, 0, 0);
    gl.drawArrays(gl.TRIANGLES, 0, 3);

    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    gl.viewport(0, 0, this.canvas.width, this.canvas.height);
  }

  // Shared helper: bind audio, font, mediapipe textures/uniforms. Returns next texUnit.
  _bindLayerExtras(layer, mediaPipeMgr, texUnit) {
    const gl = this.gl;
    // Audio uniforms
    updateAudioUniforms(gl);
    if (audioFFTGLTexture) {
      gl.activeTexture(gl.TEXTURE0 + texUnit);
      gl.bindTexture(gl.TEXTURE_2D, audioFFTGLTexture);
      gl.uniform1i(this._getLayerLoc(layer, 'audioFFT'), texUnit);
      texUnit++;
    }
    const alLoc = this._getLayerLoc(layer, 'audioLevel');
    if (alLoc) gl.uniform1f(alLoc, audioLevel);
    const abLoc = this._getLayerLoc(layer, 'audioBass');
    if (abLoc) gl.uniform1f(abLoc, audioBass);
    const amLoc = this._getLayerLoc(layer, 'audioMid');
    if (amLoc) gl.uniform1f(amLoc, audioMid);
    const ahLoc = this._getLayerLoc(layer, 'audioHigh');
    if (ahLoc) gl.uniform1f(ahLoc, audioHigh);

    // Audio reactivity modulation
    if (layer.inputValues && layer.inputValues['audioReactive']) {
      const sp = layer.inputValues['speed'];
      const spLoc = this._getLayerLoc(layer, 'speed');
      if (sp != null && spLoc) gl.uniform1f(spLoc, sp + audioLevel * 1.5);
      const int_ = layer.inputValues['intensity'];
      const intLoc = this._getLayerLoc(layer, 'intensity');
      if (int_ != null && intLoc) gl.uniform1f(intLoc, Math.min(1, int_ + audioBass * 0.7));
      const ts = layer.inputValues['textScale'];
      const tsLoc = this._getLayerLoc(layer, 'textScale');
      if (ts != null && tsLoc) gl.uniform1f(tsLoc, ts * (1 + audioBass * 0.3));
    }

    // Variable font texture (effects 20 + 22)
    const vfLoc = this._getLayerLoc(layer, 'varFontTex');
    if (vfLoc) {
      const _layerEffectIdx = Math.round((layer.inputValues || {})['effect'] || 0);
      if (_layerEffectIdx === 22) {
        updateBreathingTexture(gl, layer.inputValues || {});
      } else {
        updateVarFontTexture(gl, layer.inputValues || {});
      }
      if (_vfGLTexture) {
        gl.activeTexture(gl.TEXTURE0 + texUnit);
        gl.bindTexture(gl.TEXTURE_2D, _vfGLTexture);
        gl.uniform1i(vfLoc, texUnit);
        texUnit++;
      }
    }

    // Font atlas — always enabled to avoid 26-branch charData() in shader
    const _useFontAtlasLoc = this._getLayerLoc(layer, 'useFontAtlas');
    if (_useFontAtlasLoc) gl.uniform1f(_useFontAtlasLoc, 1.0);
    updateFontAtlas(gl, layer.inputValues || {});
    if (_fontAtlasGLTexture) {
      const faLoc = this._getLayerLoc(layer, 'fontAtlasTex');
      if (faLoc) {
        gl.activeTexture(gl.TEXTURE0 + texUnit);
        gl.bindTexture(gl.TEXTURE_2D, _fontAtlasGLTexture);
        gl.uniform1i(faLoc, texUnit);
        texUnit++;
      }
    }

    // MediaPipe uniforms
    if (mediaPipeMgr && mediaPipeMgr.active) {
      if (mediaPipeMgr.handTex) {
        gl.activeTexture(gl.TEXTURE0 + texUnit);
        gl.bindTexture(gl.TEXTURE_2D, mediaPipeMgr.handTex);
        gl.uniform1i(this._getLayerLoc(layer, 'mpHandLandmarks'), texUnit++);
      }
      if (mediaPipeMgr.faceTex) {
        gl.activeTexture(gl.TEXTURE0 + texUnit);
        gl.bindTexture(gl.TEXTURE_2D, mediaPipeMgr.faceTex);
        gl.uniform1i(this._getLayerLoc(layer, 'mpFaceLandmarks'), texUnit++);
      }
      if (mediaPipeMgr.poseTex) {
        gl.activeTexture(gl.TEXTURE0 + texUnit);
        gl.bindTexture(gl.TEXTURE_2D, mediaPipeMgr.poseTex);
        gl.uniform1i(this._getLayerLoc(layer, 'mpPoseLandmarks'), texUnit++);
      }
      if (mediaPipeMgr.segTex) {
        gl.activeTexture(gl.TEXTURE0 + texUnit);
        gl.bindTexture(gl.TEXTURE_2D, mediaPipeMgr.segTex);
        gl.uniform1i(this._getLayerLoc(layer, 'mpSegMask'), texUnit++);
      }
      const hcLoc = this._getLayerLoc(layer, 'mpHandCount');
      if (hcLoc) gl.uniform1f(hcLoc, mediaPipeMgr.handCount);
      const hpLoc = this._getLayerLoc(layer, 'mpHandPos');
      if (hpLoc) gl.uniform3f(hpLoc, mediaPipeMgr.handPos[0], mediaPipeMgr.handPos[1], mediaPipeMgr.handPos[2]);
    }

    return texUnit;
  }

  // Multi-pass rendering with persistent ping-pong buffers
  _renderMultiPass(layer, mediaPipeMgr) {
    const gl = this.gl;
    if (gl.isContextLost()) return;
    gl.useProgram(layer.program);
    gl.disable(gl.BLEND);

    const elapsed = (performance.now() - this.startTime) / 1000;
    const tLoc = this._getLayerLoc(layer, 'TIME');
    if (tLoc) gl.uniform1f(tLoc, elapsed);
    const fiLoc = this._getLayerLoc(layer, 'FRAMEINDEX');
    if (fiLoc) gl.uniform1i(fiLoc, this.frameIndex);
    const tbLoc = this._getLayerLoc(layer, '_transparentBg');
    if (tbLoc) gl.uniform1f(tbLoc, layer.transparentBg ? 1.0 : 0.0);
    const vgLoc2 = this._getLayerLoc(layer, '_voiceGlitch');
    if (vgLoc2) gl.uniform1f(vgLoc2, layer._voiceGlitch || 0.0);

    // Mouse uniforms — hand-as-mouse override
    let mpMx = this.mousePos[0], mpMy = this.mousePos[1];
    if (layer.handAsMouse && mediaPipeMgr && mediaPipeMgr.active && mediaPipeMgr.handCount > 0) {
      mpMx = mediaPipeMgr.handPos[0];
      mpMy = mediaPipeMgr.handPos[1];
    }
    const mousePLoc = this._getLayerLoc(layer, 'mousePos');
    if (mousePLoc) gl.uniform2f(mousePLoc, mpMx, mpMy);
    const mouseDLoc = this._getLayerLoc(layer, 'mouseDelta');
    if (mouseDLoc) gl.uniform2f(mouseDLoc, this.mouseDelta[0], this.mouseDelta[1]);

    // Resolve MediaPipe bindings
    if (layer.mpBindings && layer.mpBindings.length > 0 && mediaPipeMgr && mediaPipeMgr.active) {
      resolveBindings(layer, mediaPipeMgr);
    }

    // Set input values
    for (const [name, val] of Object.entries(layer.inputValues || {})) {
      const loc = this._getLayerLoc(layer, name);
      if (!loc) continue;
      if (typeof val === 'number') gl.uniform1f(loc, val);
      else if (typeof val === 'boolean') gl.uniform1i(loc, val ? 1 : 0);
      else if (Array.isArray(val)) {
        if (val.length === 2) gl.uniform2f(loc, val[0], val[1]);
        else if (val.length === 4) gl.uniform4f(loc, val[0], val[1], val[2], val[3]);
      }
    }

    // Bind layer textures (media inputs)
    let texUnit = 0;
    for (const [name, tex] of Object.entries(layer.textures || {})) {
      gl.activeTexture(gl.TEXTURE0 + texUnit);
      gl.bindTexture(gl.TEXTURE_2D, tex.glTexture);
      if (tex.isVideo && tex.element && (tex.element.readyState >= 2 || tex.element instanceof HTMLCanvasElement)) {
        if (tex._isNdi) gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
        if (tex.flipH || tex.flipV) {
          if (!tex._flipCanvas) { tex._flipCanvas = document.createElement('canvas'); tex._flipCtx = tex._flipCanvas.getContext('2d'); }
          const v = tex.element, fc = tex._flipCanvas;
          const vw = v.videoWidth || v.width || 640;
          const vh = v.videoHeight || v.height || 480;
          if (fc.width !== vw || fc.height !== vh) { fc.width = vw; fc.height = vh; }
          const ctx = tex._flipCtx;
          ctx.save();
          ctx.translate(tex.flipH ? fc.width : 0, tex.flipV ? fc.height : 0);
          ctx.scale(tex.flipH ? -1 : 1, tex.flipV ? -1 : 1);
          ctx.drawImage(v, 0, 0);
          ctx.restore();
          gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, fc);
        } else {
          gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, tex.element);
        }
        if (tex._isNdi) gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
      }
      gl.uniform1i(this._getLayerLoc(layer, name), texUnit);
      texUnit++;
    }

    // Bind extras (audio, font, mediapipe)
    texUnit = this._bindLayerExtras(layer, mediaPipeMgr, texUnit);

    // Reserve texture units for TARGET buffers
    const targetBaseUnit = texUnit;
    const targetUnits = {};
    layer.passes.forEach((p, i) => {
      if (p.target) {
        targetUnits[p.target] = targetBaseUnit + i;
        texUnit++;
      }
    });

    // Prepare geometry
    gl.bindBuffer(gl.ARRAY_BUFFER, this.posBuf);
    gl.enableVertexAttribArray(0);
    gl.vertexAttribPointer(0, 2, gl.FLOAT, false, 0, 0);

    // Execute passes
    for (let i = 0; i < layer.passes.length; i++) {
      const pass = layer.passes[i];
      const isFinal = !pass.target;

      let outFBO;
      if (isFinal) {
        outFBO = layer.fbo;
      } else {
        const pp = pass.ppFBO;
        outFBO = pp.current === 0 ? pp.b : pp.a;
      }

      gl.bindFramebuffer(gl.FRAMEBUFFER, outFBO.fbo);
      gl.viewport(0, 0, outFBO.width, outFBO.height);

      if (!pass.persistent || isFinal) {
        gl.clearColor(0, 0, 0, 0);
        gl.clear(gl.COLOR_BUFFER_BIT);
      }

      const piLoc = this._getLayerLoc(layer, 'PASSINDEX');
      if (piLoc) gl.uniform1i(piLoc, i);
      const rLoc = this._getLayerLoc(layer, 'RENDERSIZE');
      if (rLoc) gl.uniform2f(rLoc, outFBO.width, outFBO.height);

      // Bind all TARGET textures (read sides)
      for (const [tName, tUnit] of Object.entries(targetUnits)) {
        const tPass = layer.passes.find(p => p.target === tName);
        if (!tPass || !tPass.ppFBO) continue;
        const readFBO = tPass.ppFBO.current === 0 ? tPass.ppFBO.a : tPass.ppFBO.b;
        gl.activeTexture(gl.TEXTURE0 + tUnit);
        gl.bindTexture(gl.TEXTURE_2D, readFBO.texture);
        gl.uniform1i(this._getLayerLoc(layer, tName), tUnit);
      }

      gl.drawArrays(gl.TRIANGLES, 0, 3);

      if (pass.persistent && pass.ppFBO) {
        pass.ppFBO.current ^= 1;
      }
    }

    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    gl.viewport(0, 0, this.canvas.width, this.canvas.height);
  }

  initCompositor() {
    const compFrag = `
precision highp float;
uniform sampler2D layer0;
uniform sampler2D layer1;
uniform sampler2D layer2;
uniform sampler2D layer3;
uniform float opacity0, opacity1, opacity2, opacity3;
uniform float visible0, visible1, visible2, visible3;
uniform float blendMode0, blendMode1, blendMode2, blendMode3;
uniform float flipH0, flipV0, flipH1, flipV1, flipH2, flipV2, flipH3, flipV3;
uniform vec2 RENDERSIZE;
uniform sampler2D bgTexture;
uniform float bgMode;
uniform vec3 bgColor;
uniform vec2 overlayTR;    // translate (x, y) in -1..1
uniform float overlayScale; // scale
uniform float overlayRot;   // rotation in radians
uniform float overlayImgAspect; // image width/height ratio
varying vec2 isf_FragNormCoord;
uniform float morphWidth;    // 0=square, 1=full rect
uniform float textureScale;  // 1=fill, >1=zoom in, <1=zoom out

vec2 uvForLayer(vec2 uv, float fh, float fv) {
  if (fh > 0.5) uv.x = 1.0 - uv.x;
  if (fv > 0.5) uv.y = 1.0 - uv.y;
  return uv;
}

vec2 uvForOverlay(vec2 uv) {
  float asp = RENDERSIZE.x / RENDERSIZE.y;
  float imgAsp = max(overlayImgAspect, 0.01);
  vec2 c = uv - 0.5 - vec2(overlayTR.x * 0.5, overlayTR.y * 0.5);
  c.x *= asp; // square space
  float cs = cos(-overlayRot);
  float sn = sin(-overlayRot);
  c = vec2(c.x * cs - c.y * sn, c.x * sn + c.y * cs);
  c /= max(overlayScale, 0.01);
  c.x /= imgAsp; // image aspect (preserves native proportions)
  return c + 0.5;
}

vec2 uvForMorph(vec2 uv) {
  float canvasAsp = RENDERSIZE.x / RENDERSIZE.y;
  float halfW = mix(0.5 / canvasAsp, 0.5, morphWidth);
  float left = 0.5 - halfW;
  float right = 0.5 + halfW;
  // Outside morph rect -> return -1 sentinel
  if (uv.x < left || uv.x > right) return vec2(-1.0);
  // Remap UV to fill the morph rect
  vec2 m = vec2((uv.x - left) / (right - left), uv.y);
  // Apply texture scale (zoom from center)
  m = (m - 0.5) / max(textureScale, 0.01) + 0.5;
  return m;
}

vec3 blendNormal(vec3 base, vec3 top, float a) { return mix(base, top, a); }
vec3 blendAdd(vec3 base, vec3 top, float a) { return base + top * a; }
vec3 blendMultiply(vec3 base, vec3 top, float a) { return mix(base, base * top, a); }
vec3 blendScreen(vec3 base, vec3 top, float a) { vec3 s = 1.0 - (1.0 - base) * (1.0 - top); return mix(base, s, a); }
vec3 blendOverlay(vec3 base, vec3 top, float a) {
  vec3 o = vec3(
    base.r < 0.5 ? 2.0*base.r*top.r : 1.0-2.0*(1.0-base.r)*(1.0-top.r),
    base.g < 0.5 ? 2.0*base.g*top.g : 1.0-2.0*(1.0-base.g)*(1.0-top.g),
    base.b < 0.5 ? 2.0*base.b*top.b : 1.0-2.0*(1.0-base.b)*(1.0-top.b)
  );
  return mix(base, o, a);
}

vec3 applyBlend(vec3 base, vec3 top, float a, float mode) {
  if (mode < 0.5) return blendNormal(base, top, a);
  if (mode < 1.5) return blendAdd(base, top, a);
  if (mode < 2.5) return blendMultiply(base, top, a);
  if (mode < 3.5) return blendScreen(base, top, a);
  return blendOverlay(base, top, a);
}

void main() {
  vec2 uv = isf_FragNormCoord;
  vec2 mUV = uvForMorph(uv);
  if (mUV.x < -0.5) { gl_FragColor = vec4(0.0); return; }
  uv = mUV;

  // Background
  vec4 result = vec4(0.0, 0.0, 0.0, 1.0);
  if (bgMode > 0.5 && bgMode < 1.5) result = vec4(0.0, 0.0, 0.0, 0.0);
  else if (bgMode > 1.5 && bgMode < 2.5) result = vec4(bgColor, 1.0);
  else if (bgMode > 2.5) result = texture2D(bgTexture, uv);

  // Layer 0 (base)
  if (visible0 > 0.5) {
    vec4 c = texture2D(layer0, uvForLayer(uv, flipH0, flipV0));
    float a = c.a * opacity0;
    result.rgb = applyBlend(result.rgb, c.rgb, a, blendMode0);
    result.a = max(result.a, a);
  }

  // Layer 1
  if (visible1 > 0.5) {
    vec4 c = texture2D(layer1, uvForLayer(uv, flipH1, flipV1));
    float a = c.a * opacity1;
    result.rgb = applyBlend(result.rgb, c.rgb, a, blendMode1);
    result.a = max(result.a, a);
  }

  // Layer 2
  if (visible2 > 0.5) {
    vec4 c = texture2D(layer2, uvForLayer(uv, flipH2, flipV2));
    float a = c.a * opacity2;
    result.rgb = applyBlend(result.rgb, c.rgb, a, blendMode2);
    result.a = max(result.a, a);
  }

  // Layer 3 (overlay — topmost, with transform)
  if (visible3 > 0.5) {
    vec2 ouv = uvForOverlay(uvForLayer(uv, flipH3, flipV3));
    vec4 c = vec4(0.0);
    if (ouv.x >= 0.0 && ouv.x <= 1.0 && ouv.y >= 0.0 && ouv.y <= 1.0)
      c = texture2D(layer3, ouv);
    float a = c.a * opacity3;
    result.rgb = applyBlend(result.rgb, c.rgb, a, blendMode3);
    result.a = max(result.a, a);
  }

  gl_FragColor = result;
}
`;
    const result = this.compile(VERT_SHADER, compFrag);
    if (result.ok) {
      this.compositorProgram = this.program;
      this.compositorLocs = {};
      this.program = null; // compositor stored separately
    } else {
      console.error('Compositor shader failed:', result.errors);
    }
    return result;
  }

  _getCompLoc(name) {
    if (!(name in this.compositorLocs)) {
      this.compositorLocs[name] = this.gl.getUniformLocation(this.compositorProgram, name);
    }
    return this.compositorLocs[name];
  }

  renderCompositor(layers, sceneTexture, bgState, morphOpts) {
    const gl = this.gl;
    if (gl.isContextLost()) return;
    if (!this.compositorProgram) return;

    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    gl.viewport(0, 0, this.canvas.width, this.canvas.height);
    gl.disable(gl.BLEND);
    gl.clearColor(0, 0, 0, 1);
    gl.clear(gl.COLOR_BUFFER_BIT);

    gl.useProgram(this.compositorProgram);

    const rLoc = this._getCompLoc('RENDERSIZE');
    if (rLoc) gl.uniform2f(rLoc, this.canvas.width, this.canvas.height);

    const blendModeMap = { normal: 0, add: 1, multiply: 2, screen: 3, overlay: 4 };

    // Bind layer textures (type-aware: scene layer uses sceneTexture, overlay/shader use FBO)
    const layerCount = Math.min(layers.length, 4);
    for (let i = 0; i < 4; i++) {
      gl.activeTexture(gl.TEXTURE0 + i);
      if (i < layerCount && layers[i] && layers[i].type === 'scene' && sceneTexture) {
        gl.bindTexture(gl.TEXTURE_2D, sceneTexture);
      } else if (i < layerCount && layers[i] && layers[i].fbo) {
        gl.bindTexture(gl.TEXTURE_2D, layers[i].fbo.texture);
      } else {
        gl.bindTexture(gl.TEXTURE_2D, this._defaultTex);
      }
      gl.uniform1i(this._getCompLoc('layer' + i), i);
      gl.uniform1f(this._getCompLoc('opacity' + i), (i < layerCount && layers[i]) ? layers[i].opacity : 0);
      gl.uniform1f(this._getCompLoc('visible' + i), (i < layerCount && layers[i] && layers[i].visible) ? 1.0 : 0.0);
      gl.uniform1f(this._getCompLoc('blendMode' + i), blendModeMap[(i < layerCount && layers[i]) ? layers[i].blendMode : 'normal'] || 0);

      // Per-layer flip uniforms
      const isScene = i < layerCount && layers[i] && layers[i].type === 'scene';
      gl.uniform1f(this._getCompLoc('flipH' + i), isScene && layers[i].sceneFlipH ? 1.0 : 0.0);
      gl.uniform1f(this._getCompLoc('flipV' + i), isScene && layers[i].sceneFlipV ? 1.0 : 0.0);
    }

    // Overlay transform uniforms (layer 3)
    const olay = (layerCount > 3 && layers[3]) ? layers[3] : null;
    gl.uniform2f(this._getCompLoc('overlayTR'), olay ? (olay._tx || 0) : 0, olay ? (olay._ty || 0) : 0);
    gl.uniform1f(this._getCompLoc('overlayScale'), olay ? (olay._scale || 1) : 1);
    gl.uniform1f(this._getCompLoc('overlayRot'), olay ? (olay._rotate || 0) : 0);
    gl.uniform1f(this._getCompLoc('overlayImgAspect'), olay ? (olay._imgAspect || 1.778) : 1.778);

    // Morph uniforms
    gl.uniform1f(this._getCompLoc('morphWidth'), morphOpts ? morphOpts.width : 1.0);
    gl.uniform1f(this._getCompLoc('textureScale'), morphOpts ? morphOpts.scale : 1.0);

    // Background uniforms (use texture unit 4 now that we have 4 layers)
    const bgModeMap = { none: 0, transparent: 1, color: 2, image: 3, video: 3, shader: 3, webcam: 3, ndi: 3 };
    const bgM = bgState ? (bgModeMap[bgState.mode] || 0) : 0;
    gl.uniform1f(this._getCompLoc('bgMode'), bgM);
    if (bgState && bgState.color) {
      gl.uniform3f(this._getCompLoc('bgColor'), bgState.color[0], bgState.color[1], bgState.color[2]);
    }
    gl.activeTexture(gl.TEXTURE4);
    gl.bindTexture(gl.TEXTURE_2D, (bgState && bgState.texture) ? bgState.texture : this._defaultTex);
    gl.uniform1i(this._getCompLoc('bgTexture'), 4);

    gl.bindBuffer(gl.ARRAY_BUFFER, this.posBuf);
    gl.enableVertexAttribArray(0);
    gl.vertexAttribPointer(0, 2, gl.FLOAT, false, 0, 0);
    gl.drawArrays(gl.TRIANGLES, 0, 3);

    this.frameIndex++;
  }
}

// ============================================================
// Three.js Scene Renderer
// ============================================================

class SceneRenderer {
  constructor(canvas) {
    this.canvas = canvas;
    this.renderer = null;
    this.sceneDef = null;
    this.playing = false;
    this.animId = null;
    this.startTime = performance.now();
    this.inputValues = {};
    this.inputs = [];
    this.media = []; // { name, type, threeTexture, threeModel }
    this._shaderBg = null; // { isfRenderer, texture } when shader bg active
  }

  load(sceneDef) {
    // Dispose old scene but keep the renderer (avoid creating multiple WebGL contexts)
    this.stop();
    if (this.sceneDef && this.sceneDef.dispose) this.sceneDef.dispose();
    this.sceneDef = null;
    this.inputs = [];
    this.inputValues = {};

    if (!this.renderer) {
      this.renderer = new THREE.WebGLRenderer({ canvas: this.canvas, antialias: true, preserveDrawingBuffer: true, powerPreference: 'high-performance', alpha: true, premultipliedAlpha: false });
      this.renderer.setPixelRatio(window.devicePixelRatio);
      this.renderer.setClearColor(0x000000, 0);
    }
    this.resize();
    this.sceneDef = sceneDef.create(this.renderer, this.canvas, this.media);
    this.inputs = sceneDef.INPUTS || [];
    this.startTime = performance.now();
  }

  render() {
    if (!this.sceneDef || !this.renderer) return;
    if (this.renderer.getContext().isContextLost()) return;
    // Update audio analysis (used by ISF bg shader and scene)
    if (this._isfGL) updateAudioUniforms(this._isfGL);
    // Drive ISF offscreen render and update texture before 3D render
    if (this._shaderBg) {
      this._shaderBg.isfRenderer.render();
      this._shaderBg.texture.needsUpdate = true;
    }
    const elapsed = (performance.now() - this.startTime) / 1000;
    this.sceneDef.update(elapsed, this.inputValues, this.media);
    this.renderer.render(this.sceneDef.scene, this.sceneDef.camera);
  }

  start() {
    if (this.playing && this.animId) return;
    this.playing = true;
    const loop = () => {
      if (!this.playing) return;
      this.render();
      this.animId = requestAnimationFrame(loop);
    };
    loop();
  }

  stop() {
    this.playing = false;
    if (this.animId) cancelAnimationFrame(this.animId);
    this.animId = null;
  }

  togglePlay() {
    if (this.playing) this.stop();
    else this.start();
    return this.playing;
  }

  resize() {
    if (!this.renderer) return;
    const parent = this.canvas.parentElement;
    const w = parent.clientWidth;
    const h = parent.clientHeight;
    this.renderer.setSize(w, h, false);
    this.canvas.style.width = w + 'px';
    this.canvas.style.height = h + 'px';
    if (this.sceneDef && this.sceneDef.resize) {
      this.sceneDef.resize(w, h);
    }
  }

  cleanup() {
    this.stop();
    if (this.sceneDef && this.sceneDef.dispose) {
      this.sceneDef.dispose();
    }
    if (this.renderer) {
      this.renderer.forceContextLoss();
      this.renderer.dispose();
      this.renderer = null;
    }
    this.sceneDef = null;
    this.inputs = [];
    this.inputValues = {};
  }

  resetTime() {
    this.startTime = performance.now();
  }
}

// makeDraggable removed — panels are now inline in sidebar

// ============================================================
// UI Controls Generator
// ============================================================

function generateControls(inputs, container, onChange) {
  container.innerHTML = '';
  if (!inputs || inputs.length === 0) {
    container.innerHTML = '<div class="no-params">No parameters</div>';
    return {};
  }

  // If this container is inside the text layer card, skip msg text inputs
  // (the prominent bar handles msg)
  const isTextLayer = container.closest && container.closest('[data-layer="text"]');
  if (isTextLayer) {
    inputs = inputs.filter(inp => !(inp.TYPE === 'text' && inp.NAME === 'msg'));
  }

  const values = {};
  let imageInputIdx = 0;

  inputs.forEach(inp => {
    const row = document.createElement('div');
    row.className = 'control-row';
    row.dataset.name = inp.NAME;

    const label = document.createElement('label');
    label.textContent = inp.LABEL || inp.NAME;
    row.appendChild(label);

    if (inp.TYPE === 'float') {
      const def = inp.DEFAULT != null ? inp.DEFAULT : 0.5;
      const min = inp.MIN != null ? inp.MIN : 0;
      const max = inp.MAX != null ? inp.MAX : 1;
      values[inp.NAME] = def;

      const range = document.createElement('input');
      range.type = 'range';
      range.min = min;
      range.max = max;
      range.step = (max - min) / 200;
      range.value = def;

      const valSpan = document.createElement('span');
      valSpan.className = 'val';
      valSpan.textContent = Number(def).toFixed(2);

      range.addEventListener('input', () => {
        const v = parseFloat(range.value);
        values[inp.NAME] = v;
        valSpan.textContent = v.toFixed(2);
        onChange(values);
      });

      row.appendChild(range);
      row.appendChild(valSpan);

      // MP map button for body-tracking binding
      const mpBtn = document.createElement('button');
      mpBtn.className = 'mp-map-btn';
      mpBtn.dataset.paramName = inp.NAME;
      mpBtn.title = 'Link to body tracking';
      mpBtn.innerHTML = '<svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="4.5" r="2"/><path d="M12 7v5m0 0l-4 6m4-6l4 6"/><path d="M7 11h10"/></svg>';
      mpBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        openMpPicker(mpBtn, inp.NAME, container);
      });
      row.appendChild(mpBtn);

    } else if (inp.TYPE === 'color') {
      const def = inp.DEFAULT || [1, 1, 1, 1];
      values[inp.NAME] = [...def];

      const hex = rgbToHex(def[0], def[1], def[2]);
      const picker = document.createElement('input');
      picker.type = 'color';
      picker.value = hex;

      picker.addEventListener('input', () => {
        const rgb = hexToRgb(picker.value);
        values[inp.NAME] = [rgb[0], rgb[1], rgb[2], def[3] || 1];
        onChange(values);
      });

      row.appendChild(picker);

    } else if (inp.TYPE === 'bool') {
      const def = inp.DEFAULT ? true : false;
      values[inp.NAME] = def;

      const cb = document.createElement('input');
      cb.type = 'checkbox';
      cb.checked = def;
      cb.style.accentColor = 'var(--accent)';

      cb.addEventListener('change', () => {
        values[inp.NAME] = cb.checked;
        onChange(values);
      });

      row.appendChild(cb);

    } else if (inp.TYPE === 'long') {
      const vals = inp.VALUES || [];
      const labels = inp.LABELS || vals.map(String);
      const def = inp.DEFAULT != null ? inp.DEFAULT : (vals[0] || 0);
      values[inp.NAME] = def;

      const select = document.createElement('select');
      for (let i = 0; i < vals.length; i++) {
        const opt = document.createElement('option');
        opt.value = vals[i];
        opt.textContent = labels[i] || vals[i];
        if (vals[i] === def) opt.selected = true;
        select.appendChild(opt);
      }

      select.addEventListener('change', () => {
        values[inp.NAME] = parseFloat(select.value);
        onChange(values);
      });

      row.appendChild(select);

    } else if (inp.TYPE === 'text') {
      const maxLen = inp.MAX_LENGTH || 12;
      const def = (inp.DEFAULT || '').toUpperCase();

      function charToCode(ch) {
        if (!ch || ch === ' ') return 26;
        const c = ch.toUpperCase().charCodeAt(0) - 65;
        return (c >= 0 && c <= 25) ? c : 26;
      }

      for (let i = 0; i < maxLen; i++) {
        values[inp.NAME + '_' + i] = charToCode(def[i]);
      }
      values[inp.NAME + '_len'] = def.replace(/\s+$/, '').length;

      const textInput = document.createElement('input');
      textInput.type = 'text';
      textInput.maxLength = maxLen;
      textInput.value = def;
      textInput.spellcheck = false;

      textInput.addEventListener('input', () => {
        const str = textInput.value.toUpperCase();
        for (let i = 0; i < maxLen; i++) {
          values[inp.NAME + '_' + i] = charToCode(str[i]);
        }
        values[inp.NAME + '_len'] = str.replace(/\s+$/, '').length;
        onChange(values);
      });

      row.appendChild(textInput);

      // Mic button — toggles speech recognition into this text field
      const SpeechRec = window.SpeechRecognition || window.webkitSpeechRecognition;
      if (SpeechRec) {
        const micBtn = document.createElement('button');
        micBtn.className = 'text-mic-btn';
        micBtn.textContent = '\u{1F3A4}';
        micBtn.title = 'Mic input';
        let micRec = null;
        let micActive = false;

        function startMicRec() {
          micRec = new SpeechRec();
          micRec.continuous = true;
          micRec.interimResults = true;
          micRec.onresult = (event) => {
            let interim = '';
            let final = '';
            for (let i = event.resultIndex; i < event.results.length; i++) {
              if (event.results[i].isFinal) final += event.results[i][0].transcript;
              else interim += event.results[i][0].transcript;
            }
            const raw = (final || interim).trim();
            if (!raw) return;
            let str = raw.toUpperCase();
            if (str.length > maxLen) {
              // Cut to last maxLen chars, then skip to next full word
              str = str.slice(-maxLen);
              const sp = str.indexOf(' ');
              if (sp > 0) str = str.slice(sp + 1);
            }
            textInput.value = str;
            for (let i = 0; i < maxLen; i++) {
              values[inp.NAME + '_' + i] = charToCode(str[i]);
            }
            values[inp.NAME + '_len'] = str.replace(/\s+$/, '').length;
            onChange(values);
          };
          micRec.onerror = (e) => {
            console.warn('Mic error:', e.error);
            if (e.error === 'not-allowed' || e.error === 'aborted') {
              micActive = false;
              micBtn.classList.remove('active');
            }
          };
          micRec.onend = () => {
            if (micActive) {
              // Create fresh instance — Chrome won't restart a used one reliably
              setTimeout(startMicRec, 300);
            }
          };
          micRec.start();
        }

        micBtn.addEventListener('click', () => {
          if (micActive && micRec) {
            micActive = false;
            micRec.stop();
            micRec = null;
            micBtn.classList.remove('active');
            return;
          }
          micActive = true;
          micBtn.classList.add('active');
          startMicRec();
        });
        row.appendChild(micBtn);
      }

    } else if (inp.TYPE === 'image') {
      values[inp.NAME] = null; // texture binding, not a scalar value

      // Create select (always, even if no media yet — it refreshes dynamically)
      const select = document.createElement('select');
      select.dataset.imageInput = inp.NAME;
      select.classList.add('image-input-select');

      function _populateImageSelect() {
        const prev = select.value;
        select.innerHTML = '';
        const noneOpt = document.createElement('option');
        noneOpt.value = '';
        noneOpt.textContent = '(none)';
        select.appendChild(noneOpt);
        const compatibleMedia = mediaInputs.filter(m => m.type === 'image' || m.type === 'video' || m.type === 'svg');
        compatibleMedia.forEach(m => {
          const opt = document.createElement('option');
          opt.value = m.id;
          opt.textContent = mediaTypeIcon(m.type) + ' ' + m.name;
          select.appendChild(opt);
        });
        // Restore previous selection if still valid, otherwise auto-select
        if (prev && compatibleMedia.find(m => String(m.id) === String(prev))) {
          select.value = prev;
        } else if (values[inp.NAME] && compatibleMedia.find(m => String(m.id) === String(values[inp.NAME]))) {
          select.value = values[inp.NAME];
        }
      }
      _populateImageSelect();

      // Auto-select on first build
      const compatibleMedia = mediaInputs.filter(m => m.type === 'image' || m.type === 'video' || m.type === 'svg');
      const autoIdx = Math.min(imageInputIdx, compatibleMedia.length - 1);
      if (compatibleMedia.length > 0) {
        select.value = compatibleMedia[autoIdx].id;
        values[inp.NAME] = compatibleMedia[autoIdx].id;
      }
      imageInputIdx++;

      select.addEventListener('change', () => {
        values[inp.NAME] = select.value || null;
        onChange(values);
      });

      // Register for live refresh when media list changes
      select._refreshOptions = _populateImageSelect;

      row.appendChild(select);

    } else if (inp.TYPE === 'point2D') {
      const def = inp.DEFAULT || [0, 0];
      const min = inp.MIN || [-1, -1];
      const max = inp.MAX || [1, 1];
      values[inp.NAME] = [...def];

      for (let axis = 0; axis < 2; axis++) {
        const range = document.createElement('input');
        range.type = 'range';
        range.min = min[axis];
        range.max = max[axis];
        range.step = (max[axis] - min[axis]) / 200;
        range.value = def[axis];
        range.style.flex = '1';

        range.addEventListener('input', () => {
          values[inp.NAME][axis] = parseFloat(range.value);
          onChange(values);
        });

        row.appendChild(range);
      }
    }

    container.appendChild(row);
  });

  return values;
}

function rgbToHex(r, g, b) {
  const c = (v) => Math.round(Math.max(0, Math.min(1, v)) * 255).toString(16).padStart(2, '0');
  return '#' + c(r) + c(g) + c(b);
}

function hexToRgb(hex) {
  const r = parseInt(hex.slice(1, 3), 16) / 255;
  const g = parseInt(hex.slice(3, 5), 16) / 255;
  const b = parseInt(hex.slice(5, 7), 16) / 255;
  return [r, g, b];
}

// ============================================================
// MediaPipe Manager
// ============================================================

class MediaPipeManager {
  constructor(gl) {
    this.gl = gl;
    this.active = false;
    this.modes = { hand: false, face: false, pose: false, segment: false };
    this.handLandmarker = null;
    this.faceLandmarker = null;
    this.poseLandmarker = null;
    this.imageSegmenter = null;
    this.handTex = null;
    this.faceTex = null;
    this.poseTex = null;
    this.segTex = null;
    this.handCount = 0;
    this.handPos = [0, 0, 0];
    this.isPinching = false;
    this.pinchPos = [0, 0];
    this._pinchStartPos = null;
    this._pinchAccumX = 0;
    this._pinchAccumY = 0;
    this._lastPinchPos = null;
    this._lastHandLandmarks2 = null;
    this._frameCount = 0;
    this._lastTimestamp = 0;
  }

  async init(modes) {
    if (!window.MediaPipeVision) await loadMediaPipeVision();
    if (!window.MediaPipeVision) throw new Error('MediaPipe failed to load');
    const { FilesetResolver, HandLandmarker, FaceLandmarker, PoseLandmarker, ImageSegmenter } = window.MediaPipeVision;
    const wasmPath = 'https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.32/wasm';
    const vision = await FilesetResolver.forVisionTasks(wasmPath);

    this.modes = { ...this.modes, ...modes };

    if (this.modes.hand) {
      this.handLandmarker = await HandLandmarker.createFromOptions(vision, {
        baseOptions: { modelAssetPath: 'https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task', delegate: 'GPU' },
        runningMode: 'VIDEO', numHands: 2
      });
      this.handTex = this._createDataTex(42, 1);
    }
    if (this.modes.face) {
      this.faceLandmarker = await FaceLandmarker.createFromOptions(vision, {
        baseOptions: { modelAssetPath: 'https://storage.googleapis.com/mediapipe-models/face_landmarker/face_landmarker/float16/1/face_landmarker.task', delegate: 'GPU' },
        runningMode: 'VIDEO', numFaces: 1
      });
      this.faceTex = this._createDataTex(478, 1);
    }
    if (this.modes.pose) {
      this.poseLandmarker = await PoseLandmarker.createFromOptions(vision, {
        baseOptions: { modelAssetPath: 'https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task', delegate: 'GPU' },
        runningMode: 'VIDEO'
      });
      this.poseTex = this._createDataTex(33, 1);
    }
    if (this.modes.segment) {
      this.imageSegmenter = await ImageSegmenter.createFromOptions(vision, {
        baseOptions: { modelAssetPath: 'https://storage.googleapis.com/mediapipe-models/image_segmenter/selfie_segmenter/float16/latest/selfie_segmenter.tflite', delegate: 'GPU' },
        runningMode: 'VIDEO', outputCategoryMask: false, outputConfidenceMasks: true
      });
    }
    this.active = true;
  }

  _createDataTex(w, h) {
    const gl = this.gl;
    const tex = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, tex);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, w, h, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    return tex;
  }

  // Rebuild GL textures after context restore
  reinitTextures() {
    if (this.modes.hand && this.handLandmarker) this.handTex = this._createDataTex(42, 1);
    if (this.modes.face && this.faceLandmarker) this.faceTex = this._createDataTex(478, 1);
    if (this.modes.pose && this.poseLandmarker) this.poseTex = this._createDataTex(33, 1);
    // segTex is created on-demand per frame, no persistent texture to rebuild
  }

  detect(video, timestamp) {
    if (!this.active || !video || video.readyState < 2) return;
    // Throttle to ~30fps (every 2nd frame at 60fps)
    this._frameCount++;
    if (this._frameCount % 2 !== 0) return;
    if (timestamp <= this._lastTimestamp) timestamp = this._lastTimestamp + 1;
    this._lastTimestamp = timestamp;

    const gl = this.gl;

    if (this.handLandmarker) {
      const result = this.handLandmarker.detectForVideo(video, timestamp);
      this.handCount = result.landmarks ? result.landmarks.length : 0;
      if (this.handCount > 0) {
        const lm = result.landmarks[0][9]; // middle finger MCP as hand center
        this.handPos = [lm.x, 1.0 - lm.y, lm.z];

        // Pinch detection: distance between thumb tip (4) and index tip (8)
        const thumb = result.landmarks[0][4];
        const index = result.landmarks[0][8];
        const dx = thumb.x - index.x;
        const dy = thumb.y - index.y;
        const dz = thumb.z - index.z;
        const pinchDist = Math.sqrt(dx * dx + dy * dy + dz * dz);
        const wasPinching = this.isPinching;
        this.isPinching = pinchDist < 0.05; // threshold ~5% of frame
        this.pinchPos = [(thumb.x + index.x) / 2, 1.0 - (thumb.y + index.y) / 2];

        if (this.isPinching && !wasPinching) {
          this._pinchStartPos = [...this.pinchPos];
          this._pinchAccumX = 0;
          this._pinchAccumY = 0;
        }
        if (this.isPinching && this._pinchStartPos) {
          this._pinchAccumX += (this.pinchPos[0] - (this._lastPinchPos || this.pinchPos)[0]) * Math.PI * 4;
          this._pinchAccumY += (this.pinchPos[1] - (this._lastPinchPos || this.pinchPos)[1]) * Math.PI * 4;
        }
        this._lastPinchPos = [...this.pinchPos];

        // Store raw landmarks for binding resolution
        this._lastHandLandmarks = result.landmarks[0].map(p => ({ x: p.x, y: 1.0 - p.y, z: p.z }));
        // Store second hand landmarks for two-hand gesture processing
        this._lastHandLandmarks2 = result.landmarks.length >= 2
          ? result.landmarks[1].map(p => ({ x: p.x, y: 1.0 - p.y, z: p.z }))
          : null;

        // Pack all landmarks into RGBA texture
        const data = new Uint8Array(42 * 4);
        for (let h = 0; h < Math.min(2, result.landmarks.length); h++) {
          for (let i = 0; i < 21; i++) {
            const idx = (h * 21 + i) * 4;
            const p = result.landmarks[h][i];
            data[idx] = Math.round(p.x * 255);
            data[idx + 1] = Math.round((1.0 - p.y) * 255);
            data[idx + 2] = Math.round((p.z + 0.5) * 255);
            data[idx + 3] = 255;
          }
        }
        gl.bindTexture(gl.TEXTURE_2D, this.handTex);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 42, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, data);
      } else {
        this.handPos = [0, 0, 0];
        this.isPinching = false;
        this._lastHandLandmarks2 = null;
      }
    }

    if (this.faceLandmarker) {
      const result = this.faceLandmarker.detectForVideo(video, timestamp);
      if (result.faceLandmarks && result.faceLandmarks.length > 0) {
        this._lastFaceLandmarks = result.faceLandmarks[0].map(p => ({ x: p.x, y: 1.0 - p.y, z: p.z }));
        const data = new Uint8Array(478 * 4);
        for (let i = 0; i < Math.min(478, result.faceLandmarks[0].length); i++) {
          const p = result.faceLandmarks[0][i];
          data[i * 4] = Math.round(p.x * 255);
          data[i * 4 + 1] = Math.round((1.0 - p.y) * 255);
          data[i * 4 + 2] = Math.round((p.z + 0.5) * 255);
          data[i * 4 + 3] = 255;
        }
        gl.bindTexture(gl.TEXTURE_2D, this.faceTex);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 478, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, data);
      }
    }

    if (this.poseLandmarker) {
      const result = this.poseLandmarker.detectForVideo(video, timestamp);
      if (result.landmarks && result.landmarks.length > 0) {
        this._lastPoseLandmarks = result.landmarks[0].map(p => ({ x: p.x, y: 1.0 - p.y, z: p.z }));
        const data = new Uint8Array(33 * 4);
        for (let i = 0; i < 33; i++) {
          const p = result.landmarks[0][i];
          data[i * 4] = Math.round(p.x * 255);
          data[i * 4 + 1] = Math.round((1.0 - p.y) * 255);
          data[i * 4 + 2] = Math.round((p.z + 0.5) * 255);
          data[i * 4 + 3] = Math.round((p.visibility || 0) * 255);
        }
        gl.bindTexture(gl.TEXTURE_2D, this.poseTex);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 33, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, data);
      }
    }

    if (this.imageSegmenter) {
      this.imageSegmenter.segmentForVideo(video, timestamp, (result) => {
        if (result.confidenceMasks && result.confidenceMasks.length > 0) {
          const mask = result.confidenceMasks[0];
          const w = mask.width, h = mask.height;
          const data = new Uint8Array(w * h * 4);
          const raw = mask.getAsFloat32Array();
          for (let i = 0; i < raw.length; i++) {
            const v = Math.round(raw[i] * 255);
            data[i * 4] = data[i * 4 + 1] = data[i * 4 + 2] = v;
            data[i * 4 + 3] = 255;
          }
          if (!this.segTex) this.segTex = this._createDataTex(w, h);
          gl.bindTexture(gl.TEXTURE_2D, this.segTex);
          gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, w, h, 0, gl.RGBA, gl.UNSIGNED_BYTE, data);
        }
      });
    }
  }

  getLabel() {
    const parts = [];
    if (this.modes.hand) parts.push('hand');
    if (this.modes.face) parts.push('face');
    if (this.modes.pose) parts.push('pose');
    if (this.modes.segment) parts.push('segment');
    return 'MediaPipe (' + parts.join('+') + ')';
  }

  dispose() {
    if (this.handLandmarker) this.handLandmarker.close();
    if (this.faceLandmarker) this.faceLandmarker.close();
    if (this.poseLandmarker) this.poseLandmarker.close();
    if (this.imageSegmenter) this.imageSegmenter.close();
    this.active = false;
  }
}

// ============================================================
// MediaPipe Body Part Registry & Binding Resolution
// ============================================================

const MP_BODY_PARTS = {
  hand: [
    { name: 'Wrist', index: 0 }, { name: 'Thumb Tip', index: 4 },
    { name: 'Index Tip', index: 8 }, { name: 'Middle Tip', index: 12 },
    { name: 'Ring Tip', index: 16 }, { name: 'Pinky Tip', index: 20 },
    { name: 'Palm Center', index: 9 },
  ],
  face: [
    { name: 'Nose Tip', index: 1 }, { name: 'Left Eye', index: 33 },
    { name: 'Right Eye', index: 263 }, { name: 'Mouth Center', index: 13 },
    { name: 'Chin', index: 152 }, { name: 'Forehead', index: 10 },
    { name: 'Left Ear', index: 234 }, { name: 'Right Ear', index: 454 },
    { name: 'Left Eyebrow', index: 70 }, { name: 'Right Eyebrow', index: 300 },
    { name: 'Upper Lip', index: 0 }, { name: 'Lower Lip', index: 17 },
    { name: 'Left Cheek', index: 123 }, { name: 'Right Cheek', index: 352 },
    { name: 'Nose Bridge', index: 6 },
  ],
  pose: [
    { name: 'Nose', index: 0 }, { name: 'Left Shoulder', index: 11 },
    { name: 'Right Shoulder', index: 12 }, { name: 'Left Elbow', index: 13 },
    { name: 'Right Elbow', index: 14 }, { name: 'Left Wrist', index: 15 },
    { name: 'Right Wrist', index: 16 }, { name: 'Left Hip', index: 23 },
    { name: 'Right Hip', index: 24 }, { name: 'Left Knee', index: 25 },
    { name: 'Right Knee', index: 26 }, { name: 'Left Ankle', index: 27 },
    { name: 'Right Ankle', index: 28 },
  ],
};

// Derived signals registry — organized by group, used by live signals UI and picker
const DERIVED_SIGNALS = {
  hand: [
    { name: 'Pinch Dist', key: 'pinchDist' },
    { name: 'Grip Strength', key: 'gripStrength' },
    { name: 'Finger Spread', key: 'fingerSpread' },
    { name: 'Hand Angle', key: 'handAngle' },
    { name: 'Thumb Curl', key: 'thumbCurl' },
    { name: 'Index Curl', key: 'indexCurl' },
    { name: 'Middle Curl', key: 'middleCurl' },
    { name: 'Ring Curl', key: 'ringCurl' },
    { name: 'Pinky Curl', key: 'pinkyCurl' },
  ],
  face: [
    { name: 'Head Yaw', key: 'headYaw' },
    { name: 'Head Pitch', key: 'headPitch' },
    { name: 'Head Roll', key: 'headRoll' },
    { name: 'Mouth Open', key: 'mouthOpen' },
    { name: 'Left Blink', key: 'leftBlink' },
    { name: 'Right Blink', key: 'rightBlink' },
    { name: 'Eyebrow Raise', key: 'eyebrowRaise' },
  ],
  pose: [
    { name: 'Body Lean', key: 'bodyLean' },
    { name: 'Left Arm Angle', key: 'leftArmAngle' },
    { name: 'Right Arm Angle', key: 'rightArmAngle' },
    { name: 'Shoulder Width', key: 'shoulderWidth' },
  ],
};

/**
 * Resolve MediaPipe bindings for a layer: body part position → parameter value.
 * Supports both landmark bindings { group, landmarkIndex, param, axis, min, max }
 * and derived signal bindings { source: 'derived', signalKey, param, min, max }
 */
function resolveBindings(layer, mediaPipeMgr) {
  if (!layer.mpBindings || !layer.mpBindings.length) return;
  for (const b of layer.mpBindings) {
    // Derived signal binding
    if (b.source === 'derived') {
      const v = gestureProcessor.derived[b.signalKey];
      if (v != null) {
        layer.inputValues[b.param] = b.min + v * (b.max - b.min);
      }
      continue;
    }
    // Landmark binding
    let pos = null;
    if (b.group === 'hand' && mediaPipeMgr.handCount > 0) {
      if (mediaPipeMgr._lastHandLandmarks && mediaPipeMgr._lastHandLandmarks[b.landmarkIndex]) {
        pos = mediaPipeMgr._lastHandLandmarks[b.landmarkIndex];
      } else if (b.landmarkIndex === 9) {
        pos = { x: mediaPipeMgr.handPos[0], y: mediaPipeMgr.handPos[1], z: mediaPipeMgr.handPos[2] };
      }
    } else if (b.group === 'face' && mediaPipeMgr._lastFaceLandmarks) {
      pos = mediaPipeMgr._lastFaceLandmarks[b.landmarkIndex];
    } else if (b.group === 'pose' && mediaPipeMgr._lastPoseLandmarks) {
      pos = mediaPipeMgr._lastPoseLandmarks[b.landmarkIndex];
    }
    if (!pos) continue;
    let v = (b.axis === 'y') ? pos.y : (b.axis === 'z') ? (pos.z || 0) : pos.x;
    layer.inputValues[b.param] = b.min + v * (b.max - b.min);
  }
}

// ============================================================
// NDI — state and helpers (Worker-based capture, matching grandi pattern)
// ============================================================

let ndiReceiveEntry = null;
let ndiReceiveCanvas = null;
let ndiReceiveCtx = null;
let ndiSendingActive = false;
let ndiSendAnimId = null;
let ndiSendFrameCount = 0;
let ndiSendWorker = null;
let ndiWsMsgId = 0;
const ndiPending = new Map();
const FRAME_TYPE_NDI_VIDEO = 0x01;
const FRAME_TYPE_CANVAS = 0x02;

function ndiRequest(ws, action, params = {}) {
  return new Promise((resolve, reject) => {
    if (!ws || ws.readyState !== WebSocket.OPEN) {
      return reject(new Error('WebSocket not connected'));
    }
    const id = --ndiWsMsgId;
    const timer = setTimeout(() => {
      ndiPending.delete(id);
      reject(new Error('NDI request timeout'));
    }, 5000);
    ndiPending.set(id, { resolve, reject, timer });
    ws.send(JSON.stringify({ id, action, params }));
  });
}

function handleNdiVideoFrame(data, glRef) {
  if (!ndiReceiveEntry) return;
  const view = new DataView(data);
  const width = view.getUint32(1, true);
  const height = view.getUint32(5, true);
  const pixels = new Uint8ClampedArray(data, 9);

  if (!ndiReceiveCanvas || ndiReceiveCanvas.width !== width || ndiReceiveCanvas.height !== height) {
    ndiReceiveCanvas = document.createElement('canvas');
    ndiReceiveCanvas.width = width;
    ndiReceiveCanvas.height = height;
    ndiReceiveCtx = ndiReceiveCanvas.getContext('2d');
  }

  const imageData = new ImageData(pixels, width, height);
  ndiReceiveCtx.putImageData(imageData, 0, 0);

  // Upload to GL texture — use UNPACK_FLIP_Y so NDI frames orient correctly
  if (ndiReceiveEntry.glTexture && glRef) {
    glRef.pixelStorei(glRef.UNPACK_FLIP_Y_WEBGL, true);
    glRef.bindTexture(glRef.TEXTURE_2D, ndiReceiveEntry.glTexture);
    glRef.texImage2D(glRef.TEXTURE_2D, 0, glRef.RGBA, glRef.RGBA, glRef.UNSIGNED_BYTE, ndiReceiveCanvas);
    glRef.pixelStorei(glRef.UNPACK_FLIP_Y_WEBGL, false);
  }

  if (ndiReceiveEntry.threeTexture) {
    ndiReceiveEntry.threeTexture.image = ndiReceiveCanvas;
    ndiReceiveEntry.threeTexture.needsUpdate = true;
  }
}

function createNdiWorker() {
  const code = `
    let offscreen = null;
    let ctx = null;
    self.onmessage = (e) => {
      const { bitmap, width, height } = e.data;
      if (!offscreen || offscreen.width !== width || offscreen.height !== height) {
        offscreen = new OffscreenCanvas(width, height);
        ctx = offscreen.getContext('2d', { alpha: false });
      }
      ctx.drawImage(bitmap, 0, 0, width, height);
      const imageData = ctx.getImageData(0, 0, width, height);
      bitmap.close();
      const msg = new Uint8Array(9 + imageData.data.length);
      const view = new DataView(msg.buffer, 0, 9);
      view.setUint8(0, 0x02);
      view.setUint32(1, width, true);
      view.setUint32(5, height, true);
      msg.set(imageData.data, 9);
      self.postMessage(msg.buffer, [msg.buffer]);
    };
  `;
  const blob = new Blob([code], { type: 'application/javascript' });
  return new Worker(URL.createObjectURL(blob));
}

function startNdiSend(ws, canvasEl) {
  if (ndiSendingActive) return;
  ndiSendingActive = true;
  document.getElementById('ndi-indicator')?.classList.add('active');
  ndiSendFrameCount = 0;
  const NDI_W = 960, NDI_H = 540;
  const worker = createNdiWorker();
  ndiSendWorker = worker;
  worker.onmessage = (e) => {
    if (!ndiSendingActive) return;
    if (!ws || ws.readyState !== WebSocket.OPEN) return;
    if (ws.bufferedAmount > 4 * 1024 * 1024) return;
    ws.send(e.data);
    ndiSendFrameCount++;
  };
  let lastCapture = 0;
  let pending = false;
  function captureLoop(timestamp) {
    if (!ndiSendingActive) return;
    ndiSendAnimId = requestAnimationFrame(captureLoop);
    if (timestamp - lastCapture < 33) return;
    lastCapture = timestamp;
    if (pending) return;
    pending = true;
    createImageBitmap(canvasEl, { resizeWidth: NDI_W, resizeHeight: NDI_H })
      .then(bitmap => {
        pending = false;
        if (!ndiSendingActive) { bitmap.close(); return; }
        worker.postMessage({ bitmap, width: NDI_W, height: NDI_H }, [bitmap]);
      })
      .catch(() => { pending = false; });
  }
  ndiSendAnimId = requestAnimationFrame(captureLoop);
}

function stopNdiSend() {
  ndiSendingActive = false;
  document.getElementById('ndi-indicator')?.classList.remove('active');
  if (ndiSendAnimId) { cancelAnimationFrame(ndiSendAnimId); ndiSendAnimId = null; }
  if (ndiSendWorker) { ndiSendWorker.terminate(); ndiSendWorker = null; }
}


// ============================================================
// App Init
// ============================================================

(async function init() {
  const _dbg = document.getElementById('debug-overlay');
  const _dbgLines = [];
  function dbg(msg) {
    console.log(msg);
    _dbgLines.push(msg);
    if (_dbg) {
      _dbg.textContent = _dbgLines.slice(-20).join('\n');
      if (window.innerWidth <= 768) _dbg.style.display = ''; // show debug on mobile
    }
  }
  dbg('init: starting...');
  const glCanvas = document.getElementById('gl-canvas');
  const threeCanvas = document.getElementById('three-canvas');
  dbg('init: getting WebGL context...');
  const gl = await _getWebGLWithRetry(glCanvas, 5, dbg);
  if (!gl) {
    dbg('FAILED: no WebGL after retries');
    const bar = document.getElementById('error-bar');
    if (bar) {
      bar.innerHTML = 'WebGL unavailable — close other browser tabs, then <a href="#" onclick="location.reload();return false" style="color:var(--accent);text-decoration:underline">click here to retry</a>';
      bar.classList.add('show');
    }
    return;
  }
  dbg('init: WebGL OK, creating Renderer...');
  const isfRenderer = new Renderer(glCanvas, gl);
  dbg('init: Renderer OK');
  const sceneRenderer = new SceneRenderer(threeCanvas);
  sceneRenderer._isfGL = isfRenderer.gl;
  const errorBar = document.getElementById('error-bar');

  // Three.js canvas always renders offscreen — gl-canvas is the compositor output
  threeCanvas.style.display = 'none';
  glCanvas.style.display = 'block';

  // MediaPipe manager
  const mediaPipeMgr = new MediaPipeManager(isfRenderer.gl);
  const gestureProcessor = new GestureProcessor();
  let _ndiWs = null; // WS reference for NDI

  // ===== LAYER DATA STRUCTURE =====
  const layers = [
    { id: 'shader', type: 'shader', visible: false, opacity: 1.0, blendMode: 'normal',
      program: null, uniformLocs: {}, fbo: isfRenderer.createFBO(1920, 1080), textures: {},
      inputs: [], inputValues: {}, transparentBg: false, manifestEntry: null },
    { id: 'scene', type: 'scene', visible: false, opacity: 1.0, blendMode: 'normal',
      program: null, uniformLocs: {}, fbo: null, textures: {},
      inputs: [], inputValues: {}, transparentBg: false, manifestEntry: null,
      sceneFlipH: false, sceneFlipV: true },
    { id: 'text', type: 'shader', visible: true, opacity: 1.0, blendMode: 'normal',
      program: null, uniformLocs: {}, fbo: isfRenderer.createFBO(1920, 1080), textures: {},
      inputs: [], inputValues: {}, transparentBg: true, manifestEntry: null },
    { id: 'overlay', type: 'overlay', visible: false, opacity: 1.0, blendMode: 'normal',
      program: null, uniformLocs: {}, fbo: null, textures: {},
      inputs: [], inputValues: {}, transparentBg: true, manifestEntry: null },
  ];

  // Scene layer gets a plain texture (uploaded from Three.js canvas each frame)
  function createSceneTexture() {
    const gl = isfRenderer.gl;
    const tex = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, tex);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, new Uint8Array([0,0,0,255]));
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    return tex;
  }
  let sceneTexture = createSceneTexture();

  // Init compositor
  dbg('init: compiling compositor...');
  const compResult = isfRenderer.initCompositor();
  dbg('compositor: ' + (compResult.ok ? 'OK' : 'FAILED — ' + (compResult.errors || 'unknown')));

  // ===== WEBGL CONTEXT LOSS RECOVERY =====
  let _contextLost = false;

  glCanvas.addEventListener('webglcontextlost', (e) => {
    e.preventDefault(); // Tell browser we want to restore
    _contextLost = true;
    _blitProg = null; _blitTexLoc = null; // Reset crossfade blit program
    layers.forEach(l => { l._transitionTex = null; l._transitionStart = null; l._pendingCompile = null; });
    console.warn('WebGL context lost — waiting for restore...');
    errorBar.textContent = 'WebGL context lost — recovering...';
    errorBar.classList.add('show');
  });

  function _doContextRestore() {
    const gl = isfRenderer.gl;
    if (gl.isContextLost()) {
      console.warn('Context still lost during restore — retrying in 500ms');
      setTimeout(_doContextRestore, 500);
      return;
    }

    console.log('WebGL context restored — reinitializing...');

    // 1. Rebuild core GL resources (geometry buffer, default texture)
    isfRenderer.reinitGL();
    isfRenderer.initCompositor();

    // 2. Recreate scene texture (for Three.js → compositor upload)
    sceneTexture = createSceneTexture();

    // 3. Recreate FBOs for all layers
    layers.forEach(layer => {
      if ((layer.type === 'shader' || layer.type === 'overlay') && layer.fbo) {
        layer.fbo = isfRenderer.createFBO(1920, 1080);
      }
      if (layer.passes) {
        layer.passes.forEach(p => {
          if (p.ppFBO) {
            p.ppFBO = isfRenderer.createPingPongFBO(p.width || 1920, p.height || 1080);
          }
        });
      }
      layer.program = null;
      layer.uniformLocs = {};
      layer.textures = {};
    });

    // 4. Recompile all shader layers from stored source
    let allOk = true;
    layers.forEach(layer => {
      if (layer.type === 'shader' && layer._isfSource) {
        const result = compileToLayer(layer.id, layer._isfSource);
        if (!result.ok) {
          console.warn('Context restore: failed to recompile', layer.id, result.errors);
          allOk = false;
        }
      }
    });

    // 5. Rebuild font atlas GL texture
    _fontAtlasGLTexture = null;
    _fontAtlasLastKey = '';

    // 6. Rebuild MediaPipe data textures
    if (mediaPipeMgr.active) {
      mediaPipeMgr.reinitTextures();
    }

    // 7. Rebuild media input GL textures
    mediaInputs.forEach(m => {
      if (m.element) {
        try { m.glTexture = createGLTexture(gl, m.element); } catch (e) {}
      }
    });
    autoBindTextures();

    // 8. Rebuild background texture
    if (canvasBg.mode !== 'none' && canvasBg.mode !== 'shader') {
      canvasBg.texture = createBgTexture();
      if (canvasBg.imageEl) {
        try {
          gl.bindTexture(gl.TEXTURE_2D, canvasBg.texture);
          gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, canvasBg.imageEl);
        } catch (e) {}
      }
    } else if (canvasBg.mode === 'shader' && canvasBg.shaderLayer) {
      canvasBg.shaderFBO = isfRenderer.createFBO(1920, 1080);
      canvasBg.texture = canvasBg.shaderFBO.texture;
      canvasBg.shaderLayer.fbo = canvasBg.shaderFBO;
      canvasBg.shaderLayer.program = null;
      canvasBg.shaderLayer.uniformLocs = {};
      if (canvasBg.shaderLayer._isfSource) {
        const { frag } = buildFragmentShader(canvasBg.shaderLayer._isfSource);
        isfRenderer.compileForLayer(canvasBg.shaderLayer, VERT_SHADER, frag);
      }
    }

    // Only resume rendering once everything is rebuilt
    _contextLost = false;
    errorBar.textContent = '';
    errorBar.classList.remove('show');
    console.log('WebGL context recovery complete');
  }

  glCanvas.addEventListener('webglcontextrestored', () => {
    // Defer restore to next frame to let the GL context fully stabilize
    requestAnimationFrame(() => _doContextRestore());
  });

  // Three.js scene canvas context loss handling
  threeCanvas.addEventListener('webglcontextlost', (e) => {
    e.preventDefault();
    console.warn('Three.js WebGL context lost');
  });
  threeCanvas.addEventListener('webglcontextrestored', () => {
    console.log('Three.js WebGL context restored — reloading scene');
    const sceneLayer = layers.find(l => l.type === 'scene');
    if (sceneLayer && sceneLayer._sceneDef) {
      try {
        sceneRenderer.load(sceneLayer._sceneDef);
        sceneRenderer.inputValues = sceneLayer.inputValues || {};
      } catch (e) {
        console.warn('Three.js scene restore failed:', e);
      }
    }
  });

  // ===== CANVAS PANEL STATE =====
  let projectionWindow = null;
  let projectionCanvas = null;
  let projectionCtx = null;

  const canvasBg = {
    mode: 'none',      // 'none'|'transparent'|'color'|'image'|'video'|'shader'|'webcam'
    color: [0, 0, 0],  // RGB 0-1
    texture: null,      // GL texture for image/video/webcam
    imageEl: null,      // <img> element for image bg (kept for context restore)
    videoEl: null,      // <video> element if video/webcam
    shaderFBO: null,    // FBO for shader background
    shaderLayer: null,  // pseudo-layer object for ISF rendering
  };

  let focusedLayerId = 'shader'; // which layer the code editor targets

  function getLayer(id) { return layers.find(l => l.id === id); }
  function getFocusedLayer() { return getLayer(focusedLayerId); }

  // CodeMirror editor
  const editor = CodeMirror.fromTextArea(document.getElementById('code'), {
    mode: 'x-shader/x-fragment',
    theme: 'material-darker',
    lineNumbers: true,
    matchBrackets: true,
    autoCloseBrackets: true,
    tabSize: 4,
    indentWithTabs: true
  });

  let lastErrors = null;

  // === Shader transition: crossfade utilities ===
  const TRANSITION_MS = 400;
  let _blitProg = null, _blitTexLoc = null;

  function _getBlitProg(gl) {
    if (_blitProg) return _blitProg;
    const vs = gl.createShader(gl.VERTEX_SHADER);
    gl.shaderSource(vs, 'attribute vec2 position;varying vec2 vUv;void main(){vUv=position*0.5+0.5;gl_Position=vec4(position,0.,1.);}');
    gl.compileShader(vs);
    const fs = gl.createShader(gl.FRAGMENT_SHADER);
    gl.shaderSource(fs, 'precision mediump float;uniform sampler2D uTex;varying vec2 vUv;void main(){gl_FragColor=texture2D(uTex,vUv);}');
    gl.compileShader(fs);
    _blitProg = gl.createProgram();
    gl.attachShader(_blitProg, vs); gl.attachShader(_blitProg, fs);
    gl.bindAttribLocation(_blitProg, 0, 'position');
    gl.linkProgram(_blitProg);
    gl.deleteShader(vs); gl.deleteShader(fs);
    _blitTexLoc = gl.getUniformLocation(_blitProg, 'uTex');
    return _blitProg;
  }

  function _snapshotLayerFBO(gl, layer) {
    if (!layer.fbo) return;
    const w = layer.fbo.width, h = layer.fbo.height;
    if (!layer._transitionTex) {
      layer._transitionTex = gl.createTexture();
      gl.bindTexture(gl.TEXTURE_2D, layer._transitionTex);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, w, h, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
      layer._transitionTexSize = [w, h];
    }
    if (layer._transitionTexSize[0] !== w || layer._transitionTexSize[1] !== h) {
      gl.bindTexture(gl.TEXTURE_2D, layer._transitionTex);
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, w, h, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
      layer._transitionTexSize = [w, h];
    }
    gl.bindFramebuffer(gl.FRAMEBUFFER, layer.fbo.fbo);
    gl.bindTexture(gl.TEXTURE_2D, layer._transitionTex);
    gl.copyTexSubImage2D(gl.TEXTURE_2D, 0, 0, 0, 0, 0, w, h);
    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
  }

  function _blendTransitionSnapshot(gl, layer, alpha) {
    if (!layer._transitionTex || !layer.fbo || alpha <= 0) return;
    const prog = _getBlitProg(gl);
    gl.bindFramebuffer(gl.FRAMEBUFFER, layer.fbo.fbo);
    gl.viewport(0, 0, layer.fbo.width, layer.fbo.height);
    gl.enable(gl.BLEND);
    gl.blendColor(0, 0, 0, alpha);
    gl.blendFuncSeparate(gl.CONSTANT_ALPHA, gl.ONE_MINUS_CONSTANT_ALPHA,
                         gl.CONSTANT_ALPHA, gl.ONE_MINUS_CONSTANT_ALPHA);
    gl.useProgram(prog);
    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(gl.TEXTURE_2D, layer._transitionTex);
    gl.uniform1i(_blitTexLoc, 0);
    gl.bindBuffer(gl.ARRAY_BUFFER, isfRenderer.posBuf);
    gl.enableVertexAttribArray(0);
    gl.vertexAttribPointer(0, 2, gl.FLOAT, false, 0, 0);
    gl.drawArrays(gl.TRIANGLES, 0, 3);
    gl.disable(gl.BLEND);
    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
  }

  // --- Compile ISF shader into a specific layer ---
  function compileToLayer(layerId, source, _precompiledProg) {
    const layer = getLayer(layerId);
    if (!layer || layer.type !== 'shader') return { ok: false, errors: 'Not a shader layer' };

    // Store source for context-loss recovery
    layer._isfSource = source;

    const { frag, parsed, headerLineCount } = buildFragmentShader(source);
    isfRenderer._headerLines = headerLineCount;
    // Optimize: strip charData() if-chain since we always use font atlas texture
    const optimizedFrag = frag.replace(
      /vec2 charData\(int ch\)\s*\{[\s\S]*?\n\}/,
      'vec2 charData(int ch) { return vec2(0.0); }'
    );
    const result = _precompiledProg
      ? isfRenderer.compileForLayer(layer, null, null, _precompiledProg)
      : isfRenderer.compileForLayer(layer, VERT_SHADER, optimizedFrag);

    layer.inputs = parsed.inputs || [];
    layer._hasGestureInputs = layer.inputs.some(inp =>
      inp.NAME === 'rotationX' || inp.NAME === 'rotationY' || inp.NAME === 'shapeScale' ||
      inp.NAME === 'glow' || inp.NAME === 'morph' || inp.NAME === 'alive');

    if (result.ok) {
      const paramsContainer = document.querySelector(`.layer-params[data-layer="${layerId}"]`);
      if (paramsContainer) {
        // For text layer, skip msg from params UI (prominent bar handles it)
        // and move font/fontFamily to top
        const paramsInputs = layerId === 'text'
          ? layer.inputs
              .filter(inp => !(inp.TYPE === 'text' && inp.NAME === 'msg'))
              .sort((a, b) => {
                const af = (a.NAME === 'font' || a.NAME === 'fontFamily') ? 0 : 1;
                const bf = (b.NAME === 'font' || b.NAME === 'fontFamily') ? 0 : 1;
                return af - bf;
              })
          : layer.inputs;
        layer.inputValues = generateControls(paramsInputs, paramsContainer, (vals) => {
          layer.inputValues = vals;
          if ('fontFamily' in vals) setVarFontFamily(vals.fontFamily);
          if ('fontWeight' in vals) {
            _vfWeight = Math.max(100, Math.min(900, vals.fontWeight));
            setVarFontWeight(vals.fontWeight);
          }
          autoBindTextures(layerId);
        });
        syncMpLinkedState(paramsContainer, layerId);
        // For text layer, init msg values from prominent bar
        if (layerId === 'text') {
          const msgInp = layer.inputs.find(inp => inp.TYPE === 'text' && inp.NAME === 'msg');
          if (msgInp) {
            const maxLen = msgInp.MAX_LENGTH || 12;
            const bar = document.getElementById('text-msg-input');
            const def = (bar ? bar.value.trim() : (msgInp.DEFAULT || '').trim()).toUpperCase();
            function _c2c(ch) { if (!ch || ch === ' ') return 26; const c = ch.toUpperCase().charCodeAt(0) - 65; return (c >= 0 && c <= 25) ? c : 26; }
            for (let i = 0; i < maxLen; i++) layer.inputValues['msg_' + i] = _c2c(def[i]);
            layer.inputValues['msg_len'] = def.replace(/\s+$/, '').length;
            // Update bar maxLength to match shader
            if (bar) bar.maxLength = maxLen;
          }
        }
      }
      // Update shader dropdown selection
      const select = document.querySelector(`.layer-shader-select[data-layer="${layerId}"]`);
      if (select && layer.manifestEntry) select.value = layer.manifestEntry.file;
      autoBindTextures(layerId);

      // Multi-pass allocation from PASSES metadata
      if (layer.passes) {
        layer.passes.forEach(p => { if (p.ppFBO) isfRenderer.destroyPingPongFBO(p.ppFBO); });
        layer.passes = null;
      }
      const passes = parsed.meta && Array.isArray(parsed.meta.PASSES) ? parsed.meta.PASSES : null;
      if (passes && passes.length > 0) {
        layer.passes = passes.map(p => {
          if (!p.TARGET) {
            // Final output pass — renders to layer.fbo
            return { target: null, persistent: false, ppFBO: null, width: 1920, height: 1080 };
          }
          // Resolve WIDTH/HEIGHT with $WIDTH/N expression support
          let w = 1920, h = 1080;
          const resolveExpr = (expr, base) => {
            if (!expr) return base;
            if (typeof expr === 'number') return expr;
            const s = String(expr);
            const m = s.match(/^\$(?:WIDTH|HEIGHT)\s*\/\s*(\d+)$/);
            if (m) return Math.max(1, Math.round(base / parseInt(m[1])));
            return parseInt(s) || base;
          };
          w = resolveExpr(p.WIDTH, 1920);
          h = resolveExpr(p.HEIGHT, 1080);
          const persistent = !!(p.PERSISTENT || p.persistent);
          return {
            target: p.TARGET,
            persistent,
            ppFBO: isfRenderer.createPingPongFBO(w, h),
            width: w,
            height: h
          };
        });
      }
    }
    return result;
  }

  // --- Compile from editor into focused layer ---
  function compile() {
    const source = editor.getValue();
    const result = compileToLayer(focusedLayerId, source);
    if (result.ok) {
      lastErrors = null;
      errorBar.textContent = '';
      errorBar.classList.remove('show');
    } else {
      lastErrors = result.errors;
      errorBar.textContent = result.errors;
      errorBar.classList.add('show');
    }
    return result;
  }

  // --- Load shader source into editor + compile to focused layer ---
  function loadSource(source) {
    editor.setValue(source);
    compile();
  }

  // --- Load ISF shader file into a specific layer ---
  async function loadShaderToLayer(layerId, folder, file) {
    try {
      const r = await fetch((folder || 'shaders') + '/' + file);
      const src = await r.text();

      const layer = getLayer(layerId);

      // Async path: layer already has a running program — compile in background, crossfade
      if (layer && layer.program && layer.fbo) {
        // Cancel any existing pending compilation
        if (layer._pendingCompile) {
          layer._pendingCompile.handle.dispose();
          layer._pendingCompile = null;
        }

        // Parse ISF and build fragment shader (CPU-only, fast)
        const { frag, parsed, headerLineCount } = buildFragmentShader(src);
        const optimizedFrag = frag.replace(
          /vec2 charData\(int ch\)\s*\{[\s\S]*?\n\}/,
          'vec2 charData(int ch) { return vec2(0.0); }'
        );

        // Start async GPU compilation
        const handle = isfRenderer.startAsyncCompile(VERT_SHADER, optimizedFrag);
        if (handle) {
          layer._pendingCompile = { handle, source: src, parsed, headerLineCount, file };
          // Update editor immediately so user can see new source
          if (layerId === focusedLayerId) editor.setValue(src);
          return { ok: true, errors: null }; // compilation in progress
        }
        // Fallback if startAsyncCompile failed (context lost) — sync path below
      }

      // Sync path: no existing program (first load) or fallback
      const result = compileToLayer(layerId, src);
      if (layerId === focusedLayerId) editor.setValue(src);
      if (!result.ok) {
        errorBar.textContent = result.errors;
        errorBar.classList.add('show');
      } else {
        errorBar.textContent = '';
        errorBar.classList.remove('show');
        lastErrors = null;
      }
      return result;
    } catch (e) {
      errorBar.textContent = 'Failed to load: ' + file;
      errorBar.classList.add('show');
      return { ok: false, errors: e.message };
    }
  }

  // --- Load a Three.js scene into the scene layer ---
  async function loadScene(folder, file) {
    errorBar.textContent = '';
    errorBar.classList.remove('show');
    lastErrors = null;

    try {
      const r = await fetch((folder || 'scenes') + '/' + file);
      const src = await r.text();
      const sceneDef = new Function('THREE', 'return (' + src + ')(THREE)')(THREE);
      sceneRenderer.load(sceneDef);

      const sceneLayer = getLayer('scene');
      sceneLayer._sceneDef = sceneDef; // store for context restore
      sceneLayer.inputs = sceneDef.INPUTS || [];
      const paramsContainer = document.querySelector('.layer-params[data-layer="scene"]');
      if (paramsContainer) {
        sceneLayer.inputValues = generateControls(sceneLayer.inputs, paramsContainer, (vals) => {
          sceneRenderer.inputValues = vals;
          sceneLayer.inputValues = vals;
          autoBindTextures('scene');
        });
        syncMpLinkedState(paramsContainer, 'scene');
      }
      sceneRenderer.inputValues = sceneLayer.inputValues;
      autoBindTextures('scene');
      // Update shader dropdown selection
      const sceneSelect = document.querySelector('.layer-shader-select[data-layer="scene"]');
      if (sceneSelect && sceneLayer.manifestEntry) sceneSelect.value = sceneLayer.manifestEntry.file;

      sceneRenderer.resize();
      // Don't start scene's own loop — composition loop drives it
    } catch (e) {
      lastErrors = e.message;
      errorBar.textContent = 'Scene error: ' + e.message;
      errorBar.classList.add('show');
    }
  }

  // Expose full API for MCP server bridge
  window.shaderClaw = {
    loadSource,
    loadScene,
    compile,
    compileToLayer,
    getSource: () => editor.getValue(),
    getFocusedLayer: () => focusedLayerId,

    getErrors: () => lastErrors,

    getInputs: () => {
      const layer = getFocusedLayer();
      return (layer.inputs || []).map(inp => {
        const o = {
          name: inp.NAME,
          type: inp.TYPE,
          value: layer.inputValues[inp.NAME],
          min: inp.MIN,
          max: inp.MAX,
          default: inp.DEFAULT,
        };
        if (inp.VALUES) o.values = inp.VALUES;
        if (inp.LABELS) o.labels = inp.LABELS;
        if (inp.MAX_LENGTH) o.maxLength = inp.MAX_LENGTH;
        return o;
      });
    },

    setParameter: (name, value) => {
      const layer = getFocusedLayer();
      if (!(name in layer.inputValues)) return { ok: false, error: `Unknown parameter: ${name}` };
      layer.inputValues[name] = value;
      if (layer.id === 'scene') sceneRenderer.inputValues = layer.inputValues;
      window.shaderClaw.updateControlUI(name, value, layer.id);
      return { ok: true };
    },

    screenshot: () => {
      return glCanvas.toDataURL('image/png');
    },

    updateControlUI: (name, value, layerId) => {
      const container = document.querySelector(`.layer-params[data-layer="${layerId || focusedLayerId}"]`);
      if (!container) return;
      const rows = container.querySelectorAll('.control-row');
      for (const row of rows) {
        if (row.dataset.name !== name) continue;
        const range = row.querySelector('input[type="range"]');
        if (range && typeof value === 'number') {
          range.value = value;
          const valSpan = row.querySelector('.val');
          if (valSpan) valSpan.textContent = value.toFixed(2);
        }
        const color = row.querySelector('input[type="color"]');
        if (color && Array.isArray(value)) {
          const cr = Math.round(Math.max(0, Math.min(1, value[0])) * 255).toString(16).padStart(2, '0');
          const cg = Math.round(Math.max(0, Math.min(1, value[1])) * 255).toString(16).padStart(2, '0');
          const cb = Math.round(Math.max(0, Math.min(1, value[2])) * 255).toString(16).padStart(2, '0');
          color.value = '#' + cr + cg + cb;
        }
        const cb = row.querySelector('input[type="checkbox"]');
        if (cb && typeof value === 'boolean') cb.checked = value;
        const sel = row.querySelector('select');
        if (sel && typeof value === 'number') sel.value = value;
        break;
      }
    },

    addMedia: async (name, dataUrl) => {
      const entry = await addMediaFromDataUrl(name, dataUrl);
      if (!entry) return { ok: false, error: 'Failed to load media' };
      return { ok: true, id: entry.id, name: entry.name, type: entry.type };
    },

    getMedia: () => mediaInputs.map(m => ({ id: m.id, name: m.name, type: m.type })),

    removeMedia: (id) => {
      const exists = mediaInputs.find(m => m.id === id);
      if (!exists) return { ok: false, error: `Unknown media id: ${id}` };
      removeMedia(id);
      return { ok: true };
    },

    addWebcam: addMediaFromWebcam,

    // Layer API
    setLayerVisibility: (layerId, visible) => {
      const layer = getLayer(layerId);
      if (!layer) return { ok: false, error: 'Unknown layer' };
      layer.visible = visible;
      updateLayerCardUI(layerId);
      return { ok: true };
    },

    setLayerOpacity: (layerId, opacity) => {
      const layer = getLayer(layerId);
      if (!layer) return { ok: false, error: 'Unknown layer' };
      layer.opacity = Math.max(0, Math.min(1, opacity));
      updateLayerCardUI(layerId);
      return { ok: true };
    },

    enableMediaPipe: async (modes) => {
      try {
        // Ensure webcam is available for detection
        const hasWebcam = mediaInputs.some(m => m.name === 'Webcam' && m.type === 'video');
        if (!hasWebcam) await addMediaFromWebcam();
        // Sync mode state with UI
        if (modes) {
          for (const k of ['hand', 'face', 'pose', 'segment']) {
            if (k in modes) mpModeState[k] = modes[k];
          }
          // Update mode button UI
          document.querySelectorAll('.mp-mode-btn').forEach(btn => {
            btn.classList.toggle('active', !!mpModeState[btn.dataset.mpMode]);
          });
        }
        await mediaPipeMgr.init(mpModeState);
        // Add MediaPipe media entry if not already present
        if (!mediaInputs.some(m => m._isMediaPipe)) {
          const id = ++mediaIdCounter;
          mediaInputs.push({ id, name: mediaPipeMgr.getLabel(), type: 'mediapipe', element: null, glTexture: null, threeTexture: null, threeModel: null, _isMediaPipe: true });
          renderMediaList();
        }
        // Enable gesture processing + show UI
        gestureEnabled = true;
        document.getElementById('cam-mediapipe-btn').classList.add('active');
        document.getElementById('mp-modes-row').style.display = '';
        document.getElementById('gesture-toggle-row').style.display = '';
        document.getElementById('gesture-ctrl-btn').classList.add('active');
        document.getElementById('hand-as-mouse-row').style.display = '';
        document.getElementById('bt-texture-scale-row').style.display = '';
        return { ok: true, label: mediaPipeMgr.getLabel() };
      } catch (e) {
        return { ok: false, error: e.message };
      }
    },

    getAudioLevels: () => ({
      level: audioLevel, bass: audioBass, mid: audioMid, high: audioHigh,
      hasAudio: !!activeAudioEntry,
    }),

    setVarFontWeight,
    setVarFontFamily,
    layers,
    getLayer,
    getLayers: () => layers.map(l => ({ id: l.id, type: l.type, visible: l.visible, opacity: l.opacity, blendMode: l.blendMode })),
    compileToLayer,

    setSceneFlip: (flipH, flipV) => {
      const layer = getLayer('scene');
      if (!layer) return { ok: false, error: 'Scene layer not found' };
      layer.sceneFlipH = !!flipH;
      layer.sceneFlipV = !!flipV;
      const card = document.querySelector('.layer-card[data-layer="scene"]');
      if (card) {
        const fh = card.querySelector('.scene-flip-h');
        if (fh) fh.classList.toggle('active', layer.sceneFlipH);
        const fv = card.querySelector('.scene-flip-v');
        if (fv) fv.classList.toggle('active', layer.sceneFlipV);
      }
      return { ok: true };
    },
  };

  // --- Auto-compile on change ---
  let compileTimeout = null;
  editor.on('change', () => {
    if (!document.getElementById('auto-compile').checked) return;
    clearTimeout(compileTimeout);
    compileTimeout = setTimeout(compile, 600);
  });

  // --- Buttons ---
  document.getElementById('compile-btn').addEventListener('click', compile);

  let compositionPlaying = false; // start paused — loadDefaults enables after compile

  document.getElementById('play-btn').addEventListener('click', () => {
    compositionPlaying = !compositionPlaying;
    document.getElementById('play-btn').innerHTML = compositionPlaying ? '&#9654;' : '&#9646;&#9646;';
  });

  document.getElementById('fs-btn').addEventListener('click', () => {
    if (document.fullscreenElement) document.exitFullscreen();
    else document.getElementById('preview').requestFullscreen();
  });

  document.getElementById('new-btn').addEventListener('click', () => {
    loadSource(DEFAULT_SHADER);
  });

  document.getElementById('download-btn').addEventListener('click', () => {
    const blob = new Blob([editor.getValue()], { type: 'text/plain' });
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = 'shader.fs';
    a.click();
    URL.revokeObjectURL(a.href);
  });

  // --- Load Shader Library + Populate Layer Dropdowns ---
  let manifest = [];
  try {
    const resp = await fetch('shaders/manifest.json');
    manifest = await resp.json();
  } catch (e) {
    console.warn('Could not load shader manifest:', e);
  }

  const scenes = manifest.filter(item => item.type === 'scene');
  const isfShaders = manifest.filter(item => item.type !== 'scene');
  const textShaders = isfShaders.filter(item => (item.categories || []).includes('Text'));
  const otherShaders = isfShaders.filter(item => !(item.categories || []).includes('Text'));

  // Populate layer shader dropdowns from manifest
  function populateShaderDropdown(layerId) {
    const select = document.querySelector(`.layer-shader-select[data-layer="${layerId}"]`);
    if (!select) return;
    select.innerHTML = '';

    let items;
    if (layerId === 'scene') {
      items = scenes;
    } else if (layerId === 'text') {
      items = isfShaders.filter(item => (item.categories || []).includes('Text'));
    } else if (layerId === 'overlay') {
      return; // overlay has no shader presets
    } else {
      items = isfShaders.filter(item => !(item.categories || []).includes('Text'));
    }

    // Add placeholder so first real selection triggers change event
    const layer = getLayer(layerId);
    if (!layer || !layer.manifestEntry) {
      const ph = document.createElement('option');
      ph.value = '';
      ph.disabled = true;
      ph.selected = true;
      ph.textContent = '\u2014';
      select.appendChild(ph);
    }

    items.forEach(item => {
      const opt = document.createElement('option');
      opt.value = item.file;
      opt.dataset.folder = item.folder || (layerId === 'scene' ? 'scenes' : 'shaders');
      opt.textContent = item.title;
      select.appendChild(opt);
    });

    // Set current value if a shader is already loaded
    if (layer && layer.manifestEntry) {
      select.value = layer.manifestEntry.file;
    }
  }

  // Populate all layer dropdowns on init
  populateShaderDropdown('text');
  populateShaderDropdown('shader');
  populateShaderDropdown('scene');

  // Layer dropdown change handlers — loads selected shader/scene
  document.querySelectorAll('.layer-shader-select').forEach(select => {
    select.addEventListener('change', async () => {
      const layerId = select.dataset.layer;
      const file = select.value;
      if (!file) return;
      const opt = select.querySelector(`option[value="${CSS.escape(file)}"]`);
      const folder = opt ? (opt.dataset.folder || 'shaders') : 'shaders';
      const item = manifest.find(m => m.file === file);
      const layer = getLayer(layerId);
      if (layer && item) layer.manifestEntry = item;

      if (layerId === 'scene') {
        await loadScene(folder, file);
        layer.visible = true;
        updateLayerCardUI(layerId);
      } else {
        await loadShaderToLayer(layerId, folder, file);
        layer.visible = true;
        updateLayerCardUI(layerId);
      }
    });
  });

  // --- Shader Browser ---
  const browserOverlay = document.getElementById('shader-browser');
  const browserBackdrop = document.getElementById('shader-browser-backdrop');
  const browserBody = browserOverlay ? browserOverlay.querySelector('.browser-body') : null;
  const browserSearch = browserOverlay ? browserOverlay.querySelector('.browser-search') : null;
  const browserClose = browserOverlay ? browserOverlay.querySelector('.browser-close') : null;
  let browserTargetLayer = null;

  function openShaderBrowser(layerId) {
    browserTargetLayer = layerId;
    if (!browserOverlay || !browserBody) return;
    browserBody.innerHTML = '';
    browserSearch.value = '';

    // Build category groups
    const categories = {};
    const list = layerId === 'scene' ? scenes : isfShaders;
    list.forEach(item => {
      const cats = item.categories || ['Uncategorized'];
      cats.forEach(cat => {
        if (!categories[cat]) categories[cat] = [];
        categories[cat].push(item);
      });
    });

    for (const [cat, items] of Object.entries(categories)) {
      const section = document.createElement('div');
      section.className = 'browser-category';
      section.innerHTML = `<div class="browser-category-title">${cat}</div>`;
      const grid = document.createElement('div');
      grid.className = 'browser-grid';
      items.forEach(item => {
        const el = document.createElement('div');
        el.className = 'browser-item';
        el.textContent = item.title;
        el.dataset.search = item.title.toLowerCase();
        el.addEventListener('click', async () => {
          closeBrowser();
          // Store manifest entry before loading so populatePresetDropdown has title fallback
          const layer = getLayer(layerId);
          if (layer) layer.manifestEntry = item;
          const folder = item.folder || (layerId === 'scene' ? 'scenes' : 'shaders');
          if (layerId === 'scene') {
            await loadScene(folder, item.file);
          } else {
            await loadShaderToLayer(layerId, folder, item.file);
          }
        });
        grid.appendChild(el);
      });
      section.appendChild(grid);
      browserBody.appendChild(section);
    }

    browserOverlay.classList.add('visible');
    browserBackdrop.classList.add('visible');
    browserSearch.focus();
  }

  function closeBrowser() {
    if (browserOverlay) browserOverlay.classList.remove('visible');
    if (browserBackdrop) browserBackdrop.classList.remove('visible');
    browserTargetLayer = null;
  }

  if (browserClose) browserClose.addEventListener('click', closeBrowser);
  if (browserBackdrop) browserBackdrop.addEventListener('click', closeBrowser);
  if (browserSearch) {
    browserSearch.addEventListener('input', () => {
      const q = browserSearch.value.toLowerCase();
      browserBody.querySelectorAll('.browser-item').forEach(el => {
        el.style.display = el.dataset.search.includes(q) ? '' : 'none';
      });
    });
  }

  // --- Layer Card UI Handlers ---
  function updateLayerCardUI(layerId) {
    const layer = getLayer(layerId);
    if (!layer) return;
    const card = document.querySelector(`.layer-card[data-layer="${layerId}"]`);
    if (!card) return;
    const visBtn = card.querySelector('.layer-vis');
    if (visBtn) {
      visBtn.classList.toggle('hidden', !layer.visible);
      visBtn.innerHTML = layer.visible ? '&#x1F441;' : '&#x1F441;&#x200D;&#x1F5E8;';
    }
    const opSlider = card.querySelector('.layer-opacity');
    if (opSlider) opSlider.value = layer.opacity;
    const opVal = card.querySelector('.layer-control-row .val');
    if (opVal) opVal.textContent = layer.opacity.toFixed(2);
    const blendSel = card.querySelector('.layer-blend');
    if (blendSel) blendSel.value = layer.blendMode;
  }

  // Wire up layer card interactions
  document.querySelectorAll('.layer-card').forEach(card => {
    const layerId = card.dataset.layer;

    // Click header handled by pointerup in drag handler (avoids double-toggle)

    // Visibility toggle
    const visBtn = card.querySelector('.layer-vis');
    if (visBtn) {
      visBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        const layer = getLayer(layerId);
        if (!layer) return;
        layer.visible = !layer.visible;
        updateLayerCardUI(layerId);
      });
    }

    // Opacity slider
    const opSlider = card.querySelector('.layer-opacity');
    const opVal = card.querySelector('.layer-control-row .val');
    if (opSlider) {
      opSlider.addEventListener('input', () => {
        const layer = getLayer(layerId);
        if (!layer) return;
        layer.opacity = parseFloat(opSlider.value);
        if (opVal) opVal.textContent = layer.opacity.toFixed(2);
      });
    }

    // Blend mode
    const blendSel = card.querySelector('.layer-blend');
    if (blendSel) {
      blendSel.addEventListener('change', () => {
        const layer = getLayer(layerId);
        if (!layer) return;
        layer.blendMode = blendSel.value;
      });
    }

    // Scene flip toggles
    const flipH = card.querySelector('.scene-flip-h');
    if (flipH) {
      flipH.addEventListener('click', () => {
        const layer = getLayer(layerId);
        layer.sceneFlipH = !layer.sceneFlipH;
        flipH.classList.toggle('active', layer.sceneFlipH);
      });
    }
    const flipV = card.querySelector('.scene-flip-v');
    if (flipV) {
      flipV.addEventListener('click', () => {
        const layer = getLayer(layerId);
        layer.sceneFlipV = !layer.sceneFlipV;
        flipV.classList.toggle('active', layer.sceneFlipV);
      });
    }
  });

  // === Camera card: Overlay image/GIF upload with transforms ===
  const overlayFileInput = document.createElement('input');
  overlayFileInput.type = 'file';
  overlayFileInput.accept = 'image/*,.gif';
  overlayFileInput.style.display = 'none';
  document.body.appendChild(overlayFileInput);

  // Initialize overlay transform state
  const overlayLayer = getLayer('overlay');
  overlayLayer._tx = 0;
  overlayLayer._ty = 0;
  overlayLayer._scale = 0.3; // ~sphere size by default
  overlayLayer._rotate = 0; // radians

  document.getElementById('overlay-upload-btn').addEventListener('click', () => {
    overlayFileInput.click();
  });

  overlayFileInput.addEventListener('change', () => {
    const file = overlayFileInput.files[0];
    if (!file) return;
    const isGif = file.type === 'image/gif' || file.name.toLowerCase().endsWith('.gif');
    const img = new Image();
    const url = URL.createObjectURL(file);
    img.onload = () => {
      const gl = isfRenderer.gl;
      const oLayer = getLayer('overlay');
      if (!oLayer) return;
      if (!oLayer.fbo) oLayer.fbo = isfRenderer.createFBO(1920, 1080);
      gl.bindTexture(gl.TEXTURE_2D, oLayer.fbo.texture);
      gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, img);
      gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
      oLayer.visible = true;
      oLayer._hasImage = true;
      oLayer._imgAspect = img.naturalWidth / img.naturalHeight;
      // True-size import: scale so a 1920x1080 image fills viewport at 1.0
      oLayer._tx = 0;
      oLayer._ty = 0;
      oLayer._scale = Math.min(2, Math.max(0.1, Math.max(img.naturalWidth / 1920, img.naturalHeight / 1080)));
      oLayer._rotate = 0;
      syncTransformSliders();
      updateLayerCardUI('overlay');
      if (isGif) {
        // Keep img alive for animated GIF re-upload each frame
        oLayer._gifElement = img;
        oLayer._gifUrl = url;
      } else {
        oLayer._gifElement = null;
        if (oLayer._gifUrl) { URL.revokeObjectURL(oLayer._gifUrl); oLayer._gifUrl = null; }
        URL.revokeObjectURL(url);
      }
    };
    img.src = url;
    overlayFileInput.value = '';
  });

  // Clipboard paste handler — paste images directly onto overlay
  document.addEventListener('paste', (e) => {
    // Skip if typing in a text input, textarea, or CodeMirror editor
    const tag = (e.target.tagName || '').toLowerCase();
    if (tag === 'input' || tag === 'textarea' || e.target.closest('.cm-editor')) return;
    if (!e.clipboardData || !e.clipboardData.items) return;
    for (const item of e.clipboardData.items) {
      if (item.type.startsWith('image/')) {
        e.preventDefault();
        const blob = item.getAsFile();
        if (!blob) continue;
        const img = new Image();
        const url = URL.createObjectURL(blob);
        img.onload = () => {
          const gl = isfRenderer.gl;
          const oLayer = getLayer('overlay');
          if (!oLayer) return;
          if (!oLayer.fbo) oLayer.fbo = isfRenderer.createFBO(1920, 1080);
          gl.bindTexture(gl.TEXTURE_2D, oLayer.fbo.texture);
          gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
          gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, img);
          gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
          oLayer.visible = true;
          oLayer._hasImage = true;
          oLayer._imgAspect = img.naturalWidth / img.naturalHeight;
          oLayer._tx = 0;
          oLayer._ty = 0;
          oLayer._scale = Math.min(2, Math.max(0.1, Math.max(img.naturalWidth / 1920, img.naturalHeight / 1080)));
          oLayer._rotate = 0;
          oLayer._gifElement = null;
          if (oLayer._gifUrl) { URL.revokeObjectURL(oLayer._gifUrl); oLayer._gifUrl = null; }
          URL.revokeObjectURL(url);
          syncTransformSliders();
          updateLayerCardUI('overlay');
        };
        img.src = url;
        break; // Only handle first image item
      }
    }
  });

  // Overlay clear function (no button, but kept for programmatic use)
  function clearOverlay() {
    const gl = isfRenderer.gl;
    const oLayer = getLayer('overlay');
    if (!oLayer) return;
    if (!oLayer.fbo) return; // nothing to clear
    gl.bindTexture(gl.TEXTURE_2D, oLayer.fbo.texture);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1920, 1080, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
    oLayer.visible = false;
    oLayer._hasImage = false;
    oLayer._imgAspect = null;
    oLayer._gifElement = null;
    if (oLayer._gifUrl) { URL.revokeObjectURL(oLayer._gifUrl); oLayer._gifUrl = null; }
    updateLayerCardUI('overlay');
  }

  // Overlay transform sliders
  document.getElementById('overlay-tx').addEventListener('input', (e) => {
    const v = parseFloat(e.target.value);
    getLayer('overlay')._tx = v;
    document.getElementById('overlay-tx-val').textContent = v.toFixed(2);
  });
  document.getElementById('overlay-ty').addEventListener('input', (e) => {
    const v = parseFloat(e.target.value);
    getLayer('overlay')._ty = v;
    document.getElementById('overlay-ty-val').textContent = v.toFixed(2);
  });
  document.getElementById('overlay-scale').addEventListener('input', (e) => {
    const v = parseFloat(e.target.value);
    getLayer('overlay')._scale = v;
    document.getElementById('overlay-scale-val').textContent = v.toFixed(2);
  });
  document.getElementById('overlay-rotate').addEventListener('input', (e) => {
    const deg = parseFloat(e.target.value);
    getLayer('overlay')._rotate = deg * Math.PI / 180;
    document.getElementById('overlay-rotate-val').innerHTML = deg + '&#176;';
  });

  // === Overlay Gizmo — interactive transform handles ===
  const gizmoCanvas = document.getElementById('overlay-gizmo');
  const gCtx = gizmoCanvas.getContext('2d');
  let gizmoDrag = null;

  // Cached DOM references for gizmo (avoid per-frame getElementById + getBoundingClientRect)
  const _glCanvasEl = document.getElementById('gl-canvas');
  let _glCanvasRect = _glCanvasEl.getBoundingClientRect();
  window.addEventListener('resize', () => { _glCanvasRect = _glCanvasEl.getBoundingClientRect(); });
  // Also refresh after any style/layout change that might shift the canvas
  new ResizeObserver(() => { _glCanvasRect = _glCanvasEl.getBoundingClientRect(); }).observe(_glCanvasEl);

  function syncTransformSliders() {
    const o = getLayer('overlay');
    const txS = document.getElementById('overlay-tx');
    const tyS = document.getElementById('overlay-ty');
    const scS = document.getElementById('overlay-scale');
    const rtS = document.getElementById('overlay-rotate');
    txS.value = Math.max(-1, Math.min(1, o._tx));
    document.getElementById('overlay-tx-val').textContent = o._tx.toFixed(2);
    tyS.value = Math.max(-1, Math.min(1, o._ty));
    document.getElementById('overlay-ty-val').textContent = o._ty.toFixed(2);
    scS.value = Math.max(0.1, Math.min(5, o._scale));
    document.getElementById('overlay-scale-val').textContent = o._scale.toFixed(2);
    const deg = o._rotate * 180 / Math.PI;
    rtS.value = Math.max(-180, Math.min(180, deg));
    document.getElementById('overlay-rotate-val').innerHTML = Math.round(deg) + '&#176;';
  }

  function gizmoGeometry() {
    const o = getLayer('overlay');
    const r = _glCanvasRect;
    const cw = r.width, ch = r.height;
    const cx = (0.5 + (o._tx || 0)) * cw;
    const cy = (0.5 - (o._ty || 0)) * ch;
    const sc = o._scale || 1;
    const imgAsp = o._imgAspect || (cw / ch);
    const hw = 0.5 * sc * imgAsp * ch, hh = 0.5 * sc * ch;
    const ang = -(o._rotate || 0);
    const ca = Math.cos(ang), sa = Math.sin(ang);
    const corners = [
      { x: cx + ca*(-hw) - sa*(-hh), y: cy + sa*(-hw) + ca*(-hh) },
      { x: cx + ca*(hw) - sa*(-hh),  y: cy + sa*(hw) + ca*(-hh) },
      { x: cx + ca*(hw) - sa*(hh),   y: cy + sa*(hw) + ca*(hh) },
      { x: cx + ca*(-hw) - sa*(hh),  y: cy + sa*(-hw) + ca*(hh) }
    ];
    return { cx, cy, hw, hh, ang, corners, cw, ch };
  }

  function hitCorner(mx, my, corners) {
    const thresh = 18;
    for (let i = 0; i < corners.length; i++) {
      const dx = mx - corners[i].x, dy = my - corners[i].y;
      if (dx*dx + dy*dy < thresh*thresh) return i;
    }
    return -1;
  }

  function hitBox(mx, my, geo) {
    const dx = mx - geo.cx, dy = my - geo.cy;
    const ca = Math.cos(-geo.ang), sa = Math.sin(-geo.ang);
    const lx = ca * dx - sa * dy, ly = sa * dx + ca * dy;
    return Math.abs(lx) <= geo.hw && Math.abs(ly) <= geo.hh;
  }

  function drawGizmo() {
    const o = getLayer('overlay');
    const r = _glCanvasRect;
    if (gizmoCanvas.width !== r.width || gizmoCanvas.height !== r.height) {
      gizmoCanvas.width = r.width;
      gizmoCanvas.height = r.height;
    }
    gCtx.clearRect(0, 0, gizmoCanvas.width, gizmoCanvas.height);

    // Skeleton overlay (drawn before gizmo so gizmo handles stay on top)
    if (btOverlayEnabled && mediaPipeMgr.active) {
      drawLandmarkOverlay(gCtx, gizmoCanvas.width, gizmoCanvas.height);
    }

    if (o._hasImage && o.visible) {
      const { cx, cy, hw, hh, ang } = gizmoGeometry();
      gCtx.save();
      gCtx.translate(cx, cy);
      gCtx.rotate(ang);
      // Dashed bounding box
      gCtx.strokeStyle = 'rgba(78,205,196,0.7)';
      gCtx.lineWidth = 1.5;
      gCtx.setLineDash([6, 4]);
      gCtx.strokeRect(-hw, -hh, hw*2, hh*2);
      // Corner handles
      gCtx.setLineDash([]);
      const hs = 7;
      const pts = [[-hw,-hh],[hw,-hh],[hw,hh],[-hw,hh]];
      for (const [hx,hy] of pts) {
        gCtx.fillStyle = '#fff';
        gCtx.strokeStyle = '#4ecdc4';
        gCtx.lineWidth = 2;
        gCtx.fillRect(hx-hs, hy-hs, hs*2, hs*2);
        gCtx.strokeRect(hx-hs, hy-hs, hs*2, hs*2);
      }
      gCtx.restore();
    }
    requestAnimationFrame(drawGizmo);
  }
  requestAnimationFrame(drawGizmo);

  // Event handling via capture on #preview
  const previewEl = document.getElementById('preview');

  previewEl.addEventListener('pointerdown', (e) => {
    const o = getLayer('overlay');
    if (!o._hasImage || !o.visible) return;
    const r = _glCanvasRect;
    const mx = e.clientX - r.left, my = e.clientY - r.top;
    const geo = gizmoGeometry();
    const ci = hitCorner(mx, my, geo.corners);
    if (ci >= 0) {
      e.preventDefault(); e.stopPropagation();
      const dist = Math.sqrt((mx-geo.cx)**2 + (my-geo.cy)**2);
      const ang = Math.atan2(my-geo.cy, mx-geo.cx);
      gizmoDrag = { type:'scale', startDist:dist, startAngle:ang, startScale:o._scale, startRotate:o._rotate };
      previewEl.setPointerCapture(e.pointerId);
      return;
    }
    if (hitBox(mx, my, geo)) {
      e.preventDefault(); e.stopPropagation();
      gizmoDrag = { type:'move', startX:mx, startY:my, startTx:o._tx, startTy:o._ty, cw:geo.cw, ch:geo.ch };
      previewEl.setPointerCapture(e.pointerId);
      return;
    }
  }, true);

  previewEl.addEventListener('pointermove', (e) => {
    const o = getLayer('overlay');
    if (!o._hasImage || !o.visible) { previewEl.style.cursor = ''; return; }
    const r = _glCanvasRect;
    const mx = e.clientX - r.left, my = e.clientY - r.top;

    if (gizmoDrag) {
      e.preventDefault();
      if (gizmoDrag.type === 'move') {
        o._tx = gizmoDrag.startTx + (mx - gizmoDrag.startX) / gizmoDrag.cw;
        o._ty = gizmoDrag.startTy - (my - gizmoDrag.startY) / gizmoDrag.ch;
        syncTransformSliders();
      } else if (gizmoDrag.type === 'scale') {
        const geo = gizmoGeometry();
        const dist = Math.sqrt((mx-geo.cx)**2 + (my-geo.cy)**2);
        o._scale = Math.max(0.1, Math.min(5, gizmoDrag.startScale * (dist / gizmoDrag.startDist)));
        const ang = Math.atan2(my-geo.cy, mx-geo.cx);
        o._rotate = gizmoDrag.startRotate + (gizmoDrag.startAngle - ang);
        syncTransformSliders();
      }
      return;
    }

    // Cursor hints
    const geo = gizmoGeometry();
    if (hitCorner(mx, my, geo.corners) >= 0) {
      previewEl.style.cursor = 'nwse-resize';
    } else if (hitBox(mx, my, geo)) {
      previewEl.style.cursor = 'move';
    } else {
      previewEl.style.cursor = '';
    }
  }, true);

  previewEl.addEventListener('pointerup', (e) => {
    if (gizmoDrag) {
      gizmoDrag = null;
      previewEl.releasePointerCapture(e.pointerId);
    }
  }, true);

  // Touch: two-finger pinch for scale + rotate
  let touchState = null;
  previewEl.addEventListener('touchstart', (e) => {
    const o = getLayer('overlay');
    if (!o._hasImage || !o.visible || e.touches.length < 2) return;
    const t0 = e.touches[0], t1 = e.touches[1];
    const dx = t1.clientX - t0.clientX, dy = t1.clientY - t0.clientY;
    touchState = {
      startDist: Math.sqrt(dx*dx + dy*dy),
      startAngle: Math.atan2(dy, dx),
      startScale: o._scale,
      startRotate: o._rotate
    };
    e.preventDefault();
  }, { passive: false, capture: true });

  previewEl.addEventListener('touchmove', (e) => {
    if (!touchState || e.touches.length < 2) return;
    const o = getLayer('overlay');
    const t0 = e.touches[0], t1 = e.touches[1];
    const dx = t1.clientX - t0.clientX, dy = t1.clientY - t0.clientY;
    const dist = Math.sqrt(dx*dx + dy*dy);
    const ang = Math.atan2(dy, dx);
    o._scale = Math.max(0.1, Math.min(5, touchState.startScale * (dist / touchState.startDist)));
    o._rotate = touchState.startRotate + (touchState.startAngle - ang);
    syncTransformSliders();
    e.preventDefault();
  }, { passive: false, capture: true });

  previewEl.addEventListener('touchend', () => { touchState = null; }, true);

  // === Camera card: Webcam toggle ===
  document.getElementById('cam-webcam-btn').addEventListener('click', async () => {
    const btn = document.getElementById('cam-webcam-btn');
    const hasWebcam = mediaInputs.some(m => m.name === 'Webcam' && m.type === 'video');
    if (hasWebcam) {
      // Stop webcam
      const wcEntry = mediaInputs.find(m => m.name === 'Webcam' && m.type === 'video');
      if (wcEntry) removeMedia(wcEntry.id);
      btn.classList.remove('active');
    } else {
      try {
        await addMediaFromWebcam();
        btn.classList.add('active');
      } catch (e) { console.warn('Webcam access denied:', e.message); }
    }
  });

  // === BT Preset dropdown ===
  const btPresetRow = document.getElementById('bt-preset-row');
  const btPresetSelect = document.getElementById('bt-preset-select');
  // Populate with body-tracking-friendly shaders (has rotationX/rotationY/shapeScale inputs)
  {
    const btShaders = manifest.filter(m => {
      const cats = m.categories || [];
      return cats.includes('3D') || m.title === 'Dancing Cube';
    });
    // Also include the Dancing Cube if it's not already matched
    const dcEntry = manifest.find(m => m.title === 'Dancing Cube');
    if (dcEntry && !btShaders.includes(dcEntry)) btShaders.unshift(dcEntry);
    const ph = document.createElement('option');
    ph.value = ''; ph.disabled = true; ph.selected = true; ph.textContent = '\u2014';
    btPresetSelect.appendChild(ph);
    for (const item of btShaders) {
      const opt = document.createElement('option');
      opt.value = item.file;
      opt.textContent = item.title;
      btPresetSelect.appendChild(opt);
    }
  }
  btPresetSelect.addEventListener('change', async () => {
    const file = btPresetSelect.value;
    if (!file) return;
    const item = manifest.find(m => m.file === file);
    if (!item) return;
    // Load to shader layer and enable gesture inputs
    const layer = getLayer('shader');
    if (layer) {
      layer.manifestEntry = item;
      layer._hasGestureInputs = true;
      layer.visible = true;
      updateLayerCardUI('shader');
    }
    await loadShaderToLayer('shader', 'shaders', file);
    // Also update the shader layer dropdown
    const shaderSelect = document.querySelector('.layer-shader-select[data-layer="shader"]');
    if (shaderSelect) shaderSelect.value = file;
  });

  // === Shader layer: Background color & Transparent BG ===
  document.getElementById('shader-bg-color').addEventListener('input', (e) => {
    const hex = e.target.value;
    const r = parseInt(hex.substr(1, 2), 16) / 255;
    const g = parseInt(hex.substr(3, 2), 16) / 255;
    const b = parseInt(hex.substr(5, 2), 16) / 255;
    const layer = getLayer('shader');
    if (layer) {
      layer._bgColor = [r, g, b];
    }
  });
  document.getElementById('shader-transparent-bg-btn').addEventListener('click', () => {
    const btn = document.getElementById('shader-transparent-bg-btn');
    const layer = getLayer('shader');
    if (!layer) return;
    layer.transparentBg = !layer.transparentBg;
    btn.classList.toggle('active', layer.transparentBg);
  });

  // === Body Tracking card: MediaPipe toggle ===
  const mpModesRow = document.getElementById('mp-modes-row');
  const gestureToggleRow = document.getElementById('gesture-toggle-row');
  const gestureCtrlBtn = document.getElementById('gesture-ctrl-btn');
  const handAsMouseRow = document.getElementById('hand-as-mouse-row');
  const handAsMouseBtn = document.getElementById('hand-as-mouse-btn');
  let gestureEnabled = false;
  let handAsMouseEnabled = false;
  let btOverlayEnabled = false;
  const mpModeState = { hand: true, face: false, pose: false, segment: false };

  // === Skeleton Overlay: landmark drawing constants ===
  const HAND_CONNECTIONS = [[0,1],[1,2],[2,3],[3,4],[0,5],[5,6],[6,7],[7,8],[0,9],[9,10],[10,11],[11,12],[0,13],[13,14],[14,15],[15,16],[0,17],[17,18],[18,19],[19,20],[5,9],[9,13],[13,17]];
  const POSE_CONNECTIONS = [[11,12],[11,13],[13,15],[12,14],[14,16],[11,23],[12,24],[23,24],[23,25],[25,27],[24,26],[26,28]];
  const FACE_KEY_INDICES = [1,33,263,13,152,10,234,454,70,300,0,17,123,352,6];
  const FACE_JAWLINE = [10,338,297,332,284,251,389,356,454,323,361,288,397,365,379,378,400,377,152,148,176,149,150,136,172,58,132,93,234,127,162,21,54,103,67,109,10];

  function drawLandmarkOverlay(ctx, w, h) {
    const _sx = (lm) => lm.x * w;
    const _sy = (lm) => (1.0 - lm.y) * h;

    // Hand skeleton
    const hand = mediaPipeMgr._lastHandLandmarks;
    if (hand && hand.length > 20) {
      ctx.strokeStyle = 'rgba(78,205,196,0.5)';
      ctx.fillStyle = 'rgba(78,205,196,0.6)';
      ctx.lineWidth = 1.5;
      for (const [a, b] of HAND_CONNECTIONS) {
        if (!hand[a] || !hand[b]) continue;
        ctx.beginPath(); ctx.moveTo(_sx(hand[a]), _sy(hand[a]));
        ctx.lineTo(_sx(hand[b]), _sy(hand[b])); ctx.stroke();
      }
      for (let i = 0; i < 21; i++) {
        if (!hand[i]) continue;
        ctx.beginPath(); ctx.arc(_sx(hand[i]), _sy(hand[i]), 3, 0, Math.PI * 2); ctx.fill();
      }
      // Second hand
      const hand2 = mediaPipeMgr._lastHandLandmarks2;
      if (hand2 && hand2.length > 20) {
        for (const [a, b] of HAND_CONNECTIONS) {
          if (!hand2[a] || !hand2[b]) continue;
          ctx.beginPath(); ctx.moveTo(_sx(hand2[a]), _sy(hand2[a]));
          ctx.lineTo(_sx(hand2[b]), _sy(hand2[b])); ctx.stroke();
        }
        for (let i = 0; i < 21; i++) {
          if (!hand2[i]) continue;
          ctx.beginPath(); ctx.arc(_sx(hand2[i]), _sy(hand2[i]), 3, 0, Math.PI * 2); ctx.fill();
        }
      }
    }

    // Pose skeleton
    const pose = mediaPipeMgr._lastPoseLandmarks;
    if (pose && pose.length > 28) {
      ctx.strokeStyle = 'rgba(255,215,0,0.4)';
      ctx.fillStyle = 'rgba(255,215,0,0.5)';
      ctx.lineWidth = 2;
      for (const [a, b] of POSE_CONNECTIONS) {
        if (!pose[a] || !pose[b]) continue;
        ctx.beginPath(); ctx.moveTo(_sx(pose[a]), _sy(pose[a]));
        ctx.lineTo(_sx(pose[b]), _sy(pose[b])); ctx.stroke();
      }
      for (let i = 0; i < 33; i++) {
        if (!pose[i]) continue;
        ctx.beginPath(); ctx.arc(_sx(pose[i]), _sy(pose[i]), 4, 0, Math.PI * 2); ctx.fill();
      }
    }

    // Face mesh (sparse)
    const face = mediaPipeMgr._lastFaceLandmarks;
    if (face && face.length > 454) {
      ctx.fillStyle = 'rgba(255,127,80,0.35)';
      // Key landmark dots
      for (const idx of FACE_KEY_INDICES) {
        if (!face[idx]) continue;
        ctx.beginPath(); ctx.arc(_sx(face[idx]), _sy(face[idx]), 2.5, 0, Math.PI * 2); ctx.fill();
      }
      // Jawline contour
      ctx.strokeStyle = 'rgba(255,127,80,0.25)';
      ctx.lineWidth = 1;
      ctx.beginPath();
      for (let i = 0; i < FACE_JAWLINE.length; i++) {
        const p = face[FACE_JAWLINE[i]];
        if (!p) continue;
        if (i === 0) ctx.moveTo(_sx(p), _sy(p));
        else ctx.lineTo(_sx(p), _sy(p));
      }
      ctx.stroke();
    }
  }

  // === Skeleton Overlay toggle ===
  const btOverlayRow = document.getElementById('bt-overlay-row');
  const btOverlayBtn = document.getElementById('bt-overlay-btn');
  btOverlayBtn.addEventListener('click', () => {
    btOverlayEnabled = !btOverlayEnabled;
    btOverlayBtn.classList.toggle('active', btOverlayEnabled);
  });

  // === BT Panel: collapsible section headers ===
  document.querySelectorAll('.bt-section-header').forEach(header => {
    header.addEventListener('click', () => header.classList.toggle('open'));
  });

  // === BT Panel: new section elements ===
  const btSignalsSection = document.getElementById('bt-signals-section');
  const btSignalsBody = document.getElementById('bt-signals-body');
  const btLinksSection = document.getElementById('bt-links-section');
  const btLinksBody = document.getElementById('bt-links-body');
  const btLinksList = document.getElementById('bt-links-list');
  const btLinkCount = document.getElementById('bt-link-count');
  const btRecordingSection = document.getElementById('bt-recording-section');

  // === Live Signals Monitor ===
  let _signalBarCache = {}; // { key: { fill, val } } for hot-path updates

  function renderSignalBars() {
    btSignalsBody.innerHTML = '';
    _signalBarCache = {};
    for (const group of ['hand', 'face', 'pose']) {
      if (!mpModeState[group]) continue;
      const signals = DERIVED_SIGNALS[group] || [];
      for (const sig of signals) {
        const row = document.createElement('div');
        row.className = 'bt-signal-row';
        row.innerHTML = `
          <span class="bt-signal-label">${sig.name}</span>
          <div class="bt-signal-bar"><div class="bt-signal-fill ${group}" data-key="${sig.key}"></div></div>
          <span class="bt-signal-val" data-key="${sig.key}">0.00</span>
          <button class="bt-signal-link" data-key="${sig.key}" data-group="${group}" title="Link to parameter">&rarr;</button>
        `;
        btSignalsBody.appendChild(row);
        const fill = row.querySelector('.bt-signal-fill');
        const val = row.querySelector('.bt-signal-val');
        _signalBarCache[sig.key] = { fill, val };
        // Link button
        row.querySelector('.bt-signal-link').addEventListener('click', (e) => {
          openDerivedLinkPicker(sig.key, sig.name, e.target);
        });
      }
    }
  }

  function updateSignalBars() {
    const d = gestureProcessor.derived;
    for (const key in _signalBarCache) {
      const { fill, val } = _signalBarCache[key];
      const v = d[key] || 0;
      fill.style.width = (v * 100).toFixed(1) + '%';
      val.textContent = v.toFixed(2);
    }
  }

  // === Active Bindings Dashboard ===
  function renderLinksDashboard() {
    btLinksList.innerHTML = '';
    let count = 0;
    for (const layer of layers) {
      if (!layer.mpBindings || !layer.mpBindings.length) continue;
      for (let bi = 0; bi < layer.mpBindings.length; bi++) {
        const b = layer.mpBindings[bi];
        count++;
        const row = document.createElement('div');
        row.className = 'bt-link-row';
        let srcLabel;
        if (b.source === 'derived') {
          // Find signal name
          let sigName = b.signalKey;
          for (const grp in DERIVED_SIGNALS) {
            const found = DERIVED_SIGNALS[grp].find(s => s.key === b.signalKey);
            if (found) { sigName = found.name; break; }
          }
          srcLabel = sigName;
        } else {
          const part = (MP_BODY_PARTS[b.group] || []).find(p => p.index === b.landmarkIndex);
          srcLabel = (part ? part.name : b.group) + '.' + (b.axis || 'x');
        }
        row.innerHTML = `
          <span class="bt-link-source">${srcLabel}</span>
          <span class="bt-link-arrow">&rarr;</span>
          <span class="bt-link-target">${layer.id}/${b.param}</span>
          <span class="bt-link-value" data-layer="${layer.id}" data-param="${b.param}">—</span>
          <button class="bt-link-remove" data-layer="${layer.id}" data-bi="${bi}" title="Remove link">&times;</button>
        `;
        btLinksList.appendChild(row);
        row.querySelector('.bt-link-remove').addEventListener('click', function() {
          const lid = this.dataset.layer;
          const idx = parseInt(this.dataset.bi);
          const l = getLayer(lid);
          if (l && l.mpBindings) {
            l.mpBindings.splice(idx, 1);
            renderLinksDashboard();
            refreshAllLinksUI();
          }
        });
      }
    }
    btLinkCount.textContent = count;
    btLinkCount.style.display = count > 0 ? '' : 'none';
  }

  function updateLinksDashboardValues() {
    const valEls = btLinksList.querySelectorAll('.bt-link-value');
    for (const el of valEls) {
      const layer = getLayer(el.dataset.layer);
      if (layer && layer.inputValues[el.dataset.param] != null) {
        el.textContent = Number(layer.inputValues[el.dataset.param]).toFixed(2);
      }
    }
  }

  // === Derived Signal Bind Picker (opens from signal bar bind button) ===
  function openDerivedLinkPicker(signalKey, signalName, anchorEl) {
    // Build a simple target picker: which layer × which param?
    const picker = document.createElement('div');
    picker.className = 'mp-picker';
    picker.style.display = 'flex';
    picker.style.width = '200px';
    let html = '<div style="padding:6px 8px;font-size:10px;color:var(--text);border-bottom:1px solid var(--border);">Link <b>' + signalName + '</b> to:</div>';
    html += '<div class="mp-picker-list" style="max-height:200px">';
    for (const layer of layers) {
      if (!layer.inputs || layer.inputs.length === 0) continue;
      for (const inp of layer.inputs) {
        if (inp.TYPE !== 'float' && inp.TYPE !== 'long') continue;
        html += `<div class="mp-picker-list-item" data-layer="${layer.id}" data-param="${inp.NAME}">${layer.id}/${inp.LABEL || inp.NAME}</div>`;
      }
    }
    html += '</div>';
    picker.innerHTML = html;
    document.body.appendChild(picker);

    // Position
    const rect = anchorEl.getBoundingClientRect();
    picker.style.position = 'fixed';
    picker.style.zIndex = '1001';
    picker.style.left = Math.min(rect.right + 4, window.innerWidth - 210) + 'px';
    picker.style.top = Math.min(rect.top, window.innerHeight - 240) + 'px';

    // Handle selection
    picker.querySelectorAll('.mp-picker-list-item').forEach(item => {
      item.addEventListener('click', () => {
        const layerId = item.dataset.layer;
        const paramName = item.dataset.param;
        const layer = getLayer(layerId);
        if (!layer) return;
        if (!layer.mpBindings) layer.mpBindings = [];
        // Remove existing binding for this param if any
        const idx = layer.mpBindings.findIndex(b => b.param === paramName);
        if (idx >= 0) layer.mpBindings.splice(idx, 1);
        // Find ISF input for min/max
        const isfInput = (layer.inputs || []).find(inp => inp.NAME === paramName);
        const pMin = isfInput && isfInput.MIN != null ? isfInput.MIN : 0;
        const pMax = isfInput && isfInput.MAX != null ? isfInput.MAX : 1;
        layer.mpBindings.push({ source: 'derived', signalKey, param: paramName, min: pMin, max: pMax });
        renderLinksDashboard();
        refreshAllLinksUI();
        document.body.removeChild(picker);
        document.removeEventListener('pointerdown', closePicker, true);
      });
    });

    // Close on click outside
    const closePicker = (e) => {
      if (!picker.contains(e.target) && e.target !== anchorEl) {
        if (picker.parentNode) document.body.removeChild(picker);
        document.removeEventListener('pointerdown', closePicker, true);
      }
    };
    setTimeout(() => document.addEventListener('pointerdown', closePicker, true), 0);
  }

  // === Quick-Link (Map) mode ===
  let quickLinkActive = false;
  const btMapBtn = document.getElementById('bt-map-btn');
  btMapBtn.addEventListener('click', () => {
    quickLinkActive = !quickLinkActive;
    btMapBtn.classList.toggle('active', quickLinkActive);
    document.body.classList.toggle('quicklink-active', quickLinkActive);
  });

  // === + Link button: opens target picker then mp-picker ===
  document.getElementById('bt-add-link-btn').addEventListener('click', () => {
    // Build a target picker similar to derived link but opens full mp-picker after
    const picker = document.createElement('div');
    picker.className = 'mp-picker';
    picker.style.display = 'flex';
    picker.style.width = '200px';
    let html = '<div style="padding:6px 8px;font-size:10px;color:var(--text);border-bottom:1px solid var(--border);">Select target parameter:</div>';
    html += '<div class="mp-picker-list" style="max-height:220px">';
    for (const layer of layers) {
      if (!layer.inputs || layer.inputs.length === 0) continue;
      for (const inp of layer.inputs) {
        if (inp.TYPE !== 'float' && inp.TYPE !== 'long') continue;
        html += `<div class="mp-picker-list-item" data-layer="${layer.id}" data-param="${inp.NAME}">${layer.id}/${inp.LABEL || inp.NAME}</div>`;
      }
    }
    html += '</div>';
    picker.innerHTML = html;
    document.body.appendChild(picker);

    const btn = document.getElementById('bt-add-link-btn');
    const rect = btn.getBoundingClientRect();
    picker.style.position = 'fixed';
    picker.style.zIndex = '1001';
    picker.style.left = Math.min(rect.right + 4, window.innerWidth - 210) + 'px';
    picker.style.top = Math.min(rect.top, window.innerHeight - 240) + 'px';

    picker.querySelectorAll('.mp-picker-list-item').forEach(item => {
      item.addEventListener('click', () => {
        const layerId = item.dataset.layer;
        const paramName = item.dataset.param;
        if (picker.parentNode) document.body.removeChild(picker);
        document.removeEventListener('pointerdown', closePicker, true);
        // Now open the main mp-picker for this param
        const layerCard = document.querySelector(`.layer-params[data-layer="${layerId}"]`);
        if (!layerCard) return;
        const mpBtn = layerCard.querySelector(`.mp-map-btn[data-param-name="${paramName}"]`);
        if (mpBtn) {
          openMpPicker(mpBtn, paramName, layerCard);
        }
      });
    });

    const closePicker = (e) => {
      if (!picker.contains(e.target)) {
        if (picker.parentNode) document.body.removeChild(picker);
        document.removeEventListener('pointerdown', closePicker, true);
      }
    };
    setTimeout(() => document.addEventListener('pointerdown', closePicker, true), 0);
  });

  // === Recording System ===
  let btRecording = null; // { fps, startTime, frames, tracks }
  let btIsRecording = false;
  let btIsPlaying = false;
  let btPlaybackFrame = 0;
  let btPlaybackId = null;

  const btRecBtn = document.getElementById('bt-rec-btn');
  const btPlayBtn = document.getElementById('bt-play-btn');
  const btJsonBtn = document.getElementById('bt-json-btn');
  const btRecTimer = document.getElementById('bt-rec-timer');

  btRecBtn.addEventListener('click', () => {
    if (btIsRecording) {
      stopRecording();
    } else {
      startRecording();
    }
  });

  btPlayBtn.addEventListener('click', () => {
    if (btIsPlaying) {
      stopPlayback();
    } else {
      startPlayback();
    }
  });

  btJsonBtn.addEventListener('click', () => {
    if (btRecording) exportRecording();
  });

  function startRecording() {
    btRecording = { fps: 15, startTime: performance.now(), frames: [], tracks: {}, duration: 0 };
    btIsRecording = true;
    btRecBtn.classList.add('recording');
    btPlayBtn.disabled = true;
    btJsonBtn.disabled = true;
  }

  function captureFrame() {
    if (!btRecording || !btIsRecording) return;
    const frame = {};
    for (const layer of layers) {
      if (!layer.mpBindings || !layer.mpBindings.length) continue;
      for (const b of layer.mpBindings) {
        const trackKey = layer.id + '/' + b.param;
        if (!btRecording.tracks[trackKey]) btRecording.tracks[trackKey] = [];
        const v = layer.inputValues[b.param];
        btRecording.tracks[trackKey].push(v != null ? v : 0);
        frame[trackKey] = v;
      }
    }
    btRecording.frames.push(frame);
    // Update timer
    const elapsed = (performance.now() - btRecording.startTime) / 1000;
    const m = Math.floor(elapsed / 60);
    const s = Math.floor(elapsed % 60);
    btRecTimer.textContent = m + ':' + String(s).padStart(2, '0');
  }

  function stopRecording() {
    btIsRecording = false;
    btRecBtn.classList.remove('recording');
    if (btRecording) {
      btRecording.duration = btRecording.frames.length / btRecording.fps;
    }
    btPlayBtn.disabled = false;
    btJsonBtn.disabled = false;
  }

  function startPlayback() {
    if (!btRecording || btRecording.frames.length === 0) return;
    btIsPlaying = true;
    btPlayBtn.classList.add('playing');
    btPlaybackFrame = 0;
  }

  function applyPlaybackFrame() {
    if (!btIsPlaying || !btRecording) return;
    const frame = btRecording.frames[btPlaybackFrame];
    if (!frame) return;
    for (const trackKey in frame) {
      const [layerId, param] = trackKey.split('/');
      const layer = getLayer(layerId);
      if (layer) layer.inputValues[param] = frame[trackKey];
    }
    btPlaybackFrame = (btPlaybackFrame + 1) % btRecording.frames.length;
    // Update timer
    const elapsed = btPlaybackFrame / btRecording.fps;
    const m = Math.floor(elapsed / 60);
    const s = Math.floor(elapsed % 60);
    btRecTimer.textContent = m + ':' + String(s).padStart(2, '0');
  }

  function stopPlayback() {
    btIsPlaying = false;
    btPlayBtn.classList.remove('playing');
  }

  function exportRecording() {
    if (!btRecording) return;
    const json = JSON.stringify(btRecording, null, 2);
    const blob = new Blob([json], { type: 'application/json' });
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = 'bt-recording-' + Date.now() + '.json';
    a.click();
    URL.revokeObjectURL(a.href);
  }

  const btScaleRow = document.getElementById('bt-texture-scale-row');
  const btScaleSlider = document.getElementById('bt-texture-scale');
  const btScaleVal = document.getElementById('bt-texture-scale-val');
  btScaleSlider.addEventListener('input', () => {
    const v = parseFloat(btScaleSlider.value);
    btScaleVal.textContent = v.toFixed(2);
    gestureProcessor.textureScale = v;
  });

  // Gesture Control toggle
  gestureCtrlBtn.addEventListener('click', () => {
    gestureEnabled = !gestureEnabled;
    gestureCtrlBtn.classList.toggle('active', gestureEnabled);
  });

  // Hand as Mouse toggle
  handAsMouseBtn.addEventListener('click', () => {
    handAsMouseEnabled = !handAsMouseEnabled;
    handAsMouseBtn.classList.toggle('active', handAsMouseEnabled);
    for (const lid of ['text', 'shader', 'scene']) {
      const l = getLayer(lid);
      if (l) l.handAsMouse = handAsMouseEnabled;
    }
  });

  // Mode toggle buttons
  mpModesRow.querySelectorAll('.mp-mode-btn').forEach(btn => {
    btn.addEventListener('click', async () => {
      const mode = btn.dataset.mpMode;
      mpModeState[mode] = !mpModeState[mode];
      btn.classList.toggle('active', mpModeState[mode]);
      // If MediaPipe is active, reinit with new modes
      if (mediaPipeMgr.active) {
        const mpEntry = mediaInputs.find(m => m._isMediaPipe);
        if (mpEntry) removeMedia(mpEntry.id);
        try {
          await startMediaPipe();
        } catch (e) {
          console.warn('MediaPipe reinit failed:', e.message);
        }
      }
      // Refresh signal bars to show/hide signals for toggled mode
      renderSignalBars();
    });
  });

  async function startMediaPipe() {
    const btn = document.getElementById('cam-mediapipe-btn');
    // Auto-enable webcam
    const hasWebcam = mediaInputs.some(m => m.name === 'Webcam' && m.type === 'video');
    if (!hasWebcam) {
      try {
        await addMediaFromWebcam();
        document.getElementById('cam-webcam-btn').classList.add('active');
      } catch (e) { console.warn('Webcam needed for MediaPipe:', e.message); return; }
    }
    try {
      await mediaPipeMgr.init(mpModeState);
      const id = ++mediaIdCounter;
      const entry = { id, name: mediaPipeMgr.getLabel(), type: 'mediapipe', element: null, glTexture: null, threeTexture: null, threeModel: null, _isMediaPipe: true };
      mediaInputs.push(entry);
      renderMediaList();
      btn.classList.add('active');
      btPresetRow.style.display = '';
      mpModesRow.style.display = '';
      gestureToggleRow.style.display = '';
      handAsMouseRow.style.display = '';
      btScaleRow.style.display = '';
      btOverlayRow.style.display = '';
      btSignalsSection.style.display = '';
      btLinksSection.style.display = '';
      btRecordingSection.style.display = '';
      gestureEnabled = true;
      gestureCtrlBtn.classList.add('active');
      renderSignalBars();
      renderLinksDashboard();
    } catch (e) {
      console.warn('MediaPipe init failed:', e.message);
    }
  }

  document.getElementById('cam-mediapipe-btn').addEventListener('click', async () => {
    const btn = document.getElementById('cam-mediapipe-btn');
    if (mediaPipeMgr.active) {
      mediaPipeMgr.dispose();
      const mpEntry = mediaInputs.find(m => m._isMediaPipe);
      if (mpEntry) removeMedia(mpEntry.id);
      btn.classList.remove('active');
      btPresetRow.style.display = 'none';
      mpModesRow.style.display = 'none';
      gestureToggleRow.style.display = 'none';
      handAsMouseRow.style.display = 'none';
      btScaleRow.style.display = 'none';
      btOverlayRow.style.display = 'none';
      btSignalsSection.style.display = 'none';
      btLinksSection.style.display = 'none';
      btRecordingSection.style.display = 'none';
      btOverlayEnabled = false;
      btOverlayBtn.classList.remove('active');
      gestureEnabled = false;
      gestureCtrlBtn.classList.remove('active');
      handAsMouseEnabled = false;
      handAsMouseBtn.classList.remove('active');
      if (btIsRecording) stopRecording();
      if (btIsPlaying) stopPlayback();
      for (const lid of ['text', 'shader', 'scene']) {
        const l = getLayer(lid);
        if (l) l.handAsMouse = false;
      }
      refreshAllLinksUI();
      return;
    }
    btPresetRow.style.display = '';
    mpModesRow.style.display = '';
    gestureToggleRow.style.display = '';
    handAsMouseRow.style.display = '';
    btScaleRow.style.display = '';
    btOverlayRow.style.display = '';
    btSignalsSection.style.display = '';
    btLinksSection.style.display = '';
    btRecordingSection.style.display = '';
    await startMediaPipe();
    refreshAllLinksUI();
  });

  // === MediaPipe Bindings UI ===
  // Builds/refreshes the bindings panel inside each layer card's .layer-controls
  function buildLinksUI(layerId) {
    const layer = getLayer(layerId);
    if (!layer) return;
    const card = document.querySelector(`.layer-card[data-layer="${layerId}"]`);
    if (!card) return;
    const controls = card.querySelector('.layer-controls');
    if (!controls) return;

    // Remove legacy bindings section if still present
    const section = controls.querySelector('.mp-bindings-section');
    if (section) section.remove();

    // Sync per-slider MP map button highlights
    syncMpLinkedState(controls, layerId);
  }

  // Rebuild bindings UI when MediaPipe toggled or layer switches
  function refreshAllLinksUI() {
    for (const lid of ['text', 'shader', 'scene']) {
      buildLinksUI(lid);
    }
  }

  // === MP Map: sync bound state on parameter buttons ===
  function syncMpLinkedState(container, layerId) {
    const layer = getLayer(layerId);
    if (!layer || !container) return;
    const linkedSet = new Set();
    if (layer.mpBindings) {
      for (const b of layer.mpBindings) { if (b.param) linkedSet.add(b.param); }
    }
    for (const btn of container.querySelectorAll('.mp-map-btn')) {
      btn.classList.toggle('linked', linkedSet.has(btn.dataset.paramName));
    }
  }

  // === MP Picker: singleton popup for mapping body parts to params ===
  let _mpPickerEl = null;
  let _mpPickerCloseHandler = null;

  function createMpPicker() {
    if (_mpPickerEl) return _mpPickerEl;
    const el = document.createElement('div');
    el.className = 'mp-picker';
    el.style.display = 'none';
    el.innerHTML = `
      <div class="mp-picker-tabs">
        <button class="mp-picker-tab active" data-group="hand">Hand</button>
        <button class="mp-picker-tab" data-group="face">Face</button>
        <button class="mp-picker-tab" data-group="pose">Pose</button>
        <button class="mp-picker-tab" data-group="signals">Signals</button>
      </div>
      <div class="mp-picker-list"></div>
      <div class="mp-picker-axis">
        <label><input type="radio" name="mp-axis" value="x" checked><span>X</span></label>
        <label><input type="radio" name="mp-axis" value="y"><span>Y</span></label>
        <label><input type="radio" name="mp-axis" value="z"><span>Z</span></label>
      </div>
      <button class="mp-picker-clear">Clear Link</button>
    `;
    document.body.appendChild(el);
    _mpPickerEl = el;
    return el;
  }

  function openMpPicker(anchorBtn, paramName, container) {
    const picker = createMpPicker();
    const layerCard = container.closest('[data-layer]');
    if (!layerCard) return;
    const layerId = layerCard.dataset.layer;
    const layer = getLayer(layerId);
    if (!layer) return;
    if (!layer.mpBindings) layer.mpBindings = [];

    // Find existing binding for this param
    let existing = layer.mpBindings.find(b => b.param === paramName);

    // Find ISF input def for min/max
    const isfInput = (layer.inputs || []).find(inp => inp.NAME === paramName);
    const pMin = isfInput && isfInput.MIN != null ? isfInput.MIN : 0;
    const pMax = isfInput && isfInput.MAX != null ? isfInput.MAX : 1;

    let activeGroup = existing ? (existing.source === 'derived' ? 'signals' : existing.group) : 'hand';
    let selectedAxis = existing ? (existing.axis || 'x') : 'x';

    // Tabs
    const tabs = picker.querySelectorAll('.mp-picker-tab');
    const axisRow = picker.querySelector('.mp-picker-axis');
    tabs.forEach(t => {
      t.classList.toggle('active', t.dataset.group === activeGroup);
      t.onclick = () => {
        activeGroup = t.dataset.group;
        tabs.forEach(tt => tt.classList.toggle('active', tt === t));
        // Hide axis row for signals tab
        axisRow.style.display = activeGroup === 'signals' ? 'none' : '';
        renderList();
      };
    });
    axisRow.style.display = activeGroup === 'signals' ? 'none' : '';

    // Axis radios
    const axisRadios = picker.querySelectorAll('input[name="mp-axis"]');
    axisRadios.forEach(r => {
      r.checked = r.value === selectedAxis;
      r.onchange = () => {
        selectedAxis = r.value;
        if (existing && existing.axis) { existing.axis = selectedAxis; }
      };
    });

    // Landmark / Signals list
    const listEl = picker.querySelector('.mp-picker-list');
    function renderList() {
      listEl.innerHTML = '';
      if (activeGroup === 'signals') {
        // Derived signals from all groups
        for (const grp of ['hand', 'face', 'pose']) {
          const sigs = DERIVED_SIGNALS[grp] || [];
          for (const sig of sigs) {
            const item = document.createElement('div');
            item.className = 'mp-picker-list-item';
            item.textContent = sig.name;
            if (existing && existing.source === 'derived' && existing.signalKey === sig.key) {
              item.classList.add('selected');
            }
            item.onclick = () => {
              // Remove old binding, create derived
              const idx = layer.mpBindings.findIndex(b => b.param === paramName);
              if (idx >= 0) layer.mpBindings.splice(idx, 1);
              existing = { source: 'derived', signalKey: sig.key, param: paramName, min: pMin, max: pMax };
              layer.mpBindings.push(existing);
              anchorBtn.classList.add('linked');
              buildLinksUI(layerId);
              renderLinksDashboard();
              closeMpPicker();
            };
            listEl.appendChild(item);
          }
        }
      } else {
        const parts = MP_BODY_PARTS[activeGroup] || [];
        for (const part of parts) {
          const item = document.createElement('div');
          item.className = 'mp-picker-list-item';
          item.textContent = part.name;
          if (existing && existing.group === activeGroup && existing.landmarkIndex === part.index) {
            item.classList.add('selected');
          }
          item.onclick = () => {
            // Create or update landmark binding
            const idx = layer.mpBindings.findIndex(b => b.param === paramName);
            if (idx >= 0) layer.mpBindings.splice(idx, 1);
            existing = { group: activeGroup, landmarkIndex: part.index, param: paramName, axis: selectedAxis, min: pMin, max: pMax };
            layer.mpBindings.push(existing);
            anchorBtn.classList.add('linked');
            buildLinksUI(layerId);
            renderLinksDashboard();
            closeMpPicker();
          };
          listEl.appendChild(item);
        }
      }
    }
    renderList();

    // Clear button
    picker.querySelector('.mp-picker-clear').onclick = () => {
      const idx = layer.mpBindings.findIndex(b => b.param === paramName);
      if (idx >= 0) layer.mpBindings.splice(idx, 1);
      existing = null;
      anchorBtn.classList.remove('linked');
      buildLinksUI(layerId);
      closeMpPicker();
    };

    // Position near anchor
    const rect = anchorBtn.getBoundingClientRect();
    picker.style.display = 'flex';
    picker.style.left = Math.min(rect.right + 4, window.innerWidth - 190) + 'px';
    picker.style.top = Math.min(rect.top, window.innerHeight - 300) + 'px';

    // Close on click outside
    if (_mpPickerCloseHandler) document.removeEventListener('pointerdown', _mpPickerCloseHandler, true);
    _mpPickerCloseHandler = (e) => {
      if (!picker.contains(e.target) && e.target !== anchorBtn) closeMpPicker();
    };
    setTimeout(() => document.addEventListener('pointerdown', _mpPickerCloseHandler, true), 0);
  }

  function closeMpPicker() {
    if (_mpPickerEl) _mpPickerEl.style.display = 'none';
    if (_mpPickerCloseHandler) {
      document.removeEventListener('pointerdown', _mpPickerCloseHandler, true);
      _mpPickerCloseHandler = null;
    }
  }

  // === Live slider feedback for bound parameters (Step 5) ===
  function updateLinkedSliders() {
    for (const layer of layers) {
      if (!layer.mpBindings || layer.mpBindings.length === 0) continue;
      const container = document.querySelector(`.layer-params[data-layer="${layer.id}"]`);
      if (!container) continue;
      for (const b of layer.mpBindings) {
        if (!b.param || layer.inputValues[b.param] == null) continue;
        const row = container.querySelector(`.control-row[data-name="${b.param}"]`) ||
                    Array.from(container.querySelectorAll('.control-row')).find(r => {
                      const btn = r.querySelector('.mp-map-btn');
                      return btn && btn.dataset.paramName === b.param;
                    });
        if (!row) continue;
        const slider = row.querySelector('input[type="range"]');
        const valSpan = row.querySelector('.val');
        const v = layer.inputValues[b.param];
        if (slider) slider.value = v;
        if (valSpan) valSpan.textContent = Number(v).toFixed(2);
      }
    }
  }

  // Hook into MediaPipe enable to refresh bindings UI
  const _origStartMP = typeof startMediaPipe === 'function' ? startMediaPipe : null;

  // === 3D layer: model upload button ===
  document.getElementById('scene-model-btn').addEventListener('click', () => {
    document.getElementById('model-file-input').click();
  });

  // Inputs section collapse toggle
  document.querySelector('#inputs-section .section-header').addEventListener('click', () => {
    document.getElementById('inputs-section').classList.toggle('open');
  });

  // Sidebar resize drag
  const resizeHandle = document.getElementById('sidebar-resize');
  const appEl = document.getElementById('app');
  let resizing = false;
  resizeHandle.addEventListener('pointerdown', (e) => {
    resizing = true;
    resizeHandle.classList.add('active');
    resizeHandle.setPointerCapture(e.pointerId);
    document.body.style.cursor = 'col-resize';
    document.body.style.userSelect = 'none';
  });
  resizeHandle.addEventListener('pointermove', (e) => {
    if (!resizing) return;
    const w = Math.max(200, Math.min(600, window.innerWidth - e.clientX));
    appEl.style.gridTemplateColumns = '1fr 5px ' + w + 'px';
  });
  resizeHandle.addEventListener('pointerup', () => {
    resizing = false;
    resizeHandle.classList.remove('active');
    document.body.style.cursor = '';
    document.body.style.userSelect = '';
  });

  // Mobile drag handle — resize canvas/sidebar split
  const mobileDragHandle = document.getElementById('mobile-drag-handle');
  const mainEl = document.getElementById('main');
  let mobileResizing = false;
  let mobileResizePointerId = null;
  mobileDragHandle.addEventListener('pointerdown', (e) => {
    mobileResizing = true;
    mobileResizePointerId = e.pointerId;
    mobileDragHandle.setPointerCapture(e.pointerId);
    document.body.style.userSelect = 'none';
  });
  mobileDragHandle.addEventListener('pointermove', (e) => {
    if (!mobileResizing) return;
    const vh = window.innerHeight;
    const pct = Math.max(8, Math.min(70, (e.clientY / vh) * 100));
    appEl.style.gridTemplateRows = pct + 'vh auto 1fr';
  });
  mobileDragHandle.addEventListener('pointerup', () => {
    mobileResizing = false;
    mobileResizePointerId = null;
    document.body.style.userSelect = '';
  });
  mobileDragHandle.addEventListener('pointercancel', () => {
    mobileResizing = false;
    mobileResizePointerId = null;
    document.body.style.userSelect = '';
  });

  // Canvas panel always open (no collapse toggle)

  // Shared mic toggle logic
  function toggleMic() {
    const headerBtn = document.getElementById('canvas-mic-btn');
    const panelToggle = document.getElementById('voice-mic-toggle');
    if (_micCaptionEntry && mediaInputs.includes(_micCaptionEntry)) {
      // Stop mic
      removeMedia(_micCaptionEntry.id);
      headerBtn.classList.remove('active');
      if (panelToggle) panelToggle.classList.remove('active');
      _voiceDecayEnabled = false;
      const textLayer = getLayer('text');
      if (textLayer) { textLayer.opacity = 1.0; textLayer._voiceGlitch = 0.0; }
    } else {
      // Start mic + enable voice decay
      startMicCaptions();
      headerBtn.classList.add('active');
      if (panelToggle) panelToggle.classList.add('active');
      _voiceDecayEnabled = true;
    }
  }

  // Canvas Mic button — toggle voice input + auto-enable voice decay
  document.getElementById('canvas-mic-btn').addEventListener('click', toggleMic);

  // Voice panel Mic toggle — mirrors header button
  document.getElementById('voice-mic-toggle').addEventListener('click', toggleMic);

  // Export hub actions
  function exportAction(action) {
    if (action === 'window') {
      if (projectionWindow && !projectionWindow.closed) {
        projectionWindow.close();
        projectionWindow = null; projectionCtx = null; projectionCanvas = null;
      } else {
        projectionWindow = window.open('', 'ShaderClaw Projection',
          `width=${glCanvas.width},height=${glCanvas.height},menubar=no,toolbar=no,location=no,status=no`);
        projectionWindow.document.title = 'ShaderClaw';
        projectionWindow.document.body.style.cssText = 'margin:0;background:#000;overflow:hidden;cursor:none';
        projectionCanvas = projectionWindow.document.createElement('canvas');
        projectionCanvas.width = glCanvas.width;
        projectionCanvas.height = glCanvas.height;
        projectionCanvas.style.cssText = 'width:100vw;height:100vh;object-fit:contain;display:block';
        projectionWindow.document.body.appendChild(projectionCanvas);
        projectionCtx = projectionCanvas.getContext('2d');
        projectionWindow.addEventListener('beforeunload', () => {
          projectionWindow = null; projectionCtx = null; projectionCanvas = null;
        });
      }
    } else if (action === 'screenshot') {
      glCanvas.toBlob(blob => {
        const a = document.createElement('a');
        a.href = URL.createObjectURL(blob);
        a.download = 'shaderclaw-' + Date.now() + '.png';
        a.click();
        URL.revokeObjectURL(a.href);
      }, 'image/png');
    } else if (action === 'gif') {
      console.log('GIF export — coming soon');
    } else if (action === 'video') {
      console.log('Video export — coming soon');
    } else if (action === 'ndi') {
      toggleNdiSend();
    } else if (action === 'copy') {
      navigator.clipboard.writeText(editor.getValue()).then(() => {
        console.log('Shader code copied');
      });
    } else if (action === 'download') {
      const blob = new Blob([editor.getValue()], { type: 'text/plain' });
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = 'shader-' + Date.now() + '.fs';
      a.click();
      URL.revokeObjectURL(a.href);
    }
  }

  // Export hub popup
  const exportHub = document.getElementById('export-hub');
  document.getElementById('export-hub-btn').addEventListener('click', (e) => {
    e.stopPropagation();
    exportHub.classList.toggle('show');
  });
  exportHub.addEventListener('click', (e) => {
    const tile = e.target.closest('[data-action]');
    if (!tile) return;
    exportAction(tile.dataset.action);
    exportHub.classList.remove('show');
  });
  // Close on outside click
  document.addEventListener('click', (e) => {
    if (exportHub.classList.contains('show') && !exportHub.contains(e.target) && e.target.id !== 'export-hub-btn') {
      exportHub.classList.remove('show');
    }
  });

  // Background source select
  const bgSelect = document.getElementById('canvas-bg-select');
  const bgColorRow = document.getElementById('bg-color-row');
  const bgShaderRow = document.getElementById('bg-shader-row');
  const bgColorPicker = document.getElementById('bg-color-picker');
  const bgShaderSelect = document.getElementById('bg-shader-select');
  const bgImageInput = document.getElementById('bg-image-input');
  const bgVideoInput = document.getElementById('bg-video-input');

  function createBgTexture() {
    const gl = isfRenderer.gl;
    const tex = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, tex);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, new Uint8Array([0,0,0,255]));
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    return tex;
  }

  function cleanupBgMedia() {
    // Stop NDI receive if it was used as background
    if (canvasBg._isNdiBg) {
      if (_ndiWs && _ndiWs.readyState === WebSocket.OPEN) {
        ndiRequest(_ndiWs, 'ndi_receive_stop', {}).catch(() => {});
      }
      ndiReceiveEntry = null;
      ndiReceiveCanvas = null;
      ndiReceiveCtx = null;
      canvasBg._isNdiBg = false;
    }
    if (canvasBg.videoEl) {
      if (canvasBg.videoEl.pause) canvasBg.videoEl.pause();
      if (canvasBg.videoEl.srcObject) {
        canvasBg.videoEl.srcObject.getTracks().forEach(t => t.stop());
      }
      if (canvasBg.videoEl.remove) canvasBg.videoEl.remove();
      canvasBg.videoEl = null;
    }
    if (canvasBg.shaderLayer) {
      canvasBg.shaderLayer = null;
      canvasBg.shaderFBO = null;
    }
  }

  // Populate bg shader select from manifest
  isfShaders.forEach(item => {
    const opt = document.createElement('option');
    opt.value = JSON.stringify({ folder: item.folder || 'shaders', file: item.file });
    opt.textContent = item.title;
    bgShaderSelect.appendChild(opt);
  });

  bgSelect.addEventListener('change', async () => {
    const val = bgSelect.value;
    bgColorRow.style.display = 'none';
    bgShaderRow.style.display = 'none';
    cleanupBgMedia();

    switch (val) {
      case 'none':
        canvasBg.mode = 'none';
        break;
      case 'transparent':
        canvasBg.mode = 'transparent';
        break;
      case 'color':
        canvasBg.mode = 'color';
        bgColorRow.style.display = '';
        // Parse current picker value
        const hex = bgColorPicker.value;
        canvasBg.color = [
          parseInt(hex.slice(1,3), 16) / 255,
          parseInt(hex.slice(3,5), 16) / 255,
          parseInt(hex.slice(5,7), 16) / 255
        ];
        break;
      case 'image':
        bgImageInput.click();
        break;
      case 'video':
        bgVideoInput.click();
        break;
      case 'shader':
        canvasBg.mode = 'shader';
        bgShaderRow.style.display = '';
        // Load currently selected shader if any
        if (bgShaderSelect.value) {
          await loadBgShader(bgShaderSelect.value);
        }
        break;
      case 'webcam':
        try {
          const stream = await navigator.mediaDevices.getUserMedia({ video: true, audio: false });
          const video = document.createElement('video');
          video.muted = true;
          video.playsInline = true;
          video.style.cssText = 'position:fixed;top:-9999px;width:1px;height:1px;opacity:0;pointer-events:none';
          document.body.appendChild(video);
          video.srcObject = stream;
          await new Promise((res, rej) => { video.onloadeddata = res; video.onerror = rej; });
          await video.play();
          canvasBg.videoEl = video;
          if (!canvasBg.texture) canvasBg.texture = createBgTexture();
          const gl = isfRenderer.gl;
          gl.bindTexture(gl.TEXTURE_2D, canvasBg.texture);
          gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, video);
          canvasBg.mode = 'webcam';
        } catch (e) {
          console.warn('Webcam failed:', e);
          bgSelect.value = 'none';
          canvasBg.mode = 'none';
        }
        break;
      case 'ndi':
        // Open NDI source picker, then use selected source as background
        if (!_ndiWs || _ndiWs.readyState !== WebSocket.OPEN) {
          console.warn('NDI: WebSocket not connected');
          bgSelect.value = 'none';
          canvasBg.mode = 'none';
          break;
        }
        canvasBg._ndiBgPending = true;
        ndiPicker.classList.add('visible');
        // Override the picker click to route to background instead of media list
        const origHandler = ndiPicker._bgOverride;
        ndiPicker._bgOverride = async (sourceName) => {
          ndiPicker._bgOverride = null;
          canvasBg._ndiBgPending = false;
          try {
            // Start NDI receive
            await ndiRequest(_ndiWs, 'ndi_receive_start', { sourceName });
            // Set up canvas for frame reception
            ndiReceiveCanvas = document.createElement('canvas');
            ndiReceiveCanvas.width = 1920;
            ndiReceiveCanvas.height = 1080;
            ndiReceiveCtx = ndiReceiveCanvas.getContext('2d');
            ndiReceiveCtx.fillStyle = '#000';
            ndiReceiveCtx.fillRect(0, 0, 1920, 1080);
            // Create bg texture
            if (!canvasBg.texture) canvasBg.texture = createBgTexture();
            canvasBg.videoEl = ndiReceiveCanvas; // treat canvas as "video" source
            canvasBg._isNdiBg = true;
            canvasBg.mode = 'ndi';
            // Create a synthetic ndiReceiveEntry so handleNdiVideoFrame updates the canvas
            const id = ++mediaIdCounter;
            ndiReceiveEntry = {
              id,
              name: 'NDI BG: ' + sourceName,
              type: 'video',
              element: ndiReceiveCanvas,
              glTexture: canvasBg.texture,
              threeTexture: null,
              threeModel: null,
              _isNdi: true,
              _isBgOnly: true,
            };
          } catch (e) {
            console.warn('NDI background failed:', e);
            bgSelect.value = 'none';
            canvasBg.mode = 'none';
          }
        };
        break;
    }
  });

  bgColorPicker.addEventListener('input', () => {
    const hex = bgColorPicker.value;
    canvasBg.color = [
      parseInt(hex.slice(1,3), 16) / 255,
      parseInt(hex.slice(3,5), 16) / 255,
      parseInt(hex.slice(5,7), 16) / 255
    ];
  });

  // Voice decay controls (decay auto-enables with mic)
  const voiceDecaySlider = document.getElementById('voice-decay-slider');
  const voiceDecayVal = document.getElementById('voice-decay-val');
  voiceDecaySlider.addEventListener('input', () => {
    _voiceDecaySeconds = parseFloat(voiceDecaySlider.value);
    voiceDecayVal.textContent = _voiceDecaySeconds.toFixed(2) + 's';
  });

  // Prominent MSG input — syncs with the text layer's msg input
  const textMsgInput = document.getElementById('text-msg-input');
  textMsgInput.addEventListener('input', () => {
    const textLayer = getLayer('text');
    if (!textLayer) return;
    const textInputs = (textLayer.inputs || []).filter(inp => inp.TYPE === 'text');
    if (textInputs.length === 0) return;
    const inp = textInputs[0];
    const maxLen = inp.MAX_LENGTH || 12;
    const str = textMsgInput.value.toUpperCase();
    function charToCode(ch) {
      if (!ch || ch === ' ') return 26;
      const c = ch.toUpperCase().charCodeAt(0) - 65;
      return (c >= 0 && c <= 25) ? c : 26;
    }
    for (let i = 0; i < maxLen; i++) {
      textLayer.inputValues[inp.NAME + '_' + i] = charToCode(str[i]);
    }
    textLayer.inputValues[inp.NAME + '_len'] = str.replace(/\s+$/, '').length;
    // Sync the params panel text field too
    const paramsField = document.querySelector('.layer-params[data-layer="text"] input[type="text"]');
    if (paramsField) paramsField.value = str;
  });

  bgImageInput.addEventListener('change', (e) => {
    const file = e.target.files[0];
    if (!file) { bgSelect.value = 'none'; canvasBg.mode = 'none'; return; }
    const img = new Image();
    img.onload = () => {
      if (!canvasBg.texture) canvasBg.texture = createBgTexture();
      const gl = isfRenderer.gl;
      gl.bindTexture(gl.TEXTURE_2D, canvasBg.texture);
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, img);
      canvasBg.mode = 'image';
      canvasBg.imageEl = img; // keep ref for context restore
    };
    img.src = URL.createObjectURL(file);
    bgImageInput.value = '';
  });

  bgVideoInput.addEventListener('change', (e) => {
    const file = e.target.files[0];
    if (!file) { bgSelect.value = 'none'; canvasBg.mode = 'none'; return; }
    const video = document.createElement('video');
    video.muted = true;
    video.loop = true;
    video.playsInline = true;
    video.style.cssText = 'position:fixed;top:-9999px;width:1px;height:1px;opacity:0;pointer-events:none';
    document.body.appendChild(video);
    video.src = URL.createObjectURL(file);
    video.onloadeddata = async () => {
      await video.play();
      canvasBg.videoEl = video;
      if (!canvasBg.texture) canvasBg.texture = createBgTexture();
      const gl = isfRenderer.gl;
      gl.bindTexture(gl.TEXTURE_2D, canvasBg.texture);
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, video);
      canvasBg.mode = 'video';
    };
    bgVideoInput.value = '';
  });

  async function loadBgShader(jsonVal) {
    try {
      const { folder, file } = JSON.parse(jsonVal);
      const r = await fetch((folder || 'shaders') + '/' + file);
      const src = await r.text();
      const { frag, parsed } = buildFragmentShader(src);

      // Create pseudo-layer with its own FBO
      if (!canvasBg.shaderFBO) {
        canvasBg.shaderFBO = isfRenderer.createFBO(1920, 1080);
      }
      const pseudoLayer = {
        id: '_bg', type: 'shader', visible: true, opacity: 1.0, blendMode: 'normal',
        program: null, uniformLocs: {}, fbo: canvasBg.shaderFBO, textures: {},
        inputs: parsed.inputs || [], inputValues: {}, transparentBg: false
      };
      pseudoLayer._isfSource = src; // store for context restore
      const result = isfRenderer.compileForLayer(pseudoLayer, VERT_SHADER, frag);
      if (result.ok) {
        canvasBg.shaderLayer = pseudoLayer;
        canvasBg.texture = canvasBg.shaderFBO.texture;
        canvasBg.mode = 'shader';
      }
    } catch (e) {
      console.warn('Failed to load bg shader:', e);
    }
  }

  bgShaderSelect.addEventListener('change', async () => {
    if (bgShaderSelect.value) {
      await loadBgShader(bgShaderSelect.value);
    }
  });

  // --- INPUTS Panel (Media) ---
  const mediaListContainer = document.getElementById('media-list');

  // File inputs for each type
  const imageFileInput = document.getElementById('image-file-input');
  const videoFileInput = document.getElementById('video-file-input');
  const modelFileInput = document.getElementById('model-file-input');
  const soundFileInput = document.getElementById('sound-file-input');
  const vectorFileInput = document.getElementById('vector-file-input');

  function wireFileInput(input) {
    input.addEventListener('change', async (e) => {
      for (const file of e.target.files) {
        await addMediaFromFile(file);
      }
      input.value = '';
    });
  }
  wireFileInput(imageFileInput);
  wireFileInput(videoFileInput);
  wireFileInput(modelFileInput);
  wireFileInput(soundFileInput);
  wireFileInput(vectorFileInput);

  // Tile click handlers
  document.getElementById('tile-image').addEventListener('click', () => imageFileInput.click());
  document.getElementById('tile-video').addEventListener('click', () => videoFileInput.click());
  document.getElementById('tile-model').addEventListener('click', () => modelFileInput.click());
  document.getElementById('tile-sound').addEventListener('click', () => soundFileInput.click());

  document.getElementById('tile-webcam').addEventListener('click', async () => {
    try { await addMediaFromWebcam(); }
    catch (e) { console.warn('Webcam access denied:', e.message); }
  });

  // MediaPipe tile — mode selection then init
  document.getElementById('tile-mediapipe').addEventListener('click', async () => {
    if (mediaPipeMgr.active) {
      // Already active — show info
      alert('MediaPipe already active: ' + mediaPipeMgr.getLabel());
      return;
    }

    // Simple mode selection
    const modes = { hand: true, face: false, pose: false, segment: false };
    const choice = prompt('MediaPipe modes (comma-separated):\nhand, face, pose, segment\n\nDefault: hand', 'hand');
    if (!choice) return;
    choice.split(',').map(s => s.trim().toLowerCase()).forEach(m => {
      if (m === 'hand') modes.hand = true;
      if (m === 'face') modes.face = true;
      if (m === 'pose') modes.pose = true;
      if (m === 'segment') modes.segment = true;
    });

    // Auto-enable webcam if not already active
    const hasWebcam = mediaInputs.some(m => m.name === 'Webcam' && m.type === 'video');
    if (!hasWebcam) {
      try { await addMediaFromWebcam(); }
      catch (e) { console.warn('Webcam needed for MediaPipe:', e.message); return; }
    }

    // Show loading indicator
    const mpLoading = document.createElement('div');
    mpLoading.className = 'mp-loading';
    mpLoading.innerHTML = '<div class="spinner"></div> Loading MediaPipe models...';
    document.getElementById('media-list').appendChild(mpLoading);

    try {
      await mediaPipeMgr.init(modes);
      mpLoading.remove();
      // Add to media list display
      const id = ++mediaIdCounter;
      const entry = { id, name: mediaPipeMgr.getLabel(), type: 'mediapipe', element: null, glTexture: null, threeTexture: null, threeModel: null, _isMediaPipe: true };
      mediaInputs.push(entry);
      renderMediaList();
    } catch (e) {
      mpLoading.remove();
      console.warn('MediaPipe init failed:', e.message);
      alert('MediaPipe failed to load: ' + e.message);
    }
  });

  // NDI Source Picker
  const ndiPicker = document.getElementById('ndi-source-picker');
  const ndiPickerBody = document.getElementById('ndi-picker-body');

  document.getElementById('ndi-picker-close').addEventListener('click', () => {
    ndiPicker.classList.remove('visible');
    if (ndiPicker._bgOverride) {
      ndiPicker._bgOverride = null;
      bgSelect.value = 'none';
      canvasBg.mode = 'none';
    }
  });

  ndiPicker.addEventListener('click', (e) => {
    if (e.target === ndiPicker) {
      ndiPicker.classList.remove('visible');
      if (ndiPicker._bgOverride) {
        ndiPicker._bgOverride = null;
        bgSelect.value = 'none';
        canvasBg.mode = 'none';
      }
    }
  });

  async function refreshNdiSources(ws) {
    ndiPickerBody.innerHTML = '<div style="padding:16px;color:var(--text-dim);font-size:11px;text-align:center">Searching...</div>';
    try {
      const resp = await ndiRequest(ws, 'ndi_find_sources');
      const sources = resp.sources || [];
      ndiPickerBody.innerHTML = '';
      if (sources.length === 0) {
        ndiPickerBody.innerHTML = '<div style="padding:16px;color:var(--text-dim);font-size:11px;text-align:center">No NDI sources found.<br>Make sure NDI sources are running on your network.</div>';
        return;
      }
      sources.forEach(src => {
        const item = document.createElement('div');
        item.className = 'ndi-source-item';
        item.innerHTML = `<span class="ndi-dot"></span><span class="ndi-src-name">${src.name}</span><span class="ndi-src-addr">${src.urlAddress || ''}</span>`;
        item.addEventListener('click', async () => {
          ndiPicker.classList.remove('visible');
          // If background select triggered the picker, route there instead
          if (ndiPicker._bgOverride) {
            try { await ndiPicker._bgOverride(src.name); } catch (e) { console.warn('NDI bg failed:', e); }
            return;
          }
          try {
            await addNdiReceiveEntry(src.name, ws);
          } catch (e) {
            console.warn('NDI receive failed:', e);
          }
        });
        ndiPickerBody.appendChild(item);
      });
    } catch (e) {
      ndiPickerBody.innerHTML = `<div style="padding:16px;color:var(--accent);font-size:11px;text-align:center">Error: ${e.message}</div>`;
    }
  }

  async function addNdiReceiveEntry(sourceName, ws) {
    if (ndiReceiveEntry) {
      removeMedia(ndiReceiveEntry.id);
      ndiReceiveEntry = null;
    }

    await ndiRequest(ws, 'ndi_receive_start', { sourceName });

    ndiReceiveCanvas = document.createElement('canvas');
    ndiReceiveCanvas.width = 1920;
    ndiReceiveCanvas.height = 1080;
    ndiReceiveCtx = ndiReceiveCanvas.getContext('2d');
    ndiReceiveCtx.fillStyle = '#000';
    ndiReceiveCtx.fillRect(0, 0, 1920, 1080);

    const id = ++mediaIdCounter;
    const entry = {
      id,
      name: 'NDI: ' + sourceName,
      type: 'video',
      element: ndiReceiveCanvas,
      glTexture: createGLTexture(isfRenderer.gl, ndiReceiveCanvas),
      threeTexture: new THREE.CanvasTexture(ndiReceiveCanvas),
      threeModel: null,
      _isNdi: true,
    };
    entry.threeTexture.needsUpdate = true;
    ndiReceiveEntry = entry;

    mediaInputs.push(entry);
    renderMediaList();
    autoBindTextures();
    return entry;
  }

  // NDI Send (triggered from Export dropdown)
  async function toggleNdiSend() {
    if (!_ndiWs || _ndiWs.readyState !== WebSocket.OPEN) return;
    if (ndiSendingActive) {
      stopNdiSend();
      await ndiRequest(_ndiWs, 'ndi_send_stop');
    } else {
      await ndiRequest(_ndiWs, 'ndi_send_start', { name: 'ShaderClaw', width: glCanvas.width, height: glCanvas.height });
      startNdiSend(_ndiWs, glCanvas);
    }
  }

  function renderMediaList() {
    mediaListContainer.innerHTML = '';
    mediaInputs.forEach(media => {
      const item = document.createElement('div');
      item.className = 'media-item';

      const icon = document.createElement('span');
      icon.className = 'media-icon';
      icon.textContent = mediaTypeIcon(media.type, media.name);

      const name = document.createElement('span');
      name.className = 'media-name';
      name.textContent = media.name;

      item.appendChild(icon);
      item.appendChild(name);

      // Webcam: H/V flip toggles
      if (media._webcamFlip !== undefined) {
        const flipH = document.createElement('button');
        flipH.className = 'flip-toggle' + (media._webcamFlip ? ' active' : '');
        flipH.textContent = 'H';
        flipH.title = 'Mirror horizontally';
        flipH.addEventListener('click', (e) => {
          e.stopPropagation();
          media._webcamFlip = !media._webcamFlip;
          flipH.classList.toggle('active', media._webcamFlip);
          if (media.threeTexture) {
            media.threeTexture.wrapS = media._webcamFlip ? THREE.RepeatWrapping : THREE.ClampToEdgeWrapping;
            media.threeTexture.repeat.x = media._webcamFlip ? -1 : 1;
            media.threeTexture.offset.x = media._webcamFlip ? 1 : 0;
            media.threeTexture.needsUpdate = true;
          }
          autoBindTextures();
        });
        const flipV = document.createElement('button');
        flipV.className = 'flip-toggle' + (media._webcamFlipV ? ' active' : '');
        flipV.textContent = 'V';
        flipV.title = 'Mirror vertically';
        flipV.addEventListener('click', (e) => {
          e.stopPropagation();
          media._webcamFlipV = !media._webcamFlipV;
          flipV.classList.toggle('active', media._webcamFlipV);
          if (media.threeTexture) {
            media.threeTexture.wrapT = media._webcamFlipV ? THREE.RepeatWrapping : THREE.ClampToEdgeWrapping;
            media.threeTexture.repeat.y = media._webcamFlipV ? -1 : 1;
            media.threeTexture.offset.y = media._webcamFlipV ? 1 : 0;
            media.threeTexture.needsUpdate = true;
          }
          autoBindTextures();
        });
        item.appendChild(flipH);
        item.appendChild(flipV);
      }

      // Audio: play/pause toggle + level bar
      if (media.type === 'audio') {
        const toggle = document.createElement('button');
        toggle.className = 'audio-toggle';
        toggle.textContent = (media.element && !media.element.paused) ? '\u23F8' : '\u25B6';
        toggle.title = 'Play/Pause';
        toggle.addEventListener('click', (e) => {
          e.stopPropagation();
          if (media.element) {
            if (media.element.paused) {
              if (audioCtx && audioCtx.state === 'suspended') audioCtx.resume();
              media.element.play().catch(() => {});
              toggle.textContent = '\u23F8';
            } else {
              media.element.pause();
              toggle.textContent = '\u25B6';
            }
          }
        });
        item.appendChild(toggle);

        const bar = document.createElement('div');
        bar.className = 'audio-bar';
        const fill = document.createElement('div');
        fill.className = 'audio-bar-fill';
        fill.dataset.audioId = media.id;
        bar.appendChild(fill);
        item.appendChild(bar);
      }

      const del = document.createElement('button');
      del.className = 'media-delete';
      del.textContent = '\u00D7';
      del.title = 'Remove';
      del.addEventListener('click', (e) => {
        e.stopPropagation();
        removeMedia(media.id);
      });

      item.appendChild(del);
      mediaListContainer.appendChild(item);
    });

    // Refresh all image-input dropdowns so new media (NDI, webcam, etc.) appears
    document.querySelectorAll('.image-input-select').forEach(sel => {
      if (sel._refreshOptions) sel._refreshOptions();
    });
  }

  function autoBindTextures(targetLayerId) {
    const compatibleMedia = mediaInputs.filter(m => m.type === 'image' || m.type === 'video' || m.type === 'svg');

    // Bind textures for each ISF layer
    layers.forEach(layer => {
      if (layer.type !== 'shader') return;
      if (targetLayerId && layer.id !== targetLayerId) return;
      layer.textures = {};
      const imageInputs = (layer.inputs || []).filter(inp => inp.TYPE === 'image');
      imageInputs.forEach((inp, i) => {
        let selectedId = layer.inputValues[inp.NAME];
        let media = null;
        if (selectedId) media = mediaInputs.find(m => String(m.id) === String(selectedId));
        if (!media && i < compatibleMedia.length) {
          media = compatibleMedia[i];
          layer.inputValues[inp.NAME] = media.id;
        }
        if (media && media.glTexture) {
          layer.textures[inp.NAME] = {
            glTexture: media.glTexture,
            isVideo: media.type === 'video',
            element: media.element,
            flipH: !!media._webcamFlip,
            flipV: !!media._webcamFlipV,
            _isNdi: !!media._isNdi,
          };
        }
      });
    });

    // Update SceneRenderer media
    sceneRenderer.media = mediaInputs.map(m => ({
      id: m.id, name: m.name, type: m.type,
      threeTexture: m.threeTexture, threeModel: m.threeModel,
    }));
  }

  async function addMediaFromFile(file) {
    const type = detectMediaType(file);
    const id = ++mediaIdCounter;
    const entry = { id, name: file.name, type, element: null, glTexture: null, threeTexture: null, threeModel: null };

    if (type === 'image') {
      const img = new Image();
      const url = URL.createObjectURL(file);
      await new Promise((resolve, reject) => {
        img.onload = resolve;
        img.onerror = reject;
        img.src = url;
      });
      entry.element = img;
      entry.glTexture = createGLTexture(isfRenderer.gl, img);
      const threeTex = new THREE.Texture(img);
      threeTex.needsUpdate = true;
      entry.threeTexture = threeTex;

    } else if (type === 'video') {
      const video = document.createElement('video');
      video.muted = true;
      video.loop = true;
      video.playsInline = true;
      video.preload = 'auto';
      // Keep video in the DOM so Chrome doesn't GC its decode pipeline
      video.style.cssText = 'position:fixed;top:-9999px;width:1px;height:1px;opacity:0;pointer-events:none';
      document.body.appendChild(video);
      // Auto-recover from unexpected pauses and stalls
      video.addEventListener('pause', () => {
        if (video.loop && !video.ended) video.play().catch(() => {});
      });
      video.addEventListener('stalled', () => { video.play().catch(() => {}); });
      // Set up listeners before assigning src to avoid race conditions
      const loaded = new Promise((resolve, reject) => {
        video.onloadeddata = () => resolve();
        video.onerror = () => reject(new Error('Video format not supported: ' + file.name));
      });
      video.src = URL.createObjectURL(file);
      video.load();
      await loaded;
      try {
        await video.play();
      } catch (e) {
        console.warn('Video autoplay blocked for', file.name, '— will retry on interaction');
        const retryPlay = () => {
          video.play().catch(() => {});
          document.removeEventListener('click', retryPlay);
        };
        document.addEventListener('click', retryPlay, { once: true });
      }
      entry.element = video;
      entry.glTexture = createGLTexture(isfRenderer.gl, video);
      const threeTex = new THREE.VideoTexture(video);
      threeTex.needsUpdate = true;
      entry.threeTexture = threeTex;

    } else if (type === 'model') {
      await loadDeferredScripts(); // ensure model loaders are ready
      const ext = file.name.split('.').pop().toLowerCase();
      const url = URL.createObjectURL(file);

      if (ext === 'stl') {
        const loader = new THREE.STLLoader();
        const geometry = await new Promise((resolve, reject) => {
          loader.load(url, resolve, undefined, reject);
        });
        geometry.computeVertexNormals();
        const mat = new THREE.MeshStandardMaterial({ color: 0xcccccc, roughness: 0.4, metalness: 0.1 });
        const mesh = new THREE.Mesh(geometry, mat);
        const group = new THREE.Group();
        group.add(mesh);
        entry.threeModel = group;

      } else if (ext === 'obj') {
        const loader = new THREE.OBJLoader();
        const group = await new Promise((resolve, reject) => {
          loader.load(url, resolve, undefined, reject);
        });
        entry.threeModel = group;

      } else if (ext === 'fbx') {
        if (window.fflate) THREE.fflate = window.fflate;
        const loader = new THREE.FBXLoader();
        const group = await new Promise((resolve, reject) => {
          loader.load(url, resolve, undefined, reject);
        });
        entry.threeModel = group;

      } else {
        // GLTF/GLB
        if (typeof THREE.GLTFLoader === 'undefined') {
          console.warn('GLTFLoader not available');
          return null;
        }
        const loader = new THREE.GLTFLoader();
        const gltf = await new Promise((resolve, reject) => {
          loader.load(url, resolve, undefined, reject);
        });
        entry.threeModel = gltf.scene;
      }

    } else if (type === 'audio') {
      // Audio-reactive sound
      if (!audioCtx) {
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        audioAnalyser = audioCtx.createAnalyser();
        audioAnalyser.fftSize = 256;
        audioAnalyser.smoothingTimeConstant = 0.8;
        audioAnalyser.connect(audioCtx.destination);
        audioDataArray = new Uint8Array(audioAnalyser.frequencyBinCount); // 128 bins
      }

      // Disconnect previous audio source
      if (activeAudioEntry && activeAudioEntry._sourceNode) {
        try { activeAudioEntry._sourceNode.disconnect(); } catch(e) {}
        if (activeAudioEntry.element) activeAudioEntry.element.pause();
      }

      const audio = document.createElement('audio');
      audio.loop = true;
      audio.preload = 'auto';
      audio.crossOrigin = 'anonymous';
      audio.style.cssText = 'position:fixed;top:-9999px;width:1px;height:1px;opacity:0;pointer-events:none';
      document.body.appendChild(audio);

      const loaded = new Promise((resolve, reject) => {
        audio.oncanplaythrough = () => resolve();
        audio.onerror = () => reject(new Error('Audio format not supported: ' + file.name));
      });
      audio.src = URL.createObjectURL(file);
      audio.load();
      await loaded;

      if (audioCtx.state === 'suspended') await audioCtx.resume();
      const sourceNode = audioCtx.createMediaElementSource(audio);
      sourceNode.connect(audioAnalyser);

      entry.element = audio;
      entry._sourceNode = sourceNode;
      activeAudioEntry = entry;

      try { await audio.play(); }
      catch (e) {
        console.warn('Audio autoplay blocked — retry on interaction');
        const retryPlay = () => { audio.play().catch(() => {}); };
        document.addEventListener('click', retryPlay, { once: true });
      }

    } else if (type === 'svg') {
      // SVG — render to canvas texture
      const text = await file.text();
      const blob = new Blob([text], { type: 'image/svg+xml;charset=utf-8' });
      const url = URL.createObjectURL(blob);
      const img = new Image();
      await new Promise((resolve, reject) => {
        img.onload = resolve;
        img.onerror = reject;
        img.src = url;
      });
      const canvas = document.createElement('canvas');
      canvas.width = 2048;
      canvas.height = 2048;
      const ctx = canvas.getContext('2d');
      ctx.drawImage(img, 0, 0, 2048, 2048);
      URL.revokeObjectURL(url);

      entry.element = canvas;
      entry.glTexture = createGLTexture(isfRenderer.gl, canvas);
      const threeTex = new THREE.CanvasTexture(canvas);
      threeTex.needsUpdate = true;
      entry.threeTexture = threeTex;
    }

    mediaInputs.push(entry);
    renderMediaList();
    autoBindTextures();

    // Auto-switch to "Custom" shape when a model is added
    if (type === 'model') {
      const sceneLayer = getLayer('scene');
      sceneLayer.inputValues['shape'] = 6;
      sceneRenderer.inputValues = sceneLayer.inputValues;
      window.shaderClaw.updateControlUI('shape', 6, 'scene');
    }

    return entry;
  }

  async function addMediaFromWebcam() {
    const stream = await navigator.mediaDevices.getUserMedia({ video: true, audio: false });
    const id = ++mediaIdCounter;
    const entry = { id, name: 'Webcam', type: 'video', element: null, glTexture: null, threeTexture: null, threeModel: null, stream };

    const video = document.createElement('video');
    video.muted = true;
    video.playsInline = true;
    video.style.cssText = 'position:fixed;top:-9999px;width:1px;height:1px;opacity:0;pointer-events:none';
    document.body.appendChild(video);
    video.addEventListener('pause', () => { video.play().catch(() => {}); });
    video.addEventListener('stalled', () => { video.play().catch(() => {}); });

    const loaded = new Promise((resolve, reject) => {
      video.onloadeddata = () => resolve();
      video.onerror = () => reject(new Error('Webcam video failed'));
    });
    video.srcObject = stream;
    await loaded;
    await video.play();

    entry.element = video;
    entry.glTexture = createGLTexture(isfRenderer.gl, video);
    const threeTex = new THREE.VideoTexture(video);
    // Flip vertically only (GL Y-axis convention); no horizontal mirror
    threeTex.wrapS = THREE.ClampToEdgeWrapping;
    threeTex.wrapT = THREE.RepeatWrapping;
    threeTex.repeat.x = 1;
    threeTex.repeat.y = -1;
    threeTex.offset.x = 0;
    threeTex.offset.y = 1;
    threeTex.needsUpdate = true;
    entry.threeTexture = threeTex;
    entry._webcamFlip = false; // No horizontal mirror by default
    entry._webcamFlipV = true; // Vertical flip for GL coordinate system

    mediaInputs.push(entry);
    renderMediaList();
    autoBindTextures();
    return entry;
  }

  async function addMediaFromDataUrl(name, dataUrl) {
    const resp = await fetch(dataUrl);
    const blob = await resp.blob();
    const file = new File([blob], name, { type: blob.type });
    return addMediaFromFile(file);
  }

  // 3D Text — generates TextGeometry mesh from user string
  async function addText3D(text) {
    await loadDeferredScripts(); // ensure FontLoader + TextGeometry are ready
    const fontLoader = new THREE.FontLoader();
    const fontUrl = 'https://cdn.jsdelivr.net/npm/three@0.128.0/examples/fonts/helvetiker_regular.typeface.json';
    const font = await new Promise((resolve, reject) => {
      fontLoader.load(fontUrl, resolve, undefined, reject);
    });
    const geometry = new THREE.TextGeometry(text, {
      font: font,
      size: 0.5,
      height: 0.15,
      curveSegments: 12,
      bevelEnabled: true,
      bevelThickness: 0.02,
      bevelSize: 0.01,
      bevelSegments: 3
    });
    geometry.computeBoundingBox();
    const center = geometry.boundingBox.getCenter(new THREE.Vector3());
    geometry.translate(-center.x, -center.y, -center.z);

    const mat = new THREE.MeshStandardMaterial({ color: 0xcccccc, roughness: 0.3, metalness: 0.15 });
    const mesh = new THREE.Mesh(geometry, mat);
    const group = new THREE.Group();
    group.add(mesh);

    const id = ++mediaIdCounter;
    const entry = { id, name: '"' + text + '"', type: 'model', element: null, glTexture: null, threeTexture: null, threeModel: group };
    mediaInputs.push(entry);
    renderMediaList();
    autoBindTextures();

    const sceneLayer2 = getLayer('scene');
    sceneLayer2.inputValues['shape'] = 6;
    sceneRenderer.inputValues = sceneLayer2.inputValues;
    window.shaderClaw.updateControlUI('shape', 6, 'scene');
    return entry;
  }

  // Variable Font Text — renders text to canvas with animatable weight
  let _varFontEntry = null;
  let _varFontCanvas = null;
  let _varFontCtx = null;
  let _varFontText = '';
  let _varFontWeight = 400;
  let _varFontFamilyIdx = 0;

  function _renderVarFontCanvas() {
    if (!_varFontCtx || !_varFontText) return;
    const c = _varFontCanvas;
    const ctx = _varFontCtx;
    ctx.clearRect(0, 0, c.width, c.height);
    ctx.save();
    ctx.translate(0, c.height);
    ctx.scale(1, -1);
    const w = Math.round(_varFontWeight);
    const stack = _fontFamilies[_varFontFamilyIdx] || _fontFamilies[0];
    ctx.font = `${w} ${Math.round(c.height * 0.35)}px ${stack}`;
    ctx.fillStyle = '#ffffff';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(_varFontText, c.width / 2, c.height / 2);
    ctx.restore();
    // Update textures
    if (_varFontEntry) {
      if (_varFontEntry.glTexture) {
        const gl = isfRenderer.gl;
        gl.bindTexture(gl.TEXTURE_2D, _varFontEntry.glTexture);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, c);
      }
      if (_varFontEntry.threeTexture) {
        _varFontEntry.threeTexture.needsUpdate = true;
      }
    }
  }

  function addVariableFontText(text) {
    _varFontText = text;
    _varFontCanvas = document.createElement('canvas');
    _varFontCanvas.width = 2048;
    _varFontCanvas.height = 512;
    _varFontCtx = _varFontCanvas.getContext('2d');
    _renderVarFontCanvas();

    const id = ++mediaIdCounter;
    const entry = {
      id, name: 'VarFont: ' + text, type: 'image',
      element: _varFontCanvas, glTexture: createGLTexture(isfRenderer.gl, _varFontCanvas),
      threeTexture: new THREE.CanvasTexture(_varFontCanvas), threeModel: null,
      _isVarFont: true
    };
    entry.threeTexture.needsUpdate = true;
    _varFontEntry = entry;

    mediaInputs.push(entry);
    renderMediaList();
    autoBindTextures();
    return entry;
  }

  // Update variable font weight externally (called from ISF parameter or API)
  function setVarFontWeight(w) {
    _varFontWeight = Math.max(100, Math.min(900, w));
    _vfWeight = _varFontWeight; // Also update global var font texture weight
    _renderVarFontCanvas();
  }

  function setVarFontFamily(idx) {
    _varFontFamilyIdx = Math.round(idx) || 0;
    _renderVarFontCanvas();
  }

  // Mic Captions — real-time speech-to-text → canvas texture
  let _micCaptionEntry = null;
  let _micCaptionCanvas = null;
  let _micCaptionCtx = null;
  let _micCaptionText = '';
  let _micRecognition = null;
  let _voiceLastInputTime = 0;
  let _voiceDecaySeconds = 3.0;
  let _voiceDecayEnabled = false;

  function _renderMicCaptionCanvas() {
    if (!_micCaptionCtx) return;
    const c = _micCaptionCanvas;
    const ctx = _micCaptionCtx;
    ctx.clearRect(0, 0, c.width, c.height);
    ctx.save();
    ctx.translate(0, c.height);
    ctx.scale(1, -1);
    ctx.font = `500 ${Math.round(c.height * 0.18)}px "Inter", "Segoe UI", sans-serif`;
    ctx.fillStyle = '#ffffff';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    // Word-wrap for longer text
    const words = _micCaptionText.split(' ');
    const maxWidth = c.width * 0.9;
    const lines = [];
    let line = '';
    for (const word of words) {
      const test = line ? line + ' ' + word : word;
      if (ctx.measureText(test).width > maxWidth && line) {
        lines.push(line);
        line = word;
      } else {
        line = test;
      }
    }
    if (line) lines.push(line);
    const lineHeight = c.height * 0.22;
    const startY = c.height / 2 - ((lines.length - 1) * lineHeight) / 2;
    lines.forEach((l, i) => {
      ctx.fillText(l, c.width / 2, startY + i * lineHeight);
    });
    ctx.restore();
    // Update textures
    if (_micCaptionEntry) {
      if (_micCaptionEntry.glTexture) {
        const gl = isfRenderer.gl;
        gl.bindTexture(gl.TEXTURE_2D, _micCaptionEntry.glTexture);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, c);
      }
      if (_micCaptionEntry.threeTexture) {
        _micCaptionEntry.threeTexture.needsUpdate = true;
      }
    }
  }

  // Push mic transcription text into text-type ISF inputs on text layer
  function _pushMicTextToShader(text) {
    const textLayer = getLayer('text');
    if (!textLayer) return;
    const textInputs = (textLayer.inputs || []).filter(inp => inp.TYPE === 'text');
    if (textInputs.length === 0) return;

    function charToCode(ch) {
      if (!ch || ch === ' ') return 26;
      const c = ch.toUpperCase().charCodeAt(0) - 65;
      return (c >= 0 && c <= 25) ? c : 26;
    }

    for (const inp of textInputs) {
      const maxLen = inp.MAX_LENGTH || 12;
      const str = text.toUpperCase().slice(-maxLen);
      for (let i = 0; i < maxLen; i++) {
        textLayer.inputValues[inp.NAME + '_' + i] = charToCode(str[i]);
      }
      textLayer.inputValues[inp.NAME + '_len'] = str.replace(/\s+$/, '').length;

      // Update the text input field in the UI
      const container = document.querySelector('.layer-params[data-layer="text"]');
      if (container) {
        const rows = container.querySelectorAll('.control-row');
        for (const row of rows) {
          const label = row.querySelector('label');
          if (label && label.textContent === inp.NAME) {
            const field = row.querySelector('input[type="text"]');
            if (field) field.value = str;
            break;
          }
        }
      }
    }
  }

  function startMicCaptions() {
    const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
    if (!SpeechRecognition) {
      alert('Speech Recognition not supported in this browser. Use Chrome.');
      return;
    }

    _micCaptionCanvas = document.createElement('canvas');
    _micCaptionCanvas.width = 2048;
    _micCaptionCanvas.height = 512;
    _micCaptionCtx = _micCaptionCanvas.getContext('2d');
    _micCaptionText = '(listening...)';
    _renderMicCaptionCanvas();

    const id = ++mediaIdCounter;
    const entry = {
      id, name: 'Mic Captions', type: 'image',
      element: _micCaptionCanvas, glTexture: createGLTexture(isfRenderer.gl, _micCaptionCanvas),
      threeTexture: new THREE.CanvasTexture(_micCaptionCanvas), threeModel: null,
      _isMicCaption: true
    };
    entry.threeTexture.needsUpdate = true;
    _micCaptionEntry = entry;

    mediaInputs.push(entry);
    renderMediaList();
    autoBindTextures();

    // Start speech recognition
    _micRecognition = new SpeechRecognition();
    _micRecognition.continuous = true;
    _micRecognition.interimResults = true;

    _micRecognition.onresult = (event) => {
      let interim = '';
      let final = '';
      for (let i = event.resultIndex; i < event.results.length; i++) {
        if (event.results[i].isFinal) {
          final += event.results[i][0].transcript;
        } else {
          interim += event.results[i][0].transcript;
        }
      }
      _micCaptionText = (final || interim).trim() || '...';
      _renderMicCaptionCanvas();

      // Push transcription into any text-type ISF inputs (e.g. "msg" on the Text shader)
      _pushMicTextToShader(_micCaptionText);
      // Sync prominent MSG bar + voice transcript
      const msgBar = document.getElementById('text-msg-input');
      if (msgBar) msgBar.value = _micCaptionText.toUpperCase();
      const voiceTranscript = document.getElementById('voice-transcript');
      if (voiceTranscript) voiceTranscript.value = _micCaptionText.toUpperCase();
      _voiceLastInputTime = performance.now();
    };

    _micRecognition.onerror = (e) => {
      console.warn('Speech recognition error:', e.error);
      if (e.error === 'not-allowed') {
        _micCaptionText = '(mic access denied)';
        _renderMicCaptionCanvas();
      }
    };

    _micRecognition.onend = () => {
      // Auto-restart if still in media list
      if (_micCaptionEntry && mediaInputs.includes(_micCaptionEntry)) {
        try { _micRecognition.start(); } catch(e) {}
      }
    };

    _micRecognition.start();
    return entry;
  }

  // Audio-reactive per-frame update
  function removeMedia(id) {
    const idx = mediaInputs.findIndex(m => m.id === id);
    if (idx === -1) return;
    const entry = mediaInputs[idx];
    // Cleanup GL texture
    if (entry.glTexture) {
      isfRenderer.gl.deleteTexture(entry.glTexture);
    }
    // Cleanup THREE texture
    if (entry.threeTexture) {
      entry.threeTexture.dispose();
    }
    // Cleanup webcam stream
    if (entry.stream) {
      entry.stream.getTracks().forEach(t => t.stop());
    }
    // Cleanup video element (skip for NDI canvas elements)
    if (entry.type === 'video' && entry.element && !entry._isNdi) {
      entry.element.pause();
      if (entry.element.src) URL.revokeObjectURL(entry.element.src);
      entry.element.src = '';
      entry.element.load();
      if (entry.element.parentNode) entry.element.parentNode.removeChild(entry.element);
    }
    // Cleanup mic captions
    if (entry._isMicCaption && _micRecognition) {
      try { _micRecognition.stop(); } catch(e) {}
      _micRecognition = null;
      _micCaptionEntry = null;
      _micCaptionText = '';
    }
    // Cleanup variable font
    if (entry._isVarFont) {
      _varFontEntry = null;
      _varFontText = '';
    }
    // Cleanup audio element
    if (entry.type === 'audio') {
      if (entry._sourceNode) {
        try { entry._sourceNode.disconnect(); } catch(e) {}
      }
      if (entry.element) {
        entry.element.pause();
        if (entry.element.src) URL.revokeObjectURL(entry.element.src);
        entry.element.src = '';
        if (entry.element.parentNode) entry.element.parentNode.removeChild(entry.element);
      }
      if (activeAudioEntry === entry) {
        activeAudioEntry = null;
        audioLevel = audioBass = audioMid = audioHigh = 0;
      }
    }
    // If removing last model, revert scene shape to Cube
    const sceneLayer = getLayer('scene');
    if (entry.type === 'model' && sceneLayer.inputValues['shape'] === 6) {
      const hasOtherModel = mediaInputs.some((m, i) => i !== idx && m.type === 'model');
      if (!hasOtherModel) {
        sceneLayer.inputValues['shape'] = 0;
        sceneRenderer.inputValues = sceneLayer.inputValues;
        window.shaderClaw.updateControlUI('shape', 0, 'scene');
      }
    }
    // Cleanup MediaPipe
    if (entry._isMediaPipe && mediaPipeMgr) {
      mediaPipeMgr.dispose();
    }
    // Cleanup NDI receive
    if (entry._isNdi && ndiReceiveEntry === entry) {
      ndiReceiveEntry = null;
      if (_ndiWs && _ndiWs.readyState === WebSocket.OPEN) {
        ndiRequest(_ndiWs, 'ndi_receive_stop', {}).catch(() => {});
      }
    }
    mediaInputs.splice(idx, 1);
    renderMediaList();
    autoBindTextures();
  }

  // (file input change listeners wired above via wireFileInput)

  // Restart video/audio playback when tab regains focus (Chrome pauses muted background videos)
  document.addEventListener('visibilitychange', () => {
    if (!document.hidden) {
      mediaInputs.forEach(m => {
        if (m.type === 'video' && m.element && m.element.paused) {
          m.element.play().catch(() => {});
        }
        if (m.type === 'audio' && m.element && m.element.paused && m === activeAudioEntry) {
          if (audioCtx && audioCtx.state === 'suspended') audioCtx.resume();
          m.element.play().catch(() => {});
        }
      });
    }
  });

  // --- Load defaults (staggered to avoid GPU context loss) ---
  const _t0 = performance.now();
  const yieldFrame = () => new Promise(r => requestAnimationFrame(() => requestAnimationFrame(r)));

  (async function loadDefaults() {
    dbg('loadDefaults: fetching...');
    const [textSrc, sceneSrc, skySrc] = await Promise.all([
      fetch('shaders/text_james.fs').then(r => r.text()),
      fetch('scenes/tesseract.scene.js').then(r => r.text()),
      fetch('shaders/wind.fs').then(r => r.text()).catch(() => null),
    ]);

    // Yield frames between each heavy GPU operation to prevent context loss
    await yieldFrame();

    // 1. Shader layer FIRST (simple particle network — compile fast, render immediately)
    try {
      const shaderSrc = skySrc || DEFAULT_SHADER;
      const shaderResult = compileToLayer('shader', shaderSrc);
      if (shaderResult && shaderResult.ok) {
        getLayer('shader').visible = true;
        if (skySrc) {
          getLayer('shader').manifestEntry = manifest.find(m => m.file === 'wind.fs');
          const sel = document.querySelector('.layer-shader-select[data-layer="shader"]');
          if (sel) sel.value = 'wind.fs';
        }
        if (focusedLayerId === 'shader') editor.setValue(shaderSrc);
        dbg('shader: OK');
      } else {
        dbg('shader: FAILED — ' + (shaderResult && shaderResult.errors));
      }
    } catch (e) { dbg('shader EXCEPTION: ' + e.message); }

    await yieldFrame();

    // 2. Scene layer (Three.js — separate WebGL context)
    try {
      const sceneDef = new Function('THREE', 'return (' + sceneSrc + ')(THREE)')(THREE);
      sceneRenderer.load(sceneDef);
      const sceneLayer = getLayer('scene');
      sceneLayer._sceneDef = sceneDef;
      sceneLayer.inputs = sceneDef.INPUTS || [];
      const paramsContainer = document.querySelector('.layer-params[data-layer="scene"]');
      if (paramsContainer) {
        sceneLayer.inputValues = generateControls(sceneLayer.inputs, paramsContainer, (vals) => {
          sceneRenderer.inputValues = vals;
          sceneLayer.inputValues = vals;
          autoBindTextures('scene');
        });
        syncMpLinkedState(paramsContainer, 'scene');
      }
      sceneRenderer.inputValues = sceneLayer.inputValues;
      autoBindTextures('scene');
      sceneLayer.visible = true;
      sceneLayer.manifestEntry = manifest.find(m => m.file === 'tesseract.scene.js');
      const sceneSelect = document.querySelector('.layer-shader-select[data-layer="scene"]');
      if (sceneSelect) sceneSelect.value = 'tesseract.scene.js';
      sceneRenderer.resize();
      dbg('scene: OK');
    } catch (e) { dbg('scene EXCEPTION: ' + e.message); }

    // 3. Text layer (charData stripped at compile time — safe now)
    await yieldFrame();
    try {
      const textResult = compileToLayer('text', textSrc);
      if (textResult && textResult.ok) {
        getLayer('text').visible = true;
        getLayer('text').manifestEntry = manifest.find(m => m.file === 'text_james.fs');
        const textSel = document.querySelector('.layer-shader-select[data-layer="text"]');
        if (textSel) textSel.value = 'text_james.fs';
        if (focusedLayerId === 'text') editor.setValue(textSrc);
        // Pre-generate font atlas so first render frame has the texture ready
        updateFontAtlas(isfRenderer.gl, getLayer('text').inputValues || {});
        dbg('text: OK');
      } else {
        dbg('text: FAILED — ' + (textResult && textResult.errors));
      }
    } catch (e) { dbg('text EXCEPTION: ' + e.message); }

    updateLayerCardUI('scene');
    updateLayerCardUI('shader');
    updateLayerCardUI('text');
    // Start rendering now that all shaders are compiled
    compositionPlaying = true;
    document.getElementById('play-btn').innerHTML = '&#9654;';
    dbg('ALL DONE ' + Math.round(performance.now() - _t0) + 'ms');
    dbg('layers: ' + layers.map(l => l.id + '=' + (l.visible?'V':'-') + (l.program?'P':'-') + (l.fbo?'F':'-')).join(' '));
    // Start composition loop now that everything is ready
    compositionLoop();
    // Auto-hide debug overlay after 10 seconds if all went well (longer on mobile for debugging)
    const isMobile = window.innerWidth <= 768;
    setTimeout(() => { if (_dbg) _dbg.style.display = 'none'; }, isMobile ? 15000 : 5000);
  })().catch(e => {
    dbg('FATAL: ' + e.message);
    errorBar.textContent = 'Default load failed: ' + e.message;
    errorBar.classList.add('show');
  });

  // Start loading deferred scripts (model loaders) in background after init
  requestIdleCallback ? requestIdleCallback(() => loadDeferredScripts()) : setTimeout(() => loadDeferredScripts(), 2000);

  // ===== COMPOSITION LOOP =====
  let _compFrameCount = 0;
  let _cachedTextOpSlider = null;
  let _cachedTextOpVal = null;
  function compositionLoop() {
    if (!compositionPlaying || _contextLost || isfRenderer.gl.isContextLost()) {
      if (_compFrameCount < 3) dbg('compLoop SKIP: playing=' + compositionPlaying + ' ctxLost=' + _contextLost + ' glLost=' + isfRenderer.gl.isContextLost());
      _compFrameCount++;
      requestAnimationFrame(compositionLoop);
      return;
    }
    if (_compFrameCount < 3) dbg('compLoop frame ' + _compFrameCount + ' comp=' + !!isfRenderer.compositorProgram);
    _compFrameCount++;

    const gl = isfRenderer.gl;

    // Voice decay: 2s hold at full opacity, then ease-out decay
    const textLayer = getLayer('text');
    if (_voiceDecayEnabled && _voiceLastInputTime > 0 && textLayer) {
      const elapsed = (performance.now() - _voiceLastInputTime) / 1000;
      const holdTime = 2.0;
      let decayFactor;
      if (elapsed < holdTime) {
        decayFactor = 1.0;
      } else {
        const t = Math.min(1, (elapsed - holdTime) / Math.max(0.01, _voiceDecaySeconds));
        decayFactor = (1.0 - t) * (1.0 - t);
      }
      textLayer.opacity = decayFactor;
      textLayer._voiceGlitch = decayFactor < 1.0 ? (1.0 - decayFactor) : 0.0;
      // Update UI only every 4th frame to reduce DOM thrashing
      if ((_compFrameCount & 3) === 0) {
        if (!_cachedTextOpSlider) _cachedTextOpSlider = document.querySelector('.layer-card[data-layer="text"] input[type="range"]');
        if (!_cachedTextOpVal) _cachedTextOpVal = document.querySelector('.layer-card[data-layer="text"] .val');
        if (_cachedTextOpSlider) _cachedTextOpSlider.value = decayFactor;
        if (_cachedTextOpVal) _cachedTextOpVal.textContent = Math.round(decayFactor * 100) + '%';
      }
    } else if (textLayer) {
      textLayer._voiceGlitch = 0.0;
    }

    // 4. MediaPipe detection + gesture processing (BEFORE layer render so values are fresh)
    if (mediaPipeMgr.active) {
      const webcamEntry = mediaInputs.find(m => m.name === 'Webcam' && m.type === 'video');
      if (webcamEntry && webcamEntry.element) {
        mediaPipeMgr.detect(webcamEntry.element, performance.now());
      }

      // Pinch-to-rotate: apply hand pinch gesture to 3D scene rotation
      if (mediaPipeMgr.isPinching && sceneRenderer.sceneDef) {
        const sceneLayer = getLayer('scene');
        if (sceneLayer.inputValues) {
          sceneLayer.inputValues.rotY = ((sceneLayer.inputValues.rotY || 0) - mediaPipeMgr._pinchAccumX * 0.3 + 1) % 1;
          sceneLayer.inputValues.rotX = Math.max(0, Math.min(1, (sceneLayer.inputValues.rotX || 0.5) + mediaPipeMgr._pinchAccumY * 0.3));
          sceneRenderer.inputValues = sceneLayer.inputValues;
          mediaPipeMgr._pinchAccumX = 0;
          mediaPipeMgr._pinchAccumY = 0;
        }
      }

      // Live slider feedback: update sliders for MP-bound params (~15fps)
      if ((_compFrameCount & 3) === 0) {
        updateLinkedSliders();
        updateSignalBars();
        updateLinksDashboardValues();
        if (btIsRecording) captureFrame();
        if (btIsPlaying) applyPlaybackFrame();
      }
    }

    // GestureProcessor: always update so ease-out completes smoothly after tracking drops
    if (gestureEnabled) {
      gestureProcessor.update(mediaPipeMgr);
      if (!gestureProcessor.settled) {
        for (let li = 0; li < layers.length; li++) {
          const layer = layers[li];
          if (layer.type === 'shader' && layer.visible && layer._hasGestureInputs) {
            gestureProcessor.applyToLayer(layer);
          }
        }
      }
    }

    // Resolve pending async shader compilations
    for (let li = 0; li < layers.length; li++) {
      const layer = layers[li];
      if (!layer._pendingCompile) continue;
      if (!layer._pendingCompile.handle.isReady()) continue;
      const pending = layer._pendingCompile;
      layer._pendingCompile = null;
      const result = pending.handle.finalize();
      if (result.ok) {
        // Snapshot old FBO for crossfade
        _snapshotLayerFBO(gl, layer);
        // Apply compiled program via compileToLayer (handles controls, passes, etc.)
        compileToLayer(layer.id, pending.source, result.program);
        // Start crossfade
        layer._transitionStart = performance.now();
        errorBar.textContent = '';
        errorBar.classList.remove('show');
        lastErrors = null;
      } else {
        errorBar.textContent = result.errors;
        errorBar.classList.add('show');
      }
    }

    // Render each visible layer
    for (let li = 0; li < layers.length; li++) {
      const layer = layers[li];
      if (!layer.visible) continue;
      try {
        if (layer.type === 'scene' && sceneRenderer.sceneDef) {
          sceneRenderer.render();
          gl.bindTexture(gl.TEXTURE_2D, sceneTexture);
          gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, threeCanvas);
        } else if (layer.program) {
          isfRenderer.renderLayerToFBO(layer, mediaPipeMgr);
        }
        // Crossfade: blend old snapshot over new render with fading alpha
        if (layer._transitionStart) {
          const elapsed = performance.now() - layer._transitionStart;
          const t = Math.min(1, elapsed / TRANSITION_MS);
          if (t < 1) {
            // Ease-out cubic: old snapshot fades smoothly
            const alpha = (1 - t) * (1 - t) * (1 - t);
            _blendTransitionSnapshot(gl, layer, alpha);
          } else {
            layer._transitionStart = null;
          }
        }
      } catch (e) {
        // Silently skip layer if GL error (e.g. during context recovery)
      }
    }

    // Update mouse delta for this frame
    isfRenderer.mouseDelta[0] = isfRenderer.mousePos[0] - isfRenderer._lastMousePos[0];
    isfRenderer.mouseDelta[1] = isfRenderer.mousePos[1] - isfRenderer._lastMousePos[1];
    isfRenderer._lastMousePos[0] = isfRenderer.mousePos[0];
    isfRenderer._lastMousePos[1] = isfRenderer.mousePos[1];

    // Update background texture each frame
    if (canvasBg.mode === 'video' || canvasBg.mode === 'webcam') {
      if (canvasBg.videoEl && canvasBg.videoEl.readyState >= 2) {
        gl.bindTexture(gl.TEXTURE_2D, canvasBg.texture);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, canvasBg.videoEl);
      }
    } else if (canvasBg.mode === 'ndi') {
      // NDI frames are pushed to ndiReceiveCanvas by handleNdiVideoFrame;
      // just upload the canvas to the bg texture each frame
      if (canvasBg.videoEl && canvasBg.texture) {
        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
        gl.bindTexture(gl.TEXTURE_2D, canvasBg.texture);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, canvasBg.videoEl);
        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
      }
    } else if (canvasBg.mode === 'shader' && canvasBg.shaderLayer && canvasBg.shaderLayer.program) {
      isfRenderer.renderLayerToFBO(canvasBg.shaderLayer, mediaPipeMgr);
    }

    // 5. Compositor pass to screen
    const morphOpts = gestureEnabled ? { width: gestureProcessor.morphValue, scale: gestureProcessor.textureScale } : null;
    isfRenderer.renderCompositor(layers, sceneTexture, canvasBg, morphOpts);

    // 6. Projection window mirror
    if (projectionCtx && projectionWindow && !projectionWindow.closed) {
      projectionCtx.drawImage(glCanvas, 0, 0);
    } else if (projectionWindow) {
      projectionWindow = null; projectionCtx = null; projectionCanvas = null;
    }

    // 7. NDI send runs via its own requestAnimationFrame loop (Worker-based)

    requestAnimationFrame(compositionLoop);
  }

  // compositionLoop() is now started inside loadDefaults after compositionPlaying = true

  // Mouse tracking for interactive shaders
  glCanvas.addEventListener('mousemove', (e) => {
    const rect = glCanvas.getBoundingClientRect();
    const nx = (e.clientX - rect.left) / rect.width;
    const ny = 1.0 - (e.clientY - rect.top) / rect.height; // GL coords: Y up
    isfRenderer.mousePos[0] += (nx - isfRenderer.mousePos[0]) * 0.3;
    isfRenderer.mousePos[1] += (ny - isfRenderer.mousePos[1]) * 0.3;
  });

  // Handle canvas resize on panel resize
  const resizeObs = new ResizeObserver(() => {
    isfRenderer.resize();
    sceneRenderer.resize();
    // Resize layer FBOs
    layers.forEach(layer => {
      if (layer.fbo) {
        const gl = isfRenderer.gl;
        gl.bindTexture(gl.TEXTURE_2D, layer.fbo.texture);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1920, 1080, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
        layer.fbo.width = 1920;
        layer.fbo.height = 1080;
      }
    });
  });
  resizeObs.observe(document.getElementById('preview'));

  // ===== DRAG-TO-REORDER LAYERS =====
  (function initLayerDrag() {
    const panel = document.getElementById('layer-panel');
    let dragCard = null;

    function getCardFromPoint(y) {
      const cards = [...panel.querySelectorAll('.layer-card')];
      for (const card of cards) {
        const rect = card.getBoundingClientRect();
        if (y >= rect.top && y <= rect.bottom) return card;
      }
      return null;
    }

    function clearIndicators() {
      panel.querySelectorAll('.layer-card').forEach(c => {
        c.classList.remove('drag-over-top', 'drag-over-bottom');
      });
    }

    function syncLayerOrder() {
      const cards = [...panel.querySelectorAll('.layer-card')];
      // Top card in sidebar = frontmost (rendered last). Reverse so index 0 = backmost.
      // Filter out cards without compositor layers (e.g. voice)
      const newOrder = cards.map(c => getLayer(c.dataset.layer)).filter(Boolean).reverse();
      layers.length = 0;
      layers.push(...newOrder);
    }

    let dragStartY = 0;
    let dragPending = null; // card waiting for movement threshold
    const DRAG_THRESHOLD = 5; // pixels before drag activates

    panel.addEventListener('pointerdown', (e) => {
      const header = e.target.closest('.layer-header');
      if (!header) return;
      if (e.target.closest('button, select, input')) return;
      const card = header.closest('.layer-card');
      if (!card) return;
      dragPending = card;
      dragStartY = e.clientY;
    });

    panel.addEventListener('pointermove', (e) => {
      // Start drag only after threshold
      if (dragPending && !dragCard) {
        if (Math.abs(e.clientY - dragStartY) >= DRAG_THRESHOLD) {
          dragCard = dragPending;
          dragCard.classList.add('dragging');
        } else {
          return;
        }
      }
      if (!dragCard) return;
      clearIndicators();
      const overCard = getCardFromPoint(e.clientY);
      if (overCard && overCard !== dragCard) {
        const rect = overCard.getBoundingClientRect();
        const midY = rect.top + rect.height / 2;
        if (e.clientY < midY) {
          overCard.classList.add('drag-over-top');
        } else {
          overCard.classList.add('drag-over-bottom');
        }
      }
    });

    panel.addEventListener('pointerup', (e) => {
      if (dragCard) {
        clearIndicators();
        const overCard = getCardFromPoint(e.clientY);
        if (overCard && overCard !== dragCard) {
          const rect = overCard.getBoundingClientRect();
          const midY = rect.top + rect.height / 2;
          if (e.clientY < midY) {
            panel.insertBefore(dragCard, overCard);
          } else {
            panel.insertBefore(dragCard, overCard.nextSibling);
          }
          syncLayerOrder();
        }
        dragCard.classList.remove('dragging');
        dragCard = null;
      } else if (dragPending) {
        // Was a click, not a drag — toggle open/close + set focus
        const card = dragPending;
        const layerId = card.dataset.layer;
        card.classList.toggle('open');
        document.querySelectorAll('.layer-card').forEach(c => c.classList.remove('focused'));
        card.classList.add('focused');
        focusedLayerId = layerId;
      }
      dragPending = null;
    });

    panel.addEventListener('pointercancel', () => {
      if (dragCard) {
        clearIndicators();
        dragCard.classList.remove('dragging');
        dragCard = null;
      }
      dragPending = null;
    });
  })();

  // ===== KEYBOARD SHORTCUTS =====
  document.addEventListener('keydown', (e) => {
    // Don't intercept when typing in inputs
    if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA' || e.target.tagName === 'SELECT') return;
    if (e.key === '1') { const l = getLayer('text'); if (l) { l.visible = !l.visible; updateLayerCardUI('text'); } }
    if (e.key === '2') { const l = getLayer('shader'); if (l) { l.visible = !l.visible; updateLayerCardUI('shader'); } }
    if (e.key === '3') { const l = getLayer('scene'); if (l) { l.visible = !l.visible; updateLayerCardUI('scene'); } }
    if (e.key === '4') { const l = getLayer('overlay'); if (l) { l.visible = !l.visible; updateLayerCardUI('overlay'); } }
    if (e.key === 'Tab') {
      e.preventDefault();
      const ids = ['scene', 'shader', 'text', 'overlay'];
      const idx = ids.indexOf(focusedLayerId);
      focusedLayerId = ids[(idx + 1) % ids.length];
      document.querySelectorAll('.layer-card').forEach(c => c.classList.remove('focused'));
      const card = document.querySelector(`.layer-card[data-layer="${focusedLayerId}"]`);
      if (card) card.classList.add('focused');
    }
  });

  // ============================================================
  // WebSocket Client — connects to MCP server bridge
  // ============================================================

  if (location.protocol !== 'file:') {
    let ws = null;
    let reconnectTimer = null;

    function wsConnect() {
      const wsUrl = `${location.protocol === 'https:' ? 'wss' : 'ws'}://${location.host}`;
      ws = new WebSocket(wsUrl);
      ws.binaryType = 'arraybuffer';

      ws.onopen = async () => {
        if (reconnectTimer) { clearInterval(reconnectTimer); reconnectTimer = null; }
        _ndiWs = ws;
        // Auto-start NDI send
        if (!ndiSendingActive) {
          try {
            await ndiRequest(ws, 'ndi_send_start', { name: 'ShaderClaw', width: glCanvas.width, height: glCanvas.height });
            startNdiSend(ws, glCanvas);
          } catch (e) {}
        }
      };

      ws.onclose = () => {
        _ndiWs = null;
        // Stop NDI send if WS drops
        if (ndiSendingActive) {
          stopNdiSend();
        }
        if (!reconnectTimer) {
          reconnectTimer = setInterval(() => wsConnect(), 2000);
        }
      };

      ws.onerror = () => {};

      ws.onmessage = async (evt) => {
        // Handle binary NDI video frames from server
        if (evt.data instanceof ArrayBuffer) {
          const arr = new Uint8Array(evt.data);
          if (arr.length > 9 && arr[0] === FRAME_TYPE_NDI_VIDEO) {
            handleNdiVideoFrame(evt.data, isfRenderer.gl);
          }
          return;
        }

        let msg;
        try { msg = JSON.parse(evt.data); } catch { return; }

        // Check if this is a response to an NDI request (negative IDs)
        if (msg.id < 0) {
          const entry = ndiPending.get(msg.id);
          if (entry) {
            clearTimeout(entry.timer);
            ndiPending.delete(msg.id);
            if (msg.error) entry.reject(new Error(msg.error));
            else entry.resolve(msg.result);
          }
          return;
        }

        const { id, action, params } = msg;
        let result = null;
        let error = null;

        try {
          switch (action) {
            case 'load_shader': {
              const targetLayer = params.layerId || window.shaderClaw.getFocusedLayer();
              const compResult = window.shaderClaw.compileToLayer(targetLayer, params.code);
              result = {
                ok: compResult.ok,
                errors: compResult.errors || null,
                layer: targetLayer,
              };
              break;
            }

            case 'load_scene': {
              await window.shaderClaw.loadScene(params.folder, params.file);
              result = {
                ok: window.shaderClaw.getErrors() === null,
                errors: window.shaderClaw.getErrors(),
              };
              break;
            }

            case 'get_shader': {
              result = { code: window.shaderClaw.getSource() };
              break;
            }

            case 'set_parameter': {
              result = window.shaderClaw.setParameter(params.name, params.value);
              break;
            }

            case 'get_parameters': {
              result = { inputs: window.shaderClaw.getInputs() };
              break;
            }

            case 'screenshot': {
              const dataUrl = window.shaderClaw.screenshot();
              result = { dataUrl };
              break;
            }

            case 'get_errors': {
              const errs = window.shaderClaw.getErrors();
              result = { hasErrors: errs !== null, errors: errs };
              break;
            }

            case 'add_media': {
              result = await window.shaderClaw.addMedia(params.name, params.dataUrl);
              break;
            }

            case 'get_media': {
              result = { media: window.shaderClaw.getMedia() };
              break;
            }

            case 'remove_media': {
              result = window.shaderClaw.removeMedia(params.id);
              break;
            }

            case 'get_audio_levels': {
              result = window.shaderClaw.getAudioLevels();
              break;
            }

            case 'set_layer_visibility': {
              result = window.shaderClaw.setLayerVisibility(params.layerId, params.visible);
              break;
            }

            case 'set_layer_opacity': {
              result = window.shaderClaw.setLayerOpacity(params.layerId, params.opacity);
              break;
            }

            case 'enable_mediapipe': {
              result = await window.shaderClaw.enableMediaPipe(params.modes || { hand: true });
              break;
            }

            default:
              error = `Unknown action: ${action}`;
          }
        } catch (e) {
          error = e.message;
        }

        ws.send(JSON.stringify({ id, result, error }));
      };
    }

    wsConnect();

    // NDI tile — open source picker
    document.getElementById('tile-ndi').addEventListener('click', () => {
      if (!_ndiWs || _ndiWs.readyState !== WebSocket.OPEN) {
        console.warn('NDI: WebSocket not connected yet');
        return;
      }
      ndiPicker.classList.add('visible');
      refreshNdiSources(_ndiWs);
    });

    document.getElementById('ndi-refresh-btn').addEventListener('click', () => {
      if (!_ndiWs || _ndiWs.readyState !== WebSocket.OPEN) return;
      refreshNdiSources(_ndiWs);
    });
  }

})().catch(e => {
  console.error('ShaderClaw init failed:', e);
  const bar = document.getElementById('error-bar');
  if (bar) {
    bar.innerHTML = 'Init failed: ' + e.message + ' — <a href="#" onclick="location.reload();return false" style="color:var(--accent);text-decoration:underline">Retry</a>';
    bar.classList.add('show');
  }
});

// Release WebGL contexts on page unload to prevent browser context exhaustion
window.addEventListener('beforeunload', () => {
  // Release ISF renderer context
  const c = document.getElementById('gl-canvas');
  if (c) {
    const gl = c.getContext('webgl');
    if (gl) { const ext = gl.getExtension('WEBGL_lose_context'); if (ext) ext.loseContext(); }
  }
  // Release Three.js canvas context
  const tc = document.getElementById('three-canvas');
  if (tc) {
    const gl2 = tc.getContext('webgl');
    if (gl2) { const ext = gl2.getExtension('WEBGL_lose_context'); if (ext) ext.loseContext(); }
  }
});
</script>
</body>
</html>

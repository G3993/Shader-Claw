[{"working":false,"featured":false,"private":false,"stars":["69990af7b04833001acfaf2a"],"images":[],"categories":["5e7a80de7c113618206df1d9"],"publicCategories":["Examples"],"privateCategories":[],"_id":"5e7a7f987c113618206de0be","title":"Gradient Example","rawFragmentSource":"/*{\n\t\"DESCRIPTION\": \"Creates a linear gradient from one color to another\",\n\t\"CREDIT\": \"by VIDVOX\",\n\t\"ISFVSN\": \"2.0\",\n\t\"CATEGORIES\": [\n\t\t\"Examples\"\n\t],\n\t\"INPUTS\": [\n\t\t{\n\t\t\t\"NAME\": \"theColor1\",\n\t\t\t\"TYPE\": \"color\",\n\t\t\t\"DEFAULT\": [\n\t\t\t\t1.0,\n\t\t\t\t0.5,\n\t\t\t\t0.0,\n\t\t\t\t1.0\n\t\t\t]\n\t\t},\n\t\t{\n\t\t\t\"NAME\": \"theColor2\",\n\t\t\t\"TYPE\": \"color\",\n\t\t\t\"DEFAULT\": [\n\t\t\t\t0.0,\n\t\t\t\t0.0,\n\t\t\t\t1.0,\n\t\t\t\t1.0\n\t\t\t]\n\t\t}\n\t]\n}*/\n\nvoid main()\n{\n\tgl_FragColor = mix(theColor1,theColor2,isf_FragNormCoord.x);\n}","rawVertexSource":"void main() {\n\tisf_vertShaderInit();\n}","thumbnailCloudinaryId":"jqzsewqerujko1r3lzxz","description":"Creates a linear gradient from one color to another","shaderType":"generator","oldId":"3130","createdAt":"2018-08-17T20:00:39.453Z","user":{"_id":"5e7a7f587c113618206ddbd6","username":"isfvideo","name":"ISF Video","id":"5e7a7f587c113618206ddbd6"},"username":"isfvideo","updatedAt":"2026-02-22T11:58:43.217Z","__v":0,"id":"5e7a7f987c113618206de0be"},{"working":false,"featured":false,"private":false,"stars":["5e981fa7658b34001590fdb0","6411c24e24251a001ac7b87f","69990af7b04833001acfaf2a"],"images":[],"categories":["5e7a80de7c113618206df12f"],"publicCategories":[],"privateCategories":["Your category"],"_id":"5e7a7fa17c113618206de169","title":"No Man's Sky Gradients","rawFragmentSource":"/*{\n\t\"DESCRIPTION\": \"Your shader description\",\n\t\"CREDIT\": \"by you\",\n\t\"CATEGORIES\": [\n\t\t\"Your category\"\n\t],\n\t\"INPUTS\": [\n\t\n\t{\n\t\t\t\"NAME\": \"Color1\",\n\t\t\t\"TYPE\": \"color\",\n\t\t\t\"DEFAULT\": [\n\t\t\t\t1.0,\n\t\t\t\t0.0,\n\t\t\t\t0.0,\n\t\t\t\t1.0\n\t\t\t]\n\t\t},\n\t\t{\n\t\t\t\"NAME\": \"Color1_Radius\",\n\t\t\t\"TYPE\": \"float\",\n\t\t\t\"MIN\": 0.0,\n\t\t\t\"MAX\": 1.0,\n\t\t\t\"DEFAULT\": 1.0\n\t\t},\n\t\t{\n\t\t\t\"NAME\": \"Color1_Y\",\n\t\t\t\"TYPE\": \"float\",\n\t\t\t\"MIN\": 0.0,\n\t\t\t\"MAX\": 1.0,\n\t\t\t\"DEFAULT\": 0.0\n\t\t},\n\t\t{\n\t\t\t\"NAME\": \"Color2\",\n\t\t\t\"TYPE\": \"color\",\n\t\t\t\"DEFAULT\": [\n\t\t\t\t0.0,\n\t\t\t\t1.0,\n\t\t\t\t0.0,\n\t\t\t\t1.0\n\t\t\t]\n\t\t},\n\t\t{\n\t\t\t\"NAME\": \"Color2_Radius\",\n\t\t\t\"TYPE\": \"float\",\n\t\t\t\"MIN\": 0.0,\n\t\t\t\"MAX\": 1.0,\n\t\t\t\"DEFAULT\": 1.0\n\t\t},\n\t\t{\n\t\t\t\"NAME\": \"Color2_Y\",\n\t\t\t\"TYPE\": \"float\",\n\t\t\t\"MIN\": 0.0,\n\t\t\t\"MAX\": 1.0,\n\t\t\t\"DEFAULT\": 0.5\n\t\t},\n\t\t{\n\t\t\t\"NAME\": \"Color3\",\n\t\t\t\"TYPE\": \"color\",\n\t\t\t\"DEFAULT\": [\n\t\t\t\t0.0,\n\t\t\t\t0.0,\n\t\t\t\t1.0,\n\t\t\t\t1.0\n\t\t\t]\n\t\t},\n\t\t{\n\t\t\t\"NAME\": \"Color3_Radius\",\n\t\t\t\"TYPE\": \"float\",\n\t\t\t\"MIN\": 0.0,\n\t\t\t\"MAX\": 1.0,\n\t\t\t\"DEFAULT\": 1.0\n\t\t},\n\t\t{\n\t\t\t\"NAME\": \"Color3_Y\",\n\t\t\t\"TYPE\": \"float\",\n\t\t\t\"MIN\": 0.0,\n\t\t\t\"MAX\": 1.0,\n\t\t\t\"DEFAULT\": 1.0\n\t\t},\n\t\t{\n\t\t\t\"NAME\": \"CanvasColor\",\n\t\t\t\"TYPE\": \"color\",\n\t\t\t\"DEFAULT\": [\n\t\t\t\t0.0,\n\t\t\t\t0.0,\n\t\t\t\t0.0,\n\t\t\t\t1.0\n\t\t\t]\n\t\t},\n\t\t{\n\t\t\t\"NAME\": \"VERTICAL\",\n\t\t\t\"TYPE\": \"bool\",\n\t\t\t\"DEFAULT\": 0.0\n\t\t}\n\t\n\t]\n}*/\n\n// Adapted from \"RGB Soft Lights\" by BitOfGold: https://www.shadertoy.com/view/llVGz1\n// I've been playing a lot of \"No Man's Sky\" and thought this mod would help me recreate the vibe. :-)\n\nvec3 iResolution = vec3(RENDERSIZE, 1.);\n\nvec3 softLight(vec3 canvas, vec2 uv, vec2 center, float r, vec3 color) {\n    float d = clamp(1.0-length(center-uv)/r,0.0,1.0);\n    return(canvas + d*color);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / RENDERSIZE.xy;\n\t\n\tif (VERTICAL) {uv.y=uv.x;}\n\t\n\tfloat ASPECT = (RENDERSIZE.x/RENDERSIZE.y);\n\tuv.x = uv.y;\n\t\n\tvec3 canvas = vec3(CanvasColor.rgb);\n    canvas = softLight(canvas, uv, vec2(.5, Color1_Y), Color1_Radius, vec3(Color1.rgb));\n    canvas = softLight(canvas, uv, vec2(.5, Color2_Y), Color2_Radius, vec3(Color2.rgb));\n    canvas = softLight(canvas, uv, vec2(.5, Color3_Y), Color3_Radius, vec3(Color3.rgb));\n\tfragColor = vec4(canvas,1.0);\n}\n\n\nvoid main(void) {\n    mainImage(gl_FragColor, gl_FragCoord.xy);\n}","rawVertexSource":"void main() {\n\tvv_vertShaderInit();\n}","thumbnailCloudinaryId":"cfubq0dxzpmqsynxyrwn","description":"Your shader description","shaderType":"generator","oldId":"1354","createdAt":"2016-09-08T20:43:42.237Z","user":{"_id":"5e7a7f587c113618206dda61","username":"nikharron","name":"nik harron","id":"5e7a7f587c113618206dda61"},"username":"nikharron","updatedAt":"2026-02-22T12:00:57.361Z","__v":0,"id":"5e7a7fa17c113618206de169"},{"working":false,"featured":false,"private":false,"stars":["6411c24e24251a001ac7b87f","69990af7b04833001acfaf2a"],"images":[],"categories":["5e7a80de7c113618206df127"],"publicCategories":[],"privateCategories":["INKA"],"_id":"5ede15a89a2c7b00176938b0","title":"sky","rawFragmentSource":"/*{\n  \"CATEGORIES\": [\n    \"INKA\"\n  ],\n  \"DESCRIPTION\": \"Automatically converted from http://glslsandbox.com/e#36876.1\",\n  \"INPUTS\": [\n  ]\n}*/\n\nconst float PI = 3.141592654;\nconst float size = 0.5;\nfloat zoom = fract(TIME)/4.;\n\nvec4 star(vec2 uv, float zoom, float seed)\n{\n\tuv *= zoom;\n\tvec2 s = floor(uv);\n\tvec2 f = fract(uv);\n\tvec2 p = .5 + .440 * (sin(s + PI)) * sin(11. * fract(sin((s + seed) * mat2(7.5, 3.3, 6.2, 5.4)) * 55.)) - f;\n\tfloat d = length(p);\n\tfloat k = smoothstep(d*.9, d, 0.025 * size);\n\tfloat shades = 2.0;\n\tvec4 color = vec4(\n\t\t(shades/(shades-1.0))*mod(floor(shades*uv.y)/shades, 1.0),\n\t\t(shades/(shades-1.0))*mod(floor(shades*uv.x)/shades, 1.0),\n\t\t(shades/(shades-1.0))*mod(floor(shades*uv.x)/shades, 1.0), \n\t\t1.\n\t);\n    color =  vec4(1.0, 1.0, 1., 1.0);\n    return vec4(k* color.r, k * color.g, k * color.b, k);\n}\n\nvoid main(void)\n{\n    float layers = 5.;\n\tfloat phase = (fract(TIME)/5.) *PI;\n\tfloat blue = 1.-((isf_FragNormCoord.x/2.) + (isf_FragNormCoord.y));\n\tfloat opacity = (isf_FragNormCoord.x + isf_FragNormCoord.y);\n\tvec2 uv = (gl_FragCoord.xy*2.-RENDERSIZE.xy) / min(RENDERSIZE.x,RENDERSIZE.y); \n\tuv *= mat2(cos(phase), -sin(phase), sin(phase), cos(phase));\n\tvec4 c= vec4(0.,0., blue, opacity);\n\tfor(float i = 0.; i < 5. ; i += 1.)\n\t{\n\t\tvec4 dust = star(uv, mod(layers + i - zoom * layers, layers), i * 5.);\n\t\tc = mix(c, dust, dust.a*c.a);\n\t}\n\tgl_FragColor = vec4(c);\n}","rawVertexSource":"\nvoid main() {\n  isf_vertShaderInit();\n}\n","description":"Automatically converted from http://glslsandbox.com/e#36876.1","scale":1,"user":{"_id":"5eda543a658b34001590feea","username":"mcr","name":"marie","id":"5eda543a658b34001590feea"},"username":"mcr","createdAt":"2020-06-08T10:40:40.301Z","updatedAt":"2026-02-22T12:00:52.252Z","__v":47,"thumbnailCloudinaryId":"covwcwjxg4im0q97z6fd","id":"5ede15a89a2c7b00176938b0"},{"working":false,"featured":false,"private":false,"stars":["684f3dae5d14de001ac73248","69990af7b04833001acfaf2a"],"images":[],"categories":["5e7a80dd7c113618206df0c5"],"publicCategories":[],"privateCategories":["XXX"],"_id":"6494746b073c7a001a86991d","title":"Untitled Shader","rawFragmentSource":"\n/*{\n\t\"DESCRIPTION\": \"Gradient Flow forked from https://www.shadertoy.com/view/wdyczG\",\n\t\"CREDIT\": \"\",\n\t\"ISFVSN\": \"2\",\n\t\"CATEGORIES\": [\n\t\t\"XXX\"\n\t],\n\t\"INPUTS\": [\n\t\t{\n\t\t\t\"NAME\": \"Color_A\",\n\t\t\t\"TYPE\": \"color\",\n\t\t\t\"DEFAULT\": [\n\t\t\t\t0.957, 0.804, 0.623,\n\t\t\t\t1.0\n\t\t\t]\n\t\t},{\n\t\t\t\"NAME\": \"Color_B\",\n\t\t\t\"TYPE\": \"color\",\n\t\t\t\"DEFAULT\": [\n\t\t\t\t0.192, 0.384, 0.933,\n\t\t\t\t1.0\n\t\t\t]\n\t\t},{\n\t\t\t\"NAME\": \"Color_C\",\n\t\t\t\"TYPE\": \"color\",\n\t\t\t\"DEFAULT\": [\n\t\t\t\t0.910, 0.510, 0.8,\n\t\t\t\t1.0\n\t\t\t]\n\t\t}, {\n\t\t\t\"NAME\": \"Color_D\",\n\t\t\t\"TYPE\": \"color\",\n\t\t\t\"DEFAULT\": [\n\t\t\t\t0.350, 0.71, 0.953,\n\t\t\t\t1.0\n\t\t\t]\n\t\t}, {\n\t\t\t\"NAME\": \"Frequency\",\n\t\t\t\"TYPE\": \"float\",\n\t\t\t\"DEFAULT\": 5.0,\n\t\t\t\"MIN\": 0.0,\n\t\t\t\"MAX\": 100.0\n\t\t}, {\n\t\t\t\"NAME\": \"Amplitude\",\n\t\t\t\"TYPE\": \"float\",\n\t\t\t\"DEFAULT\": 30.0,\n\t\t\t\"MIN\": 0.0,\n\t\t\t\"MAX\": 100.0\n\t\t}, {\n\t\t\t\"NAME\": \"Speed\",\n\t\t\t\"TYPE\": \"float\",\n\t\t\t\"DEFAULT\": 2.0,\n\t\t\t\"MIN\": 0.0,\n\t\t\t\"MAX\": 10.0\n\t\t}\n\t]\n}*/\n\n#define S(a,b,t) smoothstep(a,b,t)\n\nmat2 Rot(float a)\n{\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\n\n// Created by inigo quilez - iq/2014\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\nvec2 hash( vec2 p )\n{\n    p = vec2( dot(p,vec2(2127.1,81.17)), dot(p,vec2(1269.5,283.37)) );\n\treturn fract(sin(p)*43758.5453);\n}\n\nfloat noise( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n\tvec2 u = f*f*(3.0-2.0*f);\n\n    float n = mix( mix( dot( -1.0+2.0*hash( i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ), \n                        dot( -1.0+2.0*hash( i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                   mix( dot( -1.0+2.0*hash( i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ), \n                        dot( -1.0+2.0*hash( i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n\treturn 0.5 + 0.5*n;\n}\n\n\nvoid main()\t{\n    vec2 uv = gl_FragCoord.xy/RENDERSIZE.xy;\n    float ratio = RENDERSIZE.x / RENDERSIZE.y;\n\n    vec2 tuv = uv;\n    tuv -= .5;\n    \n    float t = TIME;\n\n    // rotate with Noise\n    float degree = noise(vec2(t*.1, tuv.x*tuv.y));\n\n    tuv.y *= 1./ratio;\n    tuv *= Rot(radians((degree-.5)*720.+180.));\n\ttuv.y *= ratio;\n\n    \n    // Wave warp with sin\n    float speed = t * Speed;\n    tuv.x += sin(tuv.y*Frequency+speed)/Amplitude;\n   \ttuv.y += sin(tuv.x*Frequency*1.5+speed)/(Amplitude*.5);\n    \n    \n    // draw the image\n    vec3 layer1 = mix(Color_A.rgb, Color_B.rgb, S(-.3, .2, (tuv*Rot(radians(-5.))).x));\n    \n    vec3 layer2 = mix(Color_C.rgb, Color_D.rgb, S(-.3, .2, (tuv*Rot(radians(-5.))).x));\n    \n    vec3 finalComp = mix(layer1, layer2, S(.5, -.3, tuv.y));\n    \n    vec3 col = finalComp;\n    \n    gl_FragColor = vec4(col,1.0);\n}","rawVertexSource":"\nvoid main() {\n  isf_vertShaderInit();\n}\n","description":"Gradient Flow forked from https://www.shadertoy.com/view/wdyczG","scale":1,"user":{"_id":"64591895a58c94001ac87e21","username":"timurko","name":"Konstantin","id":"64591895a58c94001ac87e21"},"username":"timurko","createdAt":"2023-06-22T16:18:51.952Z","updatedAt":"2026-02-22T12:00:22.497Z","__v":14,"thumbnailCloudinaryId":"cpiny5mjhfdlcvznywg5","id":"6494746b073c7a001a86991d"},{"working":false,"featured":false,"private":false,"stars":["69990af7b04833001acfaf2a"],"images":[],"categories":["5e7a80de7c113618206df12f"],"publicCategories":[],"privateCategories":["Your category"],"_id":"651a8825388bc0001a1ad273","title":"Multi gradient","rawFragmentSource":"/*{\n\t\"DESCRIPTION\": \"Your shader description\",\n\t\"CREDIT\": \"by you\",\n\t\"CATEGORIES\": [\n\t\t\"Your category\"\n\t],\n\t\"INPUTS\": [\n\t\n\t{\n\t\t\t\"NAME\": \"Color1\",\n\t\t\t\"TYPE\": \"color\",\n\t\t\t\"DEFAULT\": [\n\t\t\t\t1.0,\n\t\t\t\t0.0,\n\t\t\t\t0.0,\n\t\t\t\t1.0\n\t\t\t]\n\t\t},\n\t\t{\n\t\t\t\"NAME\": \"Color1_Radius\",\n\t\t\t\"TYPE\": \"float\",\n\t\t\t\"MIN\": 0.0,\n\t\t\t\"MAX\": 1.0,\n\t\t\t\"DEFAULT\": 1.0\n\t\t},\n\t\t{\n\t\t\t\"NAME\": \"Color1_Y\",\n\t\t\t\"TYPE\": \"float\",\n\t\t\t\"MIN\": -1.5,\n\t\t\t\"MAX\": 1.5,\n\t\t\t\"DEFAULT\": -0.5\n\t\t},\n\t\t{\n\t\t\t\"NAME\": \"Color2\",\n\t\t\t\"TYPE\": \"color\",\n\t\t\t\"DEFAULT\": [\n\t\t\t\t0.0,\n\t\t\t\t1.0,\n\t\t\t\t0.0,\n\t\t\t\t1.0\n\t\t\t]\n\t\t},\n\t\t{\n\t\t\t\"NAME\": \"Color2_Radius\",\n\t\t\t\"TYPE\": \"float\",\n\t\t\t\"MIN\": 0.0,\n\t\t\t\"MAX\": 1.0,\n\t\t\t\"DEFAULT\": 1.0\n\t\t},\n\t\t{\n\t\t\t\"NAME\": \"Color2_Y\",\n\t\t\t\"TYPE\": \"float\",\n\t\t\t\"MIN\": -2.0,\n\t\t\t\"MAX\": 2.0,\n\t\t\t\"DEFAULT\": 0.0\n\t\t},\n\t\t{\n\t\t\t\"NAME\": \"Color3\",\n\t\t\t\"TYPE\": \"color\",\n\t\t\t\"DEFAULT\": [\n\t\t\t\t0.0,\n\t\t\t\t0.0,\n\t\t\t\t1.0,\n\t\t\t\t1.0\n\t\t\t]\n\t\t},\n\t\t{\n\t\t\t\"NAME\": \"Color3_Radius\",\n\t\t\t\"TYPE\": \"float\",\n\t\t\t\"MIN\": 0.0,\n\t\t\t\"MAX\": 1.0,\n\t\t\t\"DEFAULT\": 1.0\n\t\t},\n\t\t{\n\t\t\t\"NAME\": \"Color3_Y\",\n\t\t\t\"TYPE\": \"float\",\n\t\t\t\"MIN\": -2.0,\n\t\t\t\"MAX\": 2.0,\n\t\t\t\"DEFAULT\": 0.5\n\t\t},\t\t\n\t\t{\n\t\t\t\"NAME\": \"Color4\",\n\t\t\t\"TYPE\": \"color\",\n\t\t\t\"DEFAULT\": [\n\t\t\t\t0.0,\n\t\t\t\t0.0,\n\t\t\t\t0.0,\n\t\t\t\t1.0\n\t\t\t]\n\t\t},\n\t\t{\n\t\t\t\"NAME\": \"Color4_Radius\",\n\t\t\t\"TYPE\": \"float\",\n\t\t\t\"MIN\": 0.0,\n\t\t\t\"MAX\": 1.0,\n\t\t\t\"DEFAULT\": 1.0\n\t\t},\n\t\t{\n\t\t\t\"NAME\": \"Color4_Y\",\n\t\t\t\"TYPE\": \"float\",\n\t\t\t\"MIN\": -1.5,\n\t\t\t\"MAX\": 1.5,\n\t\t\t\"DEFAULT\": 0.5\n\t\t},\n\t\t{\n\t\t\t\"NAME\": \"CanvasColor\",\n\t\t\t\"TYPE\": \"color\",\n\t\t\t\"DEFAULT\": [\n\t\t\t\t0.0,\n\t\t\t\t0.0,\n\t\t\t\t0.0,\n\t\t\t\t1.0\n\t\t\t]\n\t\t},\n\t\t{\n\t\t\t\"NAME\": \"VERTICAL\",\n\t\t\t\"TYPE\": \"bool\",\n\t\t\t\"DEFAULT\": 1.0\n\t\t}\n\t\n\t]\n}*/\n\n// Adapted from \"RGB Soft Lights\" by BitOfGold: https://www.shadertoy.com/view/llVGz1\n// I've been playing a lot of \"No Man's Sky\" and thought this mod would help me recreate the vibe. :-)\n\nvec3 iResolution = vec3(RENDERSIZE, 1.);\n\nvec3 softLight(vec3 canvas, vec2 uv, vec2 center, float r, vec3 color) {\n    float d = clamp(1.0-length(center-uv)/r,0.0,1.0);\n    return(canvas + d*color);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / RENDERSIZE.xy;\n\t\n\tif (VERTICAL) {uv.y=uv.x;}\n\t\n\tfloat ASPECT = (RENDERSIZE.x/RENDERSIZE.y);\n\tuv.x = uv.y;\n\t\n\tvec3 canvas = vec3(CanvasColor.rgb);\n    canvas = softLight(canvas, uv-(Color1_Y), vec2(.5, 0.5), Color1_Radius, vec3(Color1.rgb));\n    canvas = softLight(canvas, uv-Color2_Y, vec2(.5, 0.5), Color2_Radius, vec3(Color2.rgb));\n    canvas = softLight(canvas, (uv-Color3_Y), vec2(.5, 0.5), Color3_Radius, vec3(Color3.rgb));\n    canvas = softLight(canvas, (uv-Color4_Y), vec2(.5, 0.5), Color4_Radius, vec3(Color4.rgb));\n\tfragColor = vec4(canvas,1.0);\n}\n\n\nvoid main(void) {\n    mainImage(gl_FragColor, gl_FragCoord.xy);\n}","rawVertexSource":"\nvoid main() {\n  isf_vertShaderInit();\n}\n","description":"Your shader description","scale":1,"user":{"_id":"5e7a7f587c113618206ddc34","username":"glawapple","name":"Aleksander Sprohgis","id":"5e7a7f587c113618206ddc34"},"username":"glawapple","createdAt":"2023-10-02T09:06:45.959Z","updatedAt":"2026-02-22T11:58:49.791Z","__v":2,"thumbnailCloudinaryId":"ah8jqdazfy4hxuofi9ll","id":"651a8825388bc0001a1ad273"},{"working":false,"featured":false,"private":false,"stars":["69990af7b04833001acfaf2a"],"images":[],"categories":["5e97acf5658b34001590fdaf"],"publicCategories":[],"privateCategories":["TEST-GLSL"],"_id":"65584a1985611d001aefce7b","title":"Moveable Gradient","rawFragmentSource":"/*{\n\t\"DESCRIPTION\": \"Moves a multicolor (up to 5) gradient across the view from and to off view\",\n\t\"CREDIT\": \"by Clutchplate\",\n\t\"ISFVSN\": \"2.0\",\n\t\"CATEGORIES\": [\n\t\t\"TEST-GLSL\"\n\t],\n\t\"INPUTS\": [\n\t\t{\n\t\t\t\"LABEL\": \"Color\",\n\t\t\t\"NAME\": \"color1\",\n\t\t\t\"TYPE\": \"color\",\n\t\t\t\"DEFAULT\": [0.0,0.0,1.0]\n\t\t},\n\t\t{\n\t\t\t\"LABEL\": \"Color\",\n\t\t\t\"NAME\": \"color2\",\n\t\t\t\"TYPE\": \"color\",\n\t\t\t\"DEFAULT\": [1.0,0.0,1.0]\n\t\t},\n\t\t{\n\t\t\t\"LABEL\": \"Color\",\n\t\t\t\"NAME\": \"color3\",\n\t\t\t\"TYPE\": \"color\",\n\t\t\t\"DEFAULT\": [1.0,1.0,0.0]\n\t\t},\n\t\t{\n\t\t\t\"LABEL\": \"Color\",\n\t\t\t\"NAME\": \"color4\",\n\t\t\t\"TYPE\": \"color\",\n\t\t\t\"DEFAULT\": [0.0,1.0,1.0]\n\t\t},\n\t\t{\n\t\t\t\"LABEL\": \"Color\",\n\t\t\t\"NAME\": \"color5\",\n\t\t\t\"TYPE\": \"color\",\n\t\t\t\"DEFAULT\": [0.0,1.0,0.0]\n\t\t},\n\t\t{\n\t\t\t\"LABEL\": \"Color\",\n\t\t\t\"NAME\": \"color6\",\n\t\t\t\"TYPE\": \"color\",\n\t\t\t\"DEFAULT\": [0.0,0.0,0.5]\n\t\t},\n\t\t{\n\t\t\t\"LABEL\": \"Color\",\n\t\t\t\"NAME\": \"color7\",\n\t\t\t\"TYPE\": \"color\",\n\t\t\t\"DEFAULT\": [0.5,0.4,0.0]\n\t\t},\n\t\t{\n\t\t\t\"LABEL\": \"Color\",\n\t\t\t\"NAME\": \"color8\",\n\t\t\t\"TYPE\": \"color\",\n\t\t\t\"DEFAULT\": [0.2,0.6,0.5]\n\t\t},\n\t\t{\n\t\t\t\"LABEL\": \"Thickness\",\n\t\t\t\"NAME\": \"thickness\",\n\t\t\t\"TYPE\": \"float\",\n\t\t\t\"DEFAULT\": 1.0,\n\t\t\t\"MIN\": 0.01,\n\t\t\t\"MAX\": 1.0\n\t\t},\n\t\t{\n\t\t\t\"LABEL\": \"Falloff\",\n\t\t\t\"NAME\": \"falloff\",\n\t\t\t\"TYPE\": \"float\",\n\t\t\t\"DEFAULT\": 0.2,\n\t\t\t\"MIN\": 0.001,\n\t\t\t\"MAX\": 0.3\n\t\t},\n\t\t{\n\t\t\t\"LABEL\": \"Rotation\",\n\t\t\t\"NAME\": \"angle\",\n\t\t\t\"TYPE\": \"float\",\n\t\t\t\"DEFAULT\": 0.0,\n\t\t\t\"MIN\": 0.0,\n\t\t\t\"MAX\": 360.0\n\t\t},\n\t\t{\n\t\t\t\"LABEL\": \"Cycles\",\n\t\t\t\"NAME\": \"cycles\",\n\t\t\t\"TYPE\": \"float\",\n\t\t\t\"DEFAULT\": 1.0,\n\t\t\t\"MIN\": 1.0,\n\t\t\t\"MAX\": 50.0\n\t\t},\n\t\t{\n\t\t\t\"LABEL\": \"Time\",\n\t\t\t\"NAME\": \"efftime\",\n\t\t\t\"TYPE\": \"float\",\n\t\t\t\"DEFAULT\": 0.5,\n\t\t\t\"MIN\": 0.0,\n\t\t\t\"MAX\": 1.0\n\t\t},\n\t\t{\n\t\t\t\"LABEL\": \"Start Offscreen\",\n\t\t\t\"NAME\": \"offscreen\",\n\t\t\t\"TYPE\": \"bool\",\n\t\t\t\"DEFAULT\": true\n\t\t}\n\t]\n}*/\nint NUMCOLORS = 3;\nfloat  reps = 0.5;\nfloat XL_DURATION = 4.0;\nvec4 black = vec4(0.0, 0.0, 0.0, 1.0);\n\nfloat frac(float f)\n{\n    return f<0.0 ? 1.0-(-f-floor(-f))  : (f-floor(f));\n}\n\n/*\nfloat thickness  = 0.2;\nbool dual = true;\n\n\n// loc is -0.5 to 0.5\nfloat mixcolor(float loc){\n    float MYTIME=(TIME-floor(TIME));\n    float normTimeInEffect = frac(MYTIME*cycles/XL_DURATION) - 0.5;\n    //float actTime = barPos/2.0; //2.0*((barPos/2.0)-0.5);\n    // actTime maps to -0.5 to 0.5 now\n\n    float actTime = normTimeInEffect;\n\n    float midc=(1.0-2.0*abs((loc-actTime)*(1.0/thickness)));\n    return midc;\n}\n*/\n\nvec4 mymix(vec4 x, vec4 y, float a) {\n    return a * x + (1.0-a) * y;\n}\n\nvoid main()\t{\n    float duration = XL_DURATION;\n    float time = efftime*XL_DURATION;\n    \n    float MYTIME=(time/XL_DURATION-floor(time/XL_DURATION));\n    MYTIME = frac(MYTIME*cycles);\n    \n    if (offscreen) {\n        time = MYTIME * (1.0+thickness) - 1.0;\n    } \n    else\n    {\n        time=frac(MYTIME);\n    }\n//    float normTimeInEffect = frac(MYTIME*cycles);\n    float normTimeInEffect = time;\n    \n    float p2x = isf_FragNormCoord.x-0.5;\n    float p2y = isf_FragNormCoord.y-0.5;\n    float rads = angle*3.1415927/180.0;\n    float px = p2x*sin(rads)+p2y*cos(rads);\n    float py = p2x*cos(rads)-p2y*sin(rads);    \n\n    float loc = (normTimeInEffect+px+0.5) / thickness;\n\n    int numColors= NUMCOLORS;\n    vec4 fragcolor;\n    vec4 lastColor = color1;\n    if (numColors==2)\n    {\n         lastColor = color2;\n    }\n    else if (numColors==3)\n    {\n         lastColor = color3;\n    }\n    else if (numColors==4)\n    {\n         lastColor = color4;\n    }\n    else if (numColors==5)\n    {\n         lastColor = color5;\n    }\n    else if (numColors==6)\n    {\n         lastColor = color6;\n    }\n    else if (numColors==7)\n    {\n         lastColor = color7;\n    }\n    else if (numColors==8)\n    {\n         lastColor = color8;\n    }\n    \n    if  ((loc > 1.0) || (loc < 0.0)) \n    {\n        fragcolor = black;\n    } \n    else if (loc <= falloff)\n    {\n        fragcolor = mix(black, color1, loc/falloff);\n    } \n    else if (loc > 1.0-falloff) \n    {\n        fragcolor = mix(lastColor, black, (loc-1.0+falloff)/falloff);\n    }\n    else \n    {\n        loc= (loc - falloff) / (1.0 - falloff * 2.0);\n        if (numColors == 1) \n        {\n            fragcolor = color1;\n        }   \n        else if (numColors == 2) \n        {\n            fragcolor = mix(color1, color2, loc);\n        }\n        else if (numColors == 3) \n        {\n            if (loc < 0.5) \n            {\n                fragcolor = mix(color1, color2, loc * 2.0);\n            } \n            else \n            {\n                fragcolor = mix(color2, color3, (loc - 0.5) * 2.0);\n            }\n        }\n        else if (numColors == 4) \n        {\n            if (loc < 0.33) \n            {\n                fragcolor = mix(color1, color2, loc * 3.0);\n            } \n            else if (loc < 0.66) \n            {\n                fragcolor = mix(color2, color3, (loc - 0.33) * 3.0);\n            } \n            else \n            {\n                fragcolor = mix(color3, color4, (loc - 0.66) * 3.0);\n            }\n        }\n        else if (numColors == 5) \n        {\n            if (loc < 0.25) \n            {\n                fragcolor = mix(color1, color2, loc * 4.0);\n            } \n            else if (loc < 0.5) \n            {\n                fragcolor = mix(color2, color3, (loc - 0.25) * 4.0);\n            } \n            else if (loc < 0.75) \n            {\n                fragcolor = mix(color3, color4, (loc - 0.5) * 4.0);\n            } \n            else \n            {\n                fragcolor = mix(color4, color5, (loc - 0.75) * 4.0);\n            }\n        }\n        else if (numColors == 6) \n        {\n            if (loc < 0.2) \n            {\n                fragcolor = mix(color1, color2, loc * 5.0);\n            } \n            else if (loc < 0.4) \n            {\n                fragcolor = mix(color2, color3, (loc - 0.2) * 5.0);\n            } \n            else if (loc < 0.6) \n            {\n                fragcolor = mix(color3, color4, (loc - 0.4) * 5.0);\n            } \n            else if (loc < 0.8) \n            {\n                fragcolor = mix(color4, color5, (loc - 0.6) * 5.0);\n            } \n            else \n            {\n                fragcolor = mix(color5, color6, (loc - 0.8) * 5.0);\n            }\n        }\n        else if (numColors == 7) \n        {\n            if (loc < 0.1667) \n            {\n                fragcolor = mix(color1, color2, loc * 6.0);\n            } \n            else if (loc < 0.3333) \n            {\n                fragcolor = mix(color2, color3, (loc - 0.1667) * 6.0);\n            } \n            else if (loc < 0.5) \n            {\n                fragcolor = mix(color3, color4, (loc - 0.3333) * 6.0);\n            } \n            else if (loc < 0.6667) \n            {\n                fragcolor = mix(color4, color5, (loc - 0.5) * 6.0);\n            } \n            else if (loc < 0.8333) \n            {\n                fragcolor = mix(color5, color6, (loc - 0.6667) * 6.0);\n            } \n            else \n            {\n                fragcolor = mix(color6, color7, (loc - 0.8333) * 6.0);\n            }\n        }\n        else if (numColors == 8) \n        {\n            if (loc < 0.1429) \n            {\n                fragcolor = mix(color1, color2, loc * 7.0);\n            } \n            else if (loc < 0.2857) \n            {\n                fragcolor = mix(color2, color3, (loc - 0.1429) * 7.0);\n            } \n            else if (loc < 0.4286) \n            {\n                fragcolor = mix(color3, color4, (loc - 0.2857) * 7.0);\n            } \n            else if (loc < 0.5714) \n            {\n                fragcolor = mix(color4, color5, (loc - 0.4286) * 7.0);\n            } \n            else if (loc < 0.7143) \n            {\n                fragcolor = mix(color5, color6, (loc - 0.5714) * 7.0);\n            } \n            else if (loc < 0.8571) \n            {\n                fragcolor = mix(color6, color7, (loc - 0.7143) * 7.0);\n            } \n            else \n            {\n                fragcolor = mix(color7, color8, (loc - 0.8571) * 7.0);\n            }\n        }\n    }\n    \n    gl_FragColor = vec4(fragcolor[0], fragcolor[1],fragcolor[2], 1.0);\n}\n","rawVertexSource":"\nvoid main() {\n  isf_vertShaderInit();\n}\n","description":"Moves a multicolor (up to 5) gradient across the view from and to off view","scale":1,"user":{"_id":"63cdbb55d12ead001aff2a94","username":"Clutchplate","name":"Lutz Kretzschmar","id":"63cdbb55d12ead001aff2a94"},"username":"Clutchplate","createdAt":"2023-11-18T05:22:34.000Z","updatedAt":"2026-02-22T11:59:28.671Z","__v":18,"thumbnailCloudinaryId":"optwjsnzcwmhmwihn7y7","id":"65584a1985611d001aefce7b"},{"working":false,"featured":false,"private":false,"stars":["69990af7b04833001acfaf2a"],"images":[],"categories":["5e7a80dd7c113618206df0c5"],"publicCategories":[],"privateCategories":["XXX"],"_id":"655f120585611d001af01bf8","title":"Gradient Mapping2","rawFragmentSource":"\n/*{\n\t\"DESCRIPTION\": \"\",\n\t\"CREDIT\": \"\",\n\t\"ISFVSN\": \"2\",\n\t\"CATEGORIES\": [\n\t\t\"XXX\"\n\t],\n\t\"INPUTS\": [\n\t\t{\n\t\t\t\"NAME\": \"inputImage\",\n\t\t\t\"TYPE\": \"image\"\n\t\t},\n\t\t{\n\t\t\t\"NAME\": \"baseColor\",\n\t\t\t\"TYPE\": \"color\",\n\t\t\t\"DEFAULT\": [\n\t\t\t\t1.0,\n\t\t\t\t1.0,\n\t\t\t\t0.0,\n\t\t\t\t1.0\n\t\t\t]\n\t\t},\n\t\t{\n\t\t\t\"NAME\": \"targetColor\",\n\t\t\t\"TYPE\": \"color\",\n\t\t\t\"DEFAULT\": [\n\t\t\t\t1.0,\n\t\t\t\t0.0,\n\t\t\t\t0.0,\n\t\t\t\t1.0\n\t\t\t]\n\t\t},\n\t\t{\n\t\t\t\"NAME\": \"targetColorPoint\",\n\t\t\t\"TYPE\": \"float\",\n\t\t\t\"DEFAULT\": 0.5\n\t\t},\n\t\t{\n\t\t\t\"NAME\": \"targetColorRange\",\n\t\t\t\"TYPE\": \"float\",\n\t\t\t\"DEFAULT\": 0.3\n\t\t},\n\t\t{\n\t\t\t\"NAME\": \"showGradient\",\n\t\t\t\"TYPE\": \"bool\",\n\t\t\t\"DEFAULT\": true\n\t\t},\n\t\t{\n\t\t\t\"NAME\": \"showSolarized\",\n\t\t\t\"TYPE\": \"bool\",\n\t\t\t\"DEFAULT\": false\n\t\t}\n\t],\n\t\"PASSES\": [\n\t\t{\n\t\t\t\"TARGET\":\"bufferVariableNameA\",\n\t\t\t\"WIDTH\": \"$WIDTH/16.0\",\n\t\t\t\"HEIGHT\": \"$HEIGHT/16.0\"\n\t\t},\n\t\t{\n\t\t\t\"DESCRIPTION\": \"this empty pass is rendered at the same rez as whatever you are running the ISF filter at- the previous step rendered an image at one-sixteenth the res, so this step ensures that the output is full-size\"\n\t\t}\n\t]\n\t\n}*/\nvec3 rgb2hsl( in vec3 c ){\n  float h = 0.0;\n\tfloat s = 0.0;\n\tfloat l = 0.0;\n\tfloat r = c.r;\n\tfloat g = c.g;\n\tfloat b = c.b;\n\tfloat cMin = min( r, min( g, b ) );\n\tfloat cMax = max( r, max( g, b ) );\n\n\tl = ( cMax + cMin ) / 2.0;\n\tif ( cMax > cMin ) {\n\t\tfloat cDelta = cMax - cMin;\n        \n        //s = l < .05 ? cDelta / ( cMax + cMin ) : cDelta / ( 2.0 - ( cMax + cMin ) ); Original\n\t\ts = l < .0 ? cDelta / ( cMax + cMin ) : cDelta / ( 2.0 - ( cMax + cMin ) );\n        \n\t\tif ( r == cMax ) {\n\t\t\th = ( g - b ) / cDelta;\n\t\t} else if ( g == cMax ) {\n\t\t\th = 2.0 + ( b - r ) / cDelta;\n\t\t} else {\n\t\t\th = 4.0 + ( r - g ) / cDelta;\n\t\t}\n\n\t\tif ( h < 0.0) {\n\t\t\th += 6.0;\n\t\t}\n\t\th = h / 6.0;\n\t}\n\treturn vec3( h, s, l );\n}\n\n\n\nvec3 hsl2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n    return c.z + c.y * (rgb-0.5)*(1.0-abs(2.0*c.z-1.0));\n}\n\nfloat solarize(in float baseLuminosity,in float point,in float range){\n    float area=clamp(1.-abs(baseLuminosity-point)/range,0.,1.);\n    return area;\n}\n\nvoid main()\t{\n\tvec4\t\tinputPixelColor;\n\t//\tboth of these are the same\n\tinputPixelColor = IMG_THIS_PIXEL(inputImage);\n// \tinputPixelColor = IMG_PIXEL(inputImage, gl_FragCoord.xy);\n\t\n\t//\tboth of these are also the same\n// \tinputPixelColor = IMG_NORM_PIXEL(inputImage, isf_FragNormCoord.xy);\n// \tinputPixelColor = IMG_THIS_NORM_PIXEL(inputImage);\n\t\n    float l=(inputPixelColor.r+inputPixelColor.g+inputPixelColor.b)/3.;\n    \n    //gradientを表示する場合、上の方に表示する\n    float gradientColor=mix(l,isf_FragNormCoord.x,step(0.9,isf_FragNormCoord.y));\n    l=mix(l,gradientColor,float(showGradient));\n    \n\tvec3 baseHsl=rgb2hsl(baseColor.rgb);\n\tvec3 baseColored=hsl2rgb(vec3(baseHsl.xy,l));\n\tvec3 targetHsl=rgb2hsl(targetColor.rgb);\n\tvec3 targetColored=hsl2rgb(vec3(targetHsl.xy,l));\n\t\n\tfloat solarized=solarize(l,targetColorPoint,targetColorRange);\n\tvec4 fullColor=vec4(mix(baseColored,targetColored,solarized),1.);\n\tvec4 solarizedColor=vec4(solarized,solarized,solarized,1.);\n// \tgl_FragColor=vec4(baseColored,1.);\n\tgl_FragColor=mix(fullColor,solarizedColor,float(showSolarized));\n}\n","rawVertexSource":"void main() {\n\tisf_vertShaderInit();\n}","description":"","scale":1,"forkedFrom":"6554c13bf4fa87001b3969b2","user":{"_id":"6299cb37cbcd96001967ddb4","name":"なめくじ","username":"greenmoonslug","id":"6299cb37cbcd96001967ddb4"},"username":"greenmoonslug","createdAt":"2023-11-23T08:49:09.628Z","updatedAt":"2026-02-22T11:59:01.615Z","__v":19,"thumbnailCloudinaryId":"jh4bg1xetayimm44ho0t","id":"655f120585611d001af01bf8"},{"working":false,"featured":false,"private":false,"stars":["639eeb9224251a001ac05e9f","68ce569fabb222001a42502e","69990af7b04833001acfaf2a"],"images":[],"categories":["669e4a64be01f9001aa47b12"],"publicCategories":[],"privateCategories":["XXX"],"_id":"65974f35fe89e9001a2096e9","title":"Ramp Sinus Gradient","rawFragmentSource":"/*{\n\t\"CREDIT\": \"by isadoratelesdecastro\",\n\t\"DESCRIPTION\": \"\",\n\t\"CATEGORIES\": [\n\t\t\"Gradient\"\n\t],\n\t\"INPUTS\": [\n\t\t{\n\t\t\t\"NAME\": \"colorA\",\n\t\t\t\"TYPE\": \"color\",\n\t\t\t\"DEFAULT\": [\n\t\t\t\t1.0,\n\t\t\t\t0.0,\n\t\t\t\t0.0,\n\t\t\t\t1.0\n\t\t\t]\n\t\t},\n\t\t{\n\t\t\t\"NAME\": \"colorB\",\n\t\t\t\"TYPE\": \"color\",\n\t\t\t\"DEFAULT\": [\n\t\t\t\t0.0,\n\t\t\t\t0.0,\n\t\t\t\t1.0,\n\t\t\t\t1.0\n\t\t\t]\n\t\t},\n\t\t{\n\t\t\t\"NAME\": \"offset\",\n\t\t\t\"TYPE\": \"float\",\n\t\t\t\"DEFAULT\": 0.5,\n\t\t\t\"MIN\": 0.0,\n\t\t\t\"MAX\": 10.0\n\t\t}\n\t]\n}*/\n\n/*\nfloat f(x)\n{\n\tfloat result = sin(4*x)/x;\n\treturn result;\n}\n*/\n\nfloat random (vec2 st) \n{\n    return fract(sin(dot(st.xy, vec2(12.9898,78.233)))*43758.5453123);\n}\n\nvoid main() \n{\n\tvec2 uv = gl_FragCoord.xy / RENDERSIZE.xy;\n\tvec3 pct = vec3(uv.y);\n\t\n\t//pct.r = sin(uv.y*colorA.r);\n\t//pct.g = sin(uv.x*colorB.g);\n\tgl_FragColor = mix(colorA, colorB, pct.b*offset);\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n","rawVertexSource":"void main() {\n\tisf_vertShaderInit();\n}","description":"","shaderType":"generator","forkedFrom":"5e7a7fb87c113618206de341","user":{"_id":"6596bd48fe89e9001a2079b8","username":"rhythmic-visions","name":"rhythmic-visions","id":"6596bd48fe89e9001a2079b8"},"username":"rhythmic-visions","createdAt":"2024-01-05T00:37:09.769Z","updatedAt":"2026-02-22T11:59:36.762Z","__v":3,"thumbnailCloudinaryId":"txubyt3mljhwluxqckar","id":"65974f35fe89e9001a2096e9"},{"working":false,"featured":false,"private":false,"stars":["6612e9d0b9e5d4001a986f73","68d72de53bc53b001a530b2f","69990af7b04833001acfaf2a"],"images":[],"categories":["65974e78fe89e9001a209660","5e7a80dd7c113618206df0a6","67c619b163819f001a74f1d1"],"publicCategories":["Generator"],"privateCategories":["Space","Stars"],"_id":"67c61eedd7aebf0019e0878c","title":"CloudyNightSky","rawFragmentSource":"/*{\n  \"CREDIT\": \"GEN8 and DeepSeek\",\n  \"DESCRIPTION\": \"Procedural night sky with scattered stars, flickering effect, and realistic nebulae.\",\n  \"CATEGORIES\": [\"Generator\", \"Space\", \"Stars\"],\n  \"INPUTS\": [\n    {\n      \"NAME\": \"lightIntensity\",\n      \"TYPE\": \"float\",\n      \"DEFAULT\": 1.0,\n      \"MIN\": 0.1,\n      \"MAX\": 2.0\n    },\n    {\n      \"NAME\": \"numStars\",\n      \"TYPE\": \"float\",\n      \"DEFAULT\": 500.0,\n      \"MIN\": 100.0,\n      \"MAX\": 1000.0\n    },\n    {\n      \"NAME\": \"nebulaDensity\",\n      \"TYPE\": \"float\",\n      \"DEFAULT\": 0.5,\n      \"MIN\": 0.1,\n      \"MAX\": 1.0\n    },\n    {\n      \"NAME\": \"nebulaColor\",\n      \"TYPE\": \"color\",\n      \"DEFAULT\": [0.5, 0.3, 0.8, 1.0]\n    },\n    {\n      \"NAME\": \"starTwinkle\",\n      \"TYPE\": \"float\",\n      \"DEFAULT\": 0.5,\n      \"MIN\": 0.0,\n      \"MAX\": 1.0\n    },\n    {\n      \"NAME\": \"speed\",\n      \"TYPE\": \"float\",\n      \"DEFAULT\": 0.1,\n      \"MIN\": 0.0,\n      \"MAX\": 1.0\n    },\n    {\n      \"NAME\": \"starSize\",\n      \"TYPE\": \"float\",\n      \"DEFAULT\": 0.01,\n      \"MIN\": 0.001,\n      \"MAX\": 0.1\n    },\n    {\n      \"NAME\": \"starFlick\",\n      \"TYPE\": \"float\",\n      \"DEFAULT\": 0.5,\n      \"MIN\": 0.0,\n      \"MAX\": 1.0\n    },\n    {\n      \"NAME\": \"flickerSpeed\",\n      \"TYPE\": \"float\",\n      \"DEFAULT\": 1.0,\n      \"MIN\": 0.1,\n      \"MAX\": 5.0\n    },\n    {\n      \"NAME\": \"nebulaDetail\",\n      \"TYPE\": \"float\",\n      \"DEFAULT\": 3.0,\n      \"MIN\": 1.0,\n      \"MAX\": 5.0\n    }\n  ]\n}*/\n\n// Random function for star generation\nfloat random(vec2 st) {\n  return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n// Simplex noise function for nebulae\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x * 34.0) + 1.0) * x); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\nfloat snoise(vec3 v) {\n  const vec2 C = vec2(1.0 / 6.0, 1.0 / 3.0);\n  vec3 i = floor(v + dot(v, C.yyy));\n  vec3 x0 = v - i + dot(i, C.xxx);\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min(g.xyz, l.zxy);\n  vec3 i2 = max(g.xyz, l.zxy);\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - 0.5;\n  i = mod289(i);\n  vec4 p = permute(permute(permute(\n             i.z + vec4(0.0, i1.z, i2.z, 1.0))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n           + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n  vec4 j = p - 49.0 * floor(p * (1.0 / 49.0));\n  vec4 x_ = floor(j * (1.0 / 7.0));\n  vec4 y_ = floor(j - 7.0 * x_);\n  vec4 x = (x_ * 2.0 + 0.5) / 7.0 - 1.0;\n  vec4 y = (y_ * 2.0 + 0.5) / 7.0 - 1.0;\n  vec4 h = 1.0 - abs(x) - abs(y);\n  vec4 b0 = vec4(x.xy, y.xy);\n  vec4 b1 = vec4(x.zw, y.zw);\n  vec4 s0 = floor(b0) * 2.0 + 1.0;\n  vec4 s1 = floor(b1) * 2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n  vec4 a0 = b0.xzyw + s0.xzyw * sh.xxyy;\n  vec4 a1 = b1.xzyw + s1.xzyw * sh.zzww;\n  vec3 g0 = vec3(a0.xy, h.x);\n  vec3 g1 = vec3(a0.zw, h.y);\n  vec3 g2 = vec3(a1.xy, h.z);\n  vec3 g3 = vec3(a1.zw, h.w);\n  vec4 norm = taylorInvSqrt(vec4(dot(g0, g0), dot(g1, g1), dot(g2, g2), dot(g3, g3)));\n  g0 *= norm.x;\n  g1 *= norm.y;\n  g2 *= norm.z;\n  g3 *= norm.w;\n  vec4 m = max(0.6 - vec4(dot(x0, x0), dot(x1, x1), dot(x2, x2), dot(x3, x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot(m * m, vec4(dot(g0, x0), dot(g1, x1), dot(g2, x2), dot(g3, x3)));\n}\n\n// Fractal noise function for nebula\nfloat fractalNoise(vec3 coord, float layers, float persistence) {\n  float total = 0.0;\n  float frequency = 1.0;\n  float amplitude = 1.0;\n  float maxValue = 0.0;\n\n  // Use a fixed number of iterations and scale based on layers\n  const int MAX_LAYERS = 5; // Maximum number of layers\n  for (int i = 0; i < MAX_LAYERS; i++) {\n    if (float(i) >= layers) break; // Stop early if layers < MAX_LAYERS\n    total += snoise(coord * frequency) * amplitude;\n    maxValue += amplitude;\n    amplitude *= persistence;\n    frequency *= 2.0;\n  }\n\n  return total / maxValue;\n}\n\n// Main function\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / RENDERSIZE.xy;\n  uv.y = 1.0 - uv.y; // Flip Y for correct orientation\n\n  // Generate stars\n  float stars = 0.0;\n  const int MAX_STARS = 1000; // Maximum number of stars\n  for (int i = 0; i < MAX_STARS; i++) {\n    // Randomize star position\n    vec2 starPos = vec2(random(vec2(float(i))), random(vec2(float(i + 1))));\n\n    // Randomly skip stars based on numStars to control density\n    if (random(vec2(float(i + 2))) > numStars / float(MAX_STARS)) continue;\n\n    // Randomize star brightness and size\n    float starBrightness = random(vec2(float(i + 3))) * lightIntensity;\n    float size = starSize * random(vec2(float(i + 4)));\n\n    // Twinkle effect\n    float twinkle = sin(TIME * speed + float(i)) * starTwinkle;\n\n    // Flickering effect with speed control\n    float flicker = 1.0 + starFlick * sin(TIME * flickerSpeed * 10.0 + float(i) * 10.0) * random(vec2(float(i + 5)));\n\n    // Draw star\n    stars += starBrightness * smoothstep(size, 0.0, length(uv - starPos)) * (1.0 + twinkle) * flicker;\n  }\n\n  // Generate nebulae using fractal noise\n  vec3 noiseCoord = vec3(uv * 5.0, TIME * speed);\n  float nebula = fractalNoise(noiseCoord, nebulaDetail, 0.5) * nebulaDensity;\n  vec3 nebulaColorFinal = nebulaColor.rgb * nebula * lightIntensity;\n\n  // Combine stars and nebulae\n  vec3 color = vec3(stars) + nebulaColorFinal;\n\n  // Output\n  gl_FragColor = vec4(color, 1.0);\n}","rawVertexSource":"\nvoid main() {\n  isf_vertShaderInit();\n}\n","description":"Procedural night sky with scattered stars, flickering effect, and realistic nebulae.","scale":1,"user":{"_id":"666c6de8e0ca9e001a0299a8","username":"GEN8","name":"Isaac Roman Espinaco","id":"666c6de8e0ca9e001a0299a8"},"username":"GEN8","createdAt":"2025-03-03T21:28:13.486Z","updatedAt":"2026-02-22T12:01:02.329Z","__v":2,"thumbnailCloudinaryId":"kp3bhebrrsrx6pxpqsvt","id":"67c61eedd7aebf0019e0878c"},{"working":false,"featured":false,"private":false,"stars":["5e7a7f587c113618206ddadd","5fe5f08fdf59c70014cdc4e8","60c1b13cdf59c70014cdc6d6","6276ad60cbcd96001966126a","62fba7a8ad0a68001afa5860","639eeb9224251a001ac05e9f","6523507d4fca60001abe2314","66f88aac522bf8001ae94e2a","698745c32f85b3001a0a97be","69987b8cb04833001acfa700"],"images":[],"categories":["5e7a80dd7c113618206df0ad"],"publicCategories":["Automatically Converted"],"privateCategories":[],"_id":"5e7a7f857c113618206ddf32","title":"PhiPiPlanet","rawFragmentSource":"/*{\n\t\"CREDIT\": \"by mojovideotech\",\n  \"CATEGORIES\" : [\n    \"Automatically Converted\"\n  ],\n  \"INPUTS\" : [\n\t {\n\t\t\t\"NAME\": \"rate\",\n\t\t\t\"TYPE\": \"float\",\n\t\t\t\"DEFAULT\": 6,\n\t\t\t\"MIN\": -100,\n\t\t\t\"MAX\": 100\n\t\t},\n\t\t\t{\n\t\t\t\"NAME\": \"radius\",\n\t\t\t\"TYPE\": \"float\",\n\t\t\t\"DEFAULT\": -40,\n\t\t\t\"MIN\": -60,\n\t\t\t\"MAX\": 60\n\t\t},\n\t\t{\n\t\t\t\"NAME\": \"multiplier\",\n\t\t\t\"TYPE\": \"float\",\n\t\t\t\"DEFAULT\": 9,\n\t\t\t\"MIN\": 1,\n\t\t\t\"MAX\": 30\n\t\t},\n\t\t    {\n      \"MAX\": [\n        2.0,\n        2.0\n      ],\n      \"MIN\": [\n        -2.0,\n        -2.0\n      ],\n      \"DEFAULT\":[0.0,0.0],\n      \"NAME\": \"offset\",\n      \"TYPE\": \"point2D\"\n    },\n     {\n\t\t\t\"NAME\": \"zoom\",\n\t\t\t\"TYPE\": \"float\",\n\t\t\t\"DEFAULT\": 3.3,\n\t\t\t\"MIN\": 0.1,\n\t\t\t\"MAX\": 3.5\n\t\t},\n     {\n\t\t\t\"NAME\": \"zoomwarp\",\n\t\t\t\"TYPE\": \"float\",\n\t\t\t\"DEFAULT\": 0.03,\n\t\t\t\"MIN\": 0.0,\n\t\t\t\"MAX\": 0.25\n\t\t},\n    {\n\t\t\t\"NAME\": \"rotozoom\",\n\t\t\t\"TYPE\": \"float\",\n\t\t\t\"DEFAULT\": 0.0,\n\t\t\t\"MIN\": -3,\n\t\t\t\"MAX\": 3\n\t\t},\n\t\t{\n\t\t     \"NAME\": \"R\",\n            \"TYPE\": \"float\",\n           \"DEFAULT\": 0.31,\n            \"MIN\": 0.0,\n            \"MAX\": 1.5\n        },\n         {\n            \"NAME\": \"G\",\n            \"TYPE\": \"float\",\n           \"DEFAULT\": 0.61,\n            \"MIN\": 0.0,\n            \"MAX\": 1.5\n        },\n         {\n            \"NAME\": \"B\",\n            \"TYPE\": \"float\",\n           \"DEFAULT\": 1.1,\n            \"MIN\": 0.0,\n            \"MAX\": 1.33\n        }\n  ],\n  \"DESCRIPTION\" : \"Automatically converted from http:\\/\\/glslsandbox.com\\/e#29138.9\"\n}\n*/\n\n\n// PhiPiPlanet by mojovideotech\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\n#define     sqfv    2.23606797749979    // sq root of 5\n#define \tpepi \t23.140692632779269 \t// powe(pi);\n#define \tpisq  \t9.869604401089359\t// pi squared, pi^2\n#define \ttwpi  \t6.283185307179586  \t// two pi, 2*pi\n#define \tpi   \t3.141592653589793 \t// pi\n#define \te     \t2.718281828459045 \t// eulers number\n#define \tphisq  \t2.6180339887499\t\t// phi squared, phi^2\n#define \tsqpi \t1.772453850905516\t// square root of pi\n#define \tphi   \t1.618033988749895 \t// golden ratio\n#define\t\terpi   \t1.523671054858932   // e root of pi\n#define \tcupi  \t1.464591887561523   // cube root of pi\n#define \tprpi \t1.439619495847591 \t// pi root of pi\n#define \tphrphi \t1.34636082003487\t// phi root of phi\n#define \tthpi  \t0.996272076220750\t// tanh(pi)\n#define \trcphi  \t0.61803398874989\t// reciprocal of pi  , 1/phi \n#define \trcpipi \t0.027425693123298 \t// reciprocal of pipi  , 1/pipi\n\nvoid main( void ) {\n\tvec2 pos = ( gl_FragCoord.xy / RENDERSIZE.xy)* 2.0 - 1.0;\n\tpos.x *=RENDERSIZE.x/RENDERSIZE.y;\n\tpos += vec2(offset);\n\tvec2 position = vec2(pos)*(4.0-zoom);\t\n\tfloat r = (position.x*position.x+position.y*position.y)+zoomwarp;\n\tposition = vec2((position.x/r)+rotozoom, (position.y/r)+rotozoom);\n\tvec3 col = vec3 (0.0);\n\tfloat T = TIME * 0.25 + (10000. * multiplier);\n\tfloat t2 = (atan(T * rcpipi)/9973.0)/rate;\n\tfloat t2e = phrphi*exp(t2-floor(t2)/rate);\n\tfloat color = (sin( position.x*t2e * cos( T /sqpi ) * 79.0 ) + cos( position.y*t2e * cos( T / twpi ) * 13.0 ))*(1.0-cos(t2*2.0*pi));\n\tt2 /= prpi;\n\tt2e -= thpi*exp(t2-floor(t2)/rate);\n\tcolor /= (sin( position.y*t2e * sin( T / phisq ) * 43.0 ) + cos( position.x*t2e * sin( T / e ) * 37.0 ))*(1.0-cos(t2*2.0*pi));\n    t2 /= cupi;\n\tt2e -= rcphi*exp(t2-floor(t2)/rate);\n\tcolor += (sin( position.x*t2e * sin( T / erpi ) * 101.0 ) + sin( position.y*t2e * sin( T / pisq ) * 83.0 ))*(1.0-cos(t2*2.0*pi));\n\tr *= pow(phi,sqfv);\n\tcolor -= r/log2(pepi-r/inversesqrt(r)*radius);\n\tcolor /= 1.0-color;\n\tr += zoom;\n\tcol.x -= color + sin(T/pi); \n\tcol.y += color + cos(T/pi); \n\tcol.z -= color - cos(T/pi);\n\tcol += vec3 (R-(G+B),G-(R+B),B-(R+G));\n\tgl_FragColor = vec4(vec3(col), 1.0 );\n}","rawVertexSource":"void main() {\n\tvv_vertShaderInit();\n}","thumbnailCloudinaryId":"kmkzw8wdyv5aqqlnjuoq","description":"Automatically converted from http://glslsandbox.com/e#29138.9","shaderType":"generator","oldId":"699","createdAt":"2015-11-30T00:26:24.375Z","user":{"_id":"5e7a7f587c113618206dda0d","username":"mojovideotech","name":"Mojo Video Tech","id":"5e7a7f587c113618206dda0d"},"username":"mojovideotech","updatedAt":"2026-02-20T16:27:49.272Z","__v":1,"id":"5e7a7f857c113618206ddf32"},{"working":false,"featured":false,"private":false,"stars":["5e7a7f587c113618206ddac2","5e7a7f587c113618206dda13","5e7a7f587c113618206ddadd","5e7a7f587c113618206dda9e","5e94caf23fd9680017950254","5eb889039a2c7b0017693835","5ebcc0c9658b34001590fea1","5ece153c658b34001590fed6","5e7a7f587c113618206ddda1","5fb60f5bdf59c70014cdc484","60072b1ddf59c70014cdc517","60658fadd4849b0013135d87","61a87341063978001a1c6fb0","62fba7a8ad0a68001afa5860","63119b25d12ead001af3ea8b","63139741d12ead001af40056","6373f34ed12ead001af9b5c9","642fbe4154062a0019c06613","63d387c9d12ead001affab8b","646f500d454380001a9bce1e","64bbf2515913c5001a3faeee","6523507d4fca60001abe2314","657b37ab85611d001af251ba","62221c907917e40014067e8c","661c08a4b9e5d4001a98ce20","667d2a6bad5cac0019834c34","66ffd0f3522bf8001ae9f02d","6783dd002909a9001a01c327","678e5f332909a9001a02a0d1","679f66e42909a9001a03e928","67f1bf8ea0bb96001afdec71","694b88fb75c346001ac82a2e","696338b37faa73001a3381ad","69987b8cb04833001acfa700"],"images":[],"categories":["5e7a80dd7c113618206df0e3","5e7a80de7c113618206df194","5e7a80dd7c113618206df0c8","5e7a80dd7c113618206df0a6"],"publicCategories":["Generator"],"privateCategories":["Blobs","distance","noise"],"_id":"5e7a7fe27c113618206de647","title":"Blobscillator","rawFragmentSource":"/*{\n\t\"CREDIT\": \"by mojovideotech\",\n  \t\"CATEGORIES\" : [\n  \t\t\"generator\",\n    \t\"blobs\",\n    \t\"distance\",\n    \t\"noise\"\n  ],\n  \t\"DESCRIPTION\" : \"based on https:\\/\\/www.shadertoy.com\\/view\\/MlKXWm by cacheflowe.  A wannabe reaction-diffusion, but not at all :-P \",\n  \t\"ISFVSN\" : \"2\",\n\t\"INPUTS\" : [\n\t{\n\t\t\"NAME\": \t\"scale\",\n\t\t\"TYPE\": \t\"float\",\n\t\t\"DEFAULT\": \t3.5,\n\t\t\"MIN\": \t\t0.0,\n\t\t\"MAX\": \t\t10\n\t},\n\t{\n\t\t\"NAME\": \t\"rate\",\n\t\t\"TYPE\": \t\"float\",\n\t\t\"DEFAULT\": \t0.125,\n\t\t\"MIN\": \t\t0.0,\n\t\t\"MAX\": \t\t1.0\n\t},\n\t{\n\t\t\"NAME\": \t\"loops\",\n\t\t\"TYPE\": \t\"float\",\n\t\t\"DEFAULT\":\t33.0,\n\t\t\"MIN\": \t\t1.0,\n\t\t\"MAX\": \t\t100.0\n\t},\n\t{\n\t\t\"NAME\": \t\"center\",\n\t\t\"TYPE\": \t\"point2D\",\n\t\t\"DEFAULT\":\t[ 0, 0 ],\n\t\t\"MAX\" : \t[ 1.0, 1.0 ],\n     \t\"MIN\" : \t[ -1.0, -1.0 ]\n\t},\n\t{\n\t\t\"NAME\": \t\"freq1\",\n\t\t\"TYPE\": \t\"float\",\n\t\t\"DEFAULT\": \t0.95,\n\t\t\"MIN\": \t\t0.005,\n\t\t\"MAX\": \t\t1.0\n\t},\n\t{\n\t\t\"NAME\": \t\"freq2\",\n\t\t\"TYPE\": \t\"float\",\n\t\t\"DEFAULT\": \t3.0,\n\t\t\"MIN\": \t\t0.5,\n\t\t\"MAX\": \t\t10.0\n\t},\n\t{\n     \t\"NAME\" :\t\"seed1\",\n     \t\"TYPE\" : \t\"float\",\n     \t\"DEFAULT\" :\t233,\n     \t\"MIN\" : \t89,\n     \t\"MAX\" :\t\t1597\n\t},\n    {\n     \t\"NAME\" :\t\"seed2\",\n      \t\"TYPE\" :\t\"float\",\n     \t\"DEFAULT\" :\t13,\n     \t\"MIN\" :\t\t5,\n     \t\"MAX\" :\t\t55\n    }\n  ]\n}\n*/\n\n////////////////////////////////////////////////////////////\n// Blobscillator  by mojovideotech\n//\n// based on :\n// shadertoy.com\\/view\\/MlKXWm  \n//\n// Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n////////////////////////////////////////////////////////////\n\nfloat hash (float a) { return floor(cos(a)*seed1+sin(a*seed2));  }\n\nvoid main() {\n\t\n    vec2 uv = (2.0 * gl_FragCoord.xy - RENDERSIZE.xy) / RENDERSIZE.y;\t\n    uv -= center.xy;\n    uv *= 10.5-scale;\n    float C = sin(TIME * rate) * freq1, dist = 0.0;\t\t\t\t\t\t\t\t\t\t\t\t\n    for(float i=10.0; i < 90.0; i++) {\t\t\t\t\t\t\t\t\n        float R = C + i;\t\t\t\t\t\t\t\t\t\n        vec2 N = vec2(sin(R), cos(R));\t\t\t\t\n        N *= abs(hash(R)) * freq2;\t\t\t\t\t\t\t\n        dist += sin(i + loops * distance(uv, N));\t\t\t\t\n    }\n\tgl_FragColor = vec4(vec3(dist),1.0);\n}\n","rawVertexSource":"void main() {\n\tisf_vertShaderInit();\n}","thumbnailCloudinaryId":"t0eczjag7hsecv13wkxy","description":"based on https://www.shadertoy.com/view/MlKXWm by cacheflowe.  A wannabe reaction-diffusion, but not at all :-P ","shaderType":"generator","oldId":"1714","createdAt":"2017-01-29T13:54:26.262Z","user":{"_id":"5e7a7f587c113618206dda0d","username":"mojovideotech","name":"Mojo Video Tech","id":"5e7a7f587c113618206dda0d"},"username":"mojovideotech","updatedAt":"2026-02-20T15:38:22.102Z","__v":3,"id":"5e7a7fe27c113618206de647"},{"working":false,"featured":false,"private":false,"stars":["5eaaf66b658b34001590fe42","5eb485bc9a2c7b0017693819","5ec10de49a2c7b001769385c","5f5832d0b1ed0d0014c0007c","5fe5f08fdf59c70014cdc4e8","6036b315df59c70014cdc585","6066f306d4849b0013135d8c","60658fadd4849b0013135d87","60f5267ff4fe08001a0a6216","6109903e063978001a1c6ec2","617581b3f4fe08001a0a62d7","6185ecc5f4fe08001a0a62ee","61a02c60063978001a1c6f9b","6053a3ecdf59c70014cdc627","624880137917e4001408d24e","625d52557917e400140a305a","62e08f9bcbcd9600196b561f","62fba7a8ad0a68001afa5860","63139741d12ead001af40056","631c6ba4d12ead001af46c0d","633167e0d12ead001af5960f","5e7a7f587c113618206ddadd","5fd1aa1edf59c70014cdc4d5","638230e2d12ead001afa7d6f","63d2f22cd12ead001affa435","63bdfee1d12ead001afe71e4","646f500d454380001a9bce1e","639eeb9224251a001ac05e9f","64bbf2515913c5001a3faeee","63f2ca6454062a0019bc525e","6523507d4fca60001abe2314","654f3fa285611d001aef1080","62221c907917e40014067e8c","659c4616fe89e9001a20c574","65c14c7c85611d001af5ca1f","666c6de8e0ca9e001a0299a8","671aa9599e84f80019d261fa","678e5f332909a9001a02a0d1","679021ca2909a9001a02bd9c","68bf75dfabb222001a410fc5","6900c7492173f0001a8b385c","691eba3e9fa0ee001aa4f2fe","69987b8cb04833001acfa700"],"images":[],"categories":["5e7a80de7c113618206df1de"],"publicCategories":[],"privateCategories":["sperical"],"_id":"5e7a7ff57c113618206de7be","title":"oooo.fs","rawFragmentSource":"/*{\n\t\"DESCRIPTION\": \"Your shader description\",\n\t\"CREDIT\": \"isf convert vdmo\",\n\t\"CATEGORIES\": [\n\t\t\"sperical\"\n\t],\n\t\"INPUTS\": [\n\n    ]\n}*/\n\nvec3 iResolution = vec3(RENDERSIZE, 1.);\nfloat iTime = TIME;\n\n// oOoOoOoOoOoOoOoOoOoOoOoOoOoOoOo\n// by TinyTexel\n// Creative Commons Attribution-ShareAlike 4.0 International Public License\n\n/*\npractical application of analytical AA for disks ( https://www.shadertoy.com/view/XtfyWs ) and\nSpherical Fibonacci Mapping ( http://lgdv.cs.fau.de/publications/publication/Pub.2015.tech.IMMD.IMMD9.spheri/ )\npartly inspired by \"A Spiral of Circles\" by knarkowicz ( https://www.shadertoy.com/view/Md2yWR )\n*/\n\n#define SPOT_COUNT_MUL 12.0\n\n// uses 5x super sampling on top of the analytical AA; mainly improves quality at acute viewing angles\n// #define USE_SSAA\n\n///////////////////////////////////////////////////////////////////////////\n//=======================================================================//\n\n#define Frame float(iFrame)\n#define Time iTime\n#define PixelCount iResolution.xy\n#define OUT\n\n#define rsqrt inversesqrt\n#define clamp01(x) clamp(x, 0.0, 1.0)\n\nconst float Pi = 3.14159265359;\nconst float Pi2  = Pi * 2.0;\nconst float Pi05 = Pi * 0.5;\n\nfloat Pow2(float x) {return x*x;}\nfloat Pow3(float x) {return x*x*x;}\nfloat Pow4(float x) {return Pow2(Pow2(x));}\n\nvec2 AngToVec(float ang)\n{\t\n\treturn vec2(cos(ang), sin(ang));\n}\n\n\nfloat SqrLen(float v) {return v * v;}\nfloat SqrLen(vec2  v) {return dot(v, v);}\nfloat SqrLen(vec3  v) {return dot(v, v);}\nfloat SqrLen(vec4  v) {return dot(v, v);}\n\nfloat GammaEncode(float x) {return pow(x, 1.0 / 2.2);}\nvec2 GammaEncode(vec2 x) {return pow(x, vec2(1.0 / 2.2));}\nvec3 GammaEncode(vec3 x) {return pow(x, vec3(1.0 / 2.2));}\nvec4 GammaEncode(vec4 x) {return pow(x, vec4(1.0 / 2.2));}\n\n#define If(cond, tru, fls) mix(fls, tru, cond)\n//=======================================================================//\n///////////////////////////////////////////////////////////////////////////\n\n/*\nIN:\n\trp\t\t: ray start position\n\trd\t\t: ray direction (normalized)\n\t\n\tsp2\t\t: sphere position\n\tsr2\t\t: sphere radius squared\n\t\nOUT:\n\tt\t\t: distances to intersection points (negative if in backwards direction)\n\nEXAMPLE:\t\n\tvec2 t;\n\tfloat hit = Intersect_Ray_Sphere(pos, dir, vec3(0.0), 1.0, OUT t);\n*/\nfloat Intersect_Ray_Sphere(\nvec3 rp, vec3 rd, \nvec3 sp, float sr2, \nout vec2 t)\n{\t\n\trp -= sp;\n\t\n\tfloat a = dot(rd, rd);\n\tfloat b = 2.0 * dot(rp, rd);\n\tfloat c = dot(rp, rp) - sr2;\n\t\n\tfloat D = b*b - 4.0*a*c;\n\t\n\tif(D < 0.0) return 0.0;\n\t\n\tfloat sqrtD = sqrt(D);\n\t// t = (-b + (c < 0.0 ? sqrtD : -sqrtD)) / a * 0.5;\n\tt = (-b + vec2(-sqrtD, sqrtD)) / a * 0.5;\n\t\n\t// if(start == inside) ...\n\tif(c < 0.0) t.xy = t.yx;\n\n\t// t.x > 0.0 || start == inside ? infront : behind\n\treturn t.x > 0.0 || c < 0.0 ? 1.0 : -1.0;\n}\n\n\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////\n//=================================================================================================//\n// Spherical Fibonacci Mapping\n// http://lgdv.cs.fau.de/publications/publication/Pub.2015.tech.IMMD.IMMD9.spheri/\n// Authors: Benjamin Keinert, Matthias Innmann, Michael SÃ¤nger, Marc Stamminger\n// (code copied from: https://www.shadertoy.com/view/4t2XWK)\n//-------------------------------------------------------------------------------------------------//\n\nconst float PI = 3.1415926535897932384626433832795;\nconst float PHI = 1.6180339887498948482045868343656;\n\nfloat madfrac( float a,float b) { return a*b -floor(a*b); }\nvec2  madfrac( vec2 a, float b) { return a*b -floor(a*b); }\n\nfloat round(float n)\n{\n\tif (fract(n) < 0.5)\n\t\treturn floor(n);\n\telse\n\t\treturn ceil(n);\n}\n\nfloat sf2id(vec3 p, float n) \n{\n    float phi = min(atan(p.y, p.x), PI), cosTheta = p.z;\n    \n    float k  = max(2.0, floor( log(n * PI * sqrt(5.0) * (1.0 - cosTheta*cosTheta))/ log(PHI*PHI)));\n    float Fk = pow(PHI, k)/sqrt(5.0);\n    \n    vec2 F = vec2( round(Fk), round(Fk * PHI) );\n\n    vec2 ka = -2.0*F/n;\n    vec2 kb = 2.0*PI*madfrac(F+1.0, PHI-1.0) - 2.0*PI*(PHI-1.0);    \n    mat2 iB = mat2( ka.y, -ka.x, -kb.y, kb.x ) / (ka.y*kb.x - ka.x*kb.y);\n\n    vec2 c = floor( iB * vec2(phi, cosTheta - (1.0-1.0/n)));\n    float d = 8.0;\n    float j = 0.0;\n    for( int s=0; s<4; s++ ) \n    {\n        vec2 uv = vec2( float(s-2*(s/2)), float(s/2) );\n        \n        float cosTheta = dot(ka, uv + c) + (1.0-1.0/n);\n        \n        cosTheta = clamp(cosTheta, -1.0, 1.0)*2.0 - cosTheta;\n        float i = floor(n*0.5 - cosTheta*n*0.5);\n        float phi = 2.0*PI*madfrac(i, PHI-1.0);\n        cosTheta = 1.0 - (2.0*i + 1.)/n;\n        float sinTheta = sqrt(1.0 - cosTheta*cosTheta);\n        \n        vec3 q = vec3( cos(phi)*sinTheta, sin(phi)*sinTheta, cosTheta);\n        float squaredDistance = dot(q-p, q-p);\n        if (squaredDistance < d) \n        {\n            d = squaredDistance;\n            j = i;\n        }\n    }\n    return j;\n}\n\nvec3 id2sf( float i, float n) \n{\n    float phi = 2.0*PI*madfrac(i,PHI);\n    float zi = 1.0 - (2.0*i+1.)/n;\n    float sinTheta = sqrt( 1.0 - zi*zi);\n    return vec3( cos(phi)*sinTheta, sin(phi)*sinTheta, zi);\n}\n//=================================================================================================//\n/////////////////////////////////////////////////////////////////////////////////////////////////////\n\n\n/*\nProjSphereArea - returns the screen space area of the projection of a sphere (assuming its an ellipse)\n\nIN:\n\trdz- z component of the unnormalized ray direction in camera space\n\tp  - center position of the sphere in camera space\n\trr - squared radius of the sphere\n\n\"Sphere - projection\" code used under\nThe MIT License\nCopyright Â© 2014 Inigo Quilez\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\nfloat ProjSphereArea(float rdz, vec3 p, float rr)\n{\n\tfloat zz = p.z * p.z;\t\n\tfloat ll = dot(p, p);\n\t\n\t//return Pi * rdz*rdz * rr * sqrt(abs((rr - ll) / (zz - rr))) / (zz - rr);\n    return Pi * rdz*rdz * rr * rsqrt(abs(Pow3(rr - zz) / (rr - ll)));\n}\n\n\nvec4 ProjDisk(vec3 rd, vec3 p, vec3 n, float rr)\n{   \n    vec3 np0 = n * p.xyz;\n    vec3 np1 = n * p.yzx;\n    vec3 np2 = n * p.zxy;  \n\n    mat3 k_mat = mat3(vec3( np0.y + np0.z,  np2.x        ,  np1.x        ),\n\t\t\t\t\t\t  vec3(-np2.y        ,  np1.y        , -np0.x - np0.z),\n\t\t\t\t\t\t  vec3(-np1.z        , -np0.x - np0.y,  np2.z        ));    \n    \n    vec3 u =     k_mat * rd;\n    vec3 k = u * k_mat;\n    \n    \n    float nrd = dot(n, rd);\n    \n    float nrd_rr = nrd * rr;\n\n    \n    float v = dot(u, u) - nrd * nrd_rr; \n    vec3  g =    (k     - n   * nrd_rr) * 2.0;   \n    \n    return vec4(g.xy, 0.0, v);\n}\n\n\n\nfloat Sph(float x, float rr) { return sqrt(rr - x*x); }\nfloat SphX0(float d, float rr0, float rr1) { return 0.5 * (d + (rr0 - rr1) / d); }\n\nvec3 EvalSceneCol(vec3 cpos, mat3 cam_mat, float focalLen, vec2 uv0)\n{      \n    const vec3 cBG = 0.014 * vec3(0.9, 1.0, 1.2);\n\n        \n    vec2 uv2 = uv0 - PixelCount.xy * 0.5;\n    \n  \tvec3 rdir0 = vec3(uv2, focalLen);\n    \n    float rdir0S = 0.5 * PixelCount.x;\n    rdir0 /= rdir0S;\n    \n    vec3 rdir = normalize(cam_mat * rdir0); \n    \n    \n    vec2 t;\n\tfloat hit = Intersect_Ray_Sphere(cpos, rdir, vec3(0.0), 1.0, OUT t);\n    \n    if(hit <= 0.0) return cBG;\n\n\n    vec3 pf = cpos + rdir * t.x;\n    vec3 pb = cpos + rdir * t.y;\n\n\tvec3 col = cBG;\n\n    //float lerpF = 0.0;\n    \n    float rra = 0.0;\n\n    vec3 p2;\n    float rr;\n    {\n\tconst float s = SPOT_COUNT_MUL;        \n    const float n = 1024.0*s;\n        \n    float id = sf2id(pf.xzy, n);\n    \t  p2 = id2sf(id,     n).xzy;        \n\n    float u = id / n;\n    float arg = (-u* 615.5*2.0*s) + Time * 1.0;//238-3 384.-2 615-1\n        \n    rra = sin(arg);\n    \n    #if 0    \n\t//for(float i = 0.0; i < 2.0; ++i)        \n\trra = (Pow2(rra)*2.-1.);\n    #endif\n        \n\trra = mix(abs(rra), Pow2(rra), 0.75);        \n      \n    rr = 0.0025/s * rra; \n    }\n    \n    \n    vec3 n2 = normalize(p2);\n    \n    const float maskS = 0.5;// sharpness\n\n    \n    if(SqrLen(pf - p2) > rr) return cBG;\n\n    float d = length(p2);\n\n    float x0 = SphX0(d, 1.0, rr);        \n    vec3 d0c = n2 * x0;\n\n    float d0rr = 1.0 - x0*x0;\n\n    vec3 dp_c = (d0c - cpos) * cam_mat;\n    vec3 dn_c = n2 * cam_mat;\n\n    vec4 r = ProjDisk(rdir0, dp_c, dn_c, d0rr);        \n\n    float cmask = clamp01(-r.w * rsqrt(dot(r.xy, r.xy))*rdir0S * maskS);\n\n    float cmask2 = 0.0;\n    {\n        vec3 d1c = n2 * (x0 - 0.005);\n\n        vec4 r = ProjDisk(rdir0, (d1c - cpos) * cam_mat, n2 * cam_mat, (1.0 - x0*x0)*rra);\n        cmask2 = clamp01(-r.w * rsqrt(dot(r.xy, r.xy))*rdir0S * maskS);\n    }\n\n\n    #if 1\t\n    float A = ProjSphereArea(rdir0.z, dp_c, d0rr);        \n    A *= rdir0S*rdir0S;\n\n    float NdV = abs(dot(dn_c, normalize(dp_c)));\n\n    A *= NdV;\n    \n    #ifndef USE_SSAA\n    A *= NdV;\n    cmask *= clamp01((A -2.0)*0.125);\n    #else\n    A = mix(A, A*NdV, 0.5);\n    cmask *= clamp01((A - 3.)*0.125);\n    #endif\n\n\n    #endif\n\n\n    const vec3 cB = vec3(0.1, 0.4, 1.0);\n    const vec3 cR = vec3(1., 0.02, 0.2);\n\n    //vec3 cX = mix(cB, cR, lerpF);\n    //vec3 cY = mix(cR, cB, lerpF);\n\n    return mix(cBG, mix(cR, vec3(0.0), cmask2), cmask);        \n    //return mix(cBG, mix(cR, cB, cmask2), cmask);\n    //return mix(cBG, mix(cX, cY, cmask2), cmask);        \n    //return mix(cBG, mix(cW, cX, cmask2), cmask);\n    //return mix(cBG, vec3(1.0), cmask);\n    //return vec3(-r.w*10.0);\n    //return vec3(1.0);\n    \n    return col;\n}\n\n\nvoid mainImage( out vec4 outCol, in vec2 uv0 )\n{\n    vec3 col = vec3(0.0);\n    \n    vec2 uv = uv0.xy - 0.5;\n  \n    \n    //vec4 mouseAccu = texelFetch(iChannel0, ivec2(1, 0), 0); \n\n    vec2 ang = vec2(Pi * 0.0, -Pi * 0.3);\n    //ang += mouseAccu.xy * 0.008;\n\n    #if 1\n    ang.x += Time * 0.15;\n    //ang.y = sin(Time * 0.2 * Pi) *0.2;\n    \n    //ang.y += Time * 0.073;\n    #endif\n\n    float fov = Pi * 0.5;\n    \n    mat3 cam_mat;\n    float focalLen;\n    {\n        float sinPhi   = sin(ang.x);\n        float cosPhi   = cos(ang.x);\n        float sinTheta = sin(ang.y);\n        float cosTheta = cos(ang.y);    \n\n        vec3 front = vec3(cosPhi * cosTheta, \n                                   sinTheta, \n                          sinPhi * cosTheta);\n\n        vec3 right = vec3(-sinPhi, 0.0, cosPhi);\n        vec3 up    = cross(right, front);\n\n        focalLen = PixelCount.x * 0.5 * tan(Pi05 - fov * 0.5);\n        \n        cam_mat = mat3(right, up, front);\n    }\n    \n    //vec3 cpos = -cam_mat[2] * (exp2(-0.3 + mouseAccu.w * 0.03));\n    vec3 cpos = -cam_mat[2] * (exp2(-0.3));\n\n    cpos.y += .75;\n\n    \n    #ifndef USE_SSAA\n    \n\tcol = EvalSceneCol(cpos, cam_mat, focalLen, uv0);\n    \n\t#elif 1\n    \n    col  = EvalSceneCol(cpos, cam_mat, focalLen, uv + vec2(0.3, 0.1));\n    col += EvalSceneCol(cpos, cam_mat, focalLen, uv + vec2(0.9, 0.3));\n    col += EvalSceneCol(cpos, cam_mat, focalLen, uv + vec2(0.5, 0.5));\n    col += EvalSceneCol(cpos, cam_mat, focalLen, uv + vec2(0.1, 0.7));\n    col += EvalSceneCol(cpos, cam_mat, focalLen, uv + vec2(0.7, 0.9));   \n    col *= 0.2;\n    \n \t#elif 1\n    \n    float o = 1.;\n    col  = EvalSceneCol(cpos, cam_mat, focalLen, uv + vec2(0.3, 0.1) * o - 0.5*o+0.5) * vec3(1.5, 0.75, 0.0);\n    col += EvalSceneCol(cpos, cam_mat, focalLen, uv + vec2(0.9, 0.3) * o - 0.5*o+0.5) * vec3(0.0, 0.0, 3.0);\n    col += EvalSceneCol(cpos, cam_mat, focalLen, uv + vec2(0.5, 0.5) * o - 0.5*o+0.5) * vec3(0.0, 3.0, 0.0);\n    col += EvalSceneCol(cpos, cam_mat, focalLen, uv + vec2(0.1, 0.7) * o - 0.5*o+0.5) * vec3(3.0, 0.0, 0.0);\n    col += EvalSceneCol(cpos, cam_mat, focalLen, uv + vec2(0.7, 0.9) * o - 0.5*o+0.5) * vec3(0.0, 0.75, 1.5);   \n    \n    col /= vec3(4.5, 4.5, 4.5);\n\n    #endif\n\n    float\talpha = (col.r + col.g + col.b);\n\toutCol = vec4(GammaEncode(clamp01(col)), alpha);\n}\n\nvoid main(void) {\n    mainImage(gl_FragColor, gl_FragCoord.xy);\n}","rawVertexSource":"void main() {\n\tisf_vertShaderInit();\n}","thumbnailCloudinaryId":"z1szrnnbxe2ykjixtejw","description":"Your shader description","shaderType":"generator","oldId":"3400","createdAt":"2018-10-25T20:43:37.109Z","user":{"_id":"5e7a7f587c113618206ddbfe","username":"cheesedooodles","name":"Paul Harmon🇺🇸","id":"5e7a7f587c113618206ddbfe"},"username":"cheesedooodles","updatedAt":"2026-02-20T15:29:19.357Z","__v":0,"id":"5e7a7ff57c113618206de7be"},{"working":false,"featured":true,"private":false,"stars":["5e7a7f587c113618206ddc44","5e7a7f587c113618206ddce7","5ebcc0c9658b34001590fea1","5ec5488e9a2c7b001769386c","5ed00fba9a2c7b001769388a","5f51a9cbb1ed0d0014c0006d","5fc10117d4849b0013135bd3","61a797eb063978001a1c6faf","61bb0facfa146100147ca8da","61ce2e1d7917e4001401cce1","61ec519ffa146100147f8274","5ea315689a2c7b00176937e3","624a4a3b7917e4001408e1a7","628b4fdbcbcd9600196739e1","628fc259cbcd960019677603","62fb14f2ad0a68001afa532a","62fba7a8ad0a68001afa5860","63225a4fd12ead001af4e36f","6331d80ed12ead001af59b4b","635afb92c0b6ee001abdda68","617c88a2f4fe08001a0a62e1","63bbed9bd12ead001afe55c1","5e7a7f587c113618206ddd52","63c9f602d12ead001afef702","63c2e7fcd12ead001afeaab1","6473170da58c94001ac9c7ee","6485c297a58c94001acae298","64bbf2515913c5001a3faeee","64edaefa4fca60001aba9ab2","633167e0d12ead001af5960f","655e779ef4fa87001b3a13ab","656214daf4fa87001b3a50ac","656214daf4fa87001b3a50ac","62221c907917e40014067e8c","65b151d285611d001af4f995","65ca320ccffff4001ab8549d","6612e9d0b9e5d4001a986f73","6617054bb9e5d4001a989e70","664de0b8e0ca9e001a00e69c","6654298ad15e30001b9fa860","670e831b2e035b001b56612b","654c242c85611d001aeee3b3","6734926ca085a6001a5bda68","674b70af7c51b3001a52be5b","67628330b808e10019342a65","678e5f332909a9001a02a0d1","67e184a8d7aebf0019e2ebe4","685a1580932476001a3a61d0","68ce569fabb222001a42502e","691eba3e9fa0ee001aa4f2fe","6356d754d12ead001af7f0b5","696eb3da80748c001a895885","69274a05ce8b81001981ec08","69987b8cb04833001acfa700"],"images":["5e7a80d07c113618206deff3"],"categories":["5e7a80dd7c113618206df0b0"],"publicCategories":["Glitch"],"privateCategories":[],"_id":"5e7a7ffe7c113618206de87f","title":"Random Freeze","rawFragmentSource":"/*\n{\n  \"CATEGORIES\" : [\n    \"Glitch\"\n  ],\n  \"DESCRIPTION\" : \"Causes only part of an image to update\",\n  \"ISFVSN\" : \"2\",\n  \"INPUTS\" : [\n    {\n      \"NAME\" : \"inputImage\",\n      \"TYPE\" : \"image\"\n    },\n    {\n      \"NAME\" : \"maxUpdateSize\",\n      \"TYPE\" : \"float\",\n      \"MAX\" : 1,\n      \"DEFAULT\" : 0.5,\n      \"LABEL\" : \"Size\",\n      \"MIN\" : 0\n    },\n    {\n      \"NAME\" : \"maxBlendAmount\",\n      \"TYPE\" : \"float\",\n      \"MAX\" : 1,\n      \"DEFAULT\" : 0,\n      \"MIN\" : 0\n    },\n    {\n      \"NAME\" : \"resetImage\",\n      \"TYPE\" : \"event\",\n      \"LABEL\" : \"Reset Image\"\n    }\n  ],\n  \"PASSES\" : [\n    {\n      \"TARGET\" : \"lastState\",\n      \"PERSISTENT\" : true,\n      \"DESCRIPTION\" : \"\"\n    }\n  ],\n  \"CREDIT\" : \"VIDVOX\"\n}\n*/\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec4 rand4(vec4 co)\t{\n\tvec4\treturnMe = vec4(0.0);\n\treturnMe.r = rand(co.rg);\n\treturnMe.g = rand(co.gb);\n\treturnMe.b = rand(co.ba);\n\treturnMe.a = rand(co.rb);\n\treturn returnMe;\n}\n\nvec3 hsv2rgb(vec3 c)\t{\n\tvec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n\tvec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n\treturn c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nconst float pi = 3.14159265359;\n\n\nbool pointInRect(vec2 pt, vec4 r)\n{\n\tbool\treturnMe = false;\n\tif ((pt.x >= r.x)&&(pt.y >= r.y)&&(pt.x <= r.x + r.z)&&(pt.y <= r.y + r.w))\n\t\treturnMe = true;\n\treturn returnMe;\n}\n\nvoid main()\t{\n\tvec2\tloc = isf_FragNormCoord.xy;\n\tbool\tdoReset = ((resetImage)||(FRAMEINDEX==0));\n\tvec4\treturnMe = (doReset) ? IMG_THIS_PIXEL(inputImage) : IMG_THIS_PIXEL(lastState);\n\tvec4\tseeds1 = TIME * vec4(0.2123,0.34517,0.53428,0.7431);\n\tvec4\trandCoords = rand4(seeds1);\n\trandCoords.zw *= maxUpdateSize;\n\tif (randCoords.x + randCoords.z > 1.0)\n\t\trandCoords.z = 1.0 - randCoords.x;\n\tif (randCoords.y + randCoords.w > 1.0)\n\t\trandCoords.w = 1.0 - randCoords.y;\n\n\tbool\tisInShape = pointInRect(loc,randCoords);\n\t\n\tif (isInShape)\t{\n\t\tfloat\t\tmixAmount = maxBlendAmount * rand(vec2(TIME,0.32234));\n\t\tvec4\t\tnewColor = IMG_THIS_PIXEL(inputImage);\n\t\tnewColor.a = 1.0;\n\t\treturnMe = mix(newColor,returnMe,mixAmount);\n\t}\n\t\n\tgl_FragColor = returnMe;\n}\n","rawVertexSource":"void main() {\n\tisf_vertShaderInit();\n}","thumbnailCloudinaryId":"vpqztrgtfaoqecotttxn","description":"Causes only part of an image to update","shaderType":"filter","oldId":"2452","createdAt":"2018-03-03T01:35:10.963Z","user":{"_id":"5e7a7f587c113618206dda00","username":"VIDVOX","name":"VIDVOX","id":"5e7a7f587c113618206dda00"},"username":"VIDVOX","updatedAt":"2026-02-20T15:22:33.612Z","__v":3,"id":"5e7a7ffe7c113618206de87f"},{"working":false,"featured":false,"private":false,"stars":["641c205724251a001ac84014","69987b8cb04833001acfa700"],"images":[],"categories":["5e7a80dd7c113618206df0b2"],"publicCategories":["Distortion Effect"],"privateCategories":[],"_id":"5e7a80117c113618206de9f9","title":"Optical Flow Distort.fs","rawFragmentSource":"/*\n{\n  \"CATEGORIES\" : [\n    \"Distortion Effect\"\n  ],\n  \"DESCRIPTION\" : \"Uses an optical flow mask to create a distortion\",\n  \"ISFVSN\" : \"2\",\n  \"INPUTS\" : [\n    {\n      \"NAME\" : \"inputImage\",\n      \"TYPE\" : \"image\"\n    },\n    {\n      \"NAME\" : \"amt\",\n      \"TYPE\" : \"float\",\n      \"MAX\" : 1,\n      \"DEFAULT\" : 0.5,\n      \"LABEL\" : \"Distortion Amount\",\n      \"MIN\" : 0\n    },\n    {\n      \"NAME\" : \"maskHold\",\n      \"TYPE\" : \"float\",\n      \"MAX\" : 1,\n      \"DEFAULT\" : 0.98,\n      \"LABEL\" : \"Flow Persistence\",\n      \"MIN\" : 0\n    },\n    {\n      \"NAME\" : \"inputScale\",\n      \"TYPE\" : \"float\",\n      \"MAX\" : 10,\n      \"DEFAULT\" : 2,\n      \"LABEL\" : \"Scale\",\n      \"MIN\" : 0\n    },\n    {\n      \"NAME\" : \"inputOffset\",\n      \"TYPE\" : \"float\",\n      \"MAX\" : 1,\n      \"DEFAULT\" : 0.1,\n      \"LABEL\" : \"Offset\",\n      \"MIN\" : 0\n    },\n    {\n      \"NAME\" : \"inputLambda\",\n      \"TYPE\" : \"float\",\n      \"MAX\" : 1,\n      \"DEFAULT\" : 1,\n      \"LABEL\" : \"Noise Removal\",\n      \"MIN\" : 0\n    },\n    {\n      \"NAME\" : \"resetNow\",\n      \"TYPE\" : \"event\",\n      \"LABEL\" : \"Restart\"\n    }\n  ],\n  \"PASSES\" : [\n    {\n      \"TARGET\" : \"maskBuffer\",\n      \"PERSISTENT\" : true\n    },\n    {\n      \"TARGET\" : \"delayBuffer\",\n      \"PERSISTENT\" : true\n    },\n    {\n\n    }\n  ],\n  \"CREDIT\" : \"by VIDVOX, based on original implementation by Andrew Benson and v002\"\n}\n*/\n\n\nvarying vec2 left_coord;\nvarying vec2 right_coord;\nvarying vec2 above_coord;\nvarying vec2 below_coord;\n\nvarying vec2 lefta_coord;\nvarying vec2 righta_coord;\nvarying vec2 leftb_coord;\nvarying vec2 rightb_coord;\n\n\n//\tbased on v002 Optical Flow which is itself a port of Andrew Bensons HS Flow implementation on the GPU.\n//\thttps://github.com/v002/v002-Optical-Flow\n\n\nconst vec4 coeffs = vec4(0.2126, 0.7152, 0.0722, 1.0);\n\nfloat gray(vec4 n)\n{\n\treturn (n.r + n.g + n.b)/3.0;\n}\n\nvoid main()\n{\n\t//\ton the first pass generate the mask using the previous delayBuffer and inputImage\n\t//\ton the 2nd pass update the delayBuffer to hold inputImage\n\t//\ton the 3rd pass output the new mask\n\tif (PASSINDEX == 0)\t{\n\t\tif ((FRAMEINDEX == 0)||(resetNow))\t{\n\t\t\tgl_FragColor = vec4(0.5);\n\t\t}\n\t\telse\t{\n\t\t\t//\tconvert to grayscale\n\t\t\tvec4 a = IMG_THIS_PIXEL(inputImage) * coeffs;\n\t\t\tfloat brightness = gray(a);\n\t\t\ta = vec4(brightness);\n\t\t\tvec4 b = IMG_THIS_PIXEL(delayBuffer) * coeffs;\n\t\t\tbrightness = gray(b);\n\t\t\tb = vec4(brightness);\n\t\t\n\t\t\tvec2 x1 = vec2(inputOffset * RENDERSIZE.x, 0.0);\n\t\t\tvec2 y1 = vec2(0.0,inputOffset * RENDERSIZE.y);\n\t\t\tvec2 texcoord0 = isf_FragNormCoord.xy * RENDERSIZE;\n\t\t\tvec2 texcoord1 = isf_FragNormCoord.xy * RENDERSIZE;\n\t\t\n\t\t\t//get the difference\n\t\t\tvec4 curdif = b-a;\n\t\n\t\t\t//calculate the gradient\n\t\t\tvec4 gradx = IMG_PIXEL(delayBuffer, texcoord1+x1)-IMG_PIXEL(delayBuffer, texcoord1-x1);\n\t\t\tgradx += IMG_PIXEL(inputImage, texcoord0+x1)-IMG_PIXEL(inputImage, texcoord0-x1);\n\t\t\n\t\t\tvec4 grady = IMG_PIXEL(delayBuffer, texcoord1+y1)-IMG_PIXEL(delayBuffer, texcoord1-y1);\n\t\t\tgrady += IMG_PIXEL(inputImage, texcoord0+y1)-IMG_PIXEL(inputImage, texcoord0-y1);\n\t\n\t\t\tvec4 gradmag = sqrt((gradx*gradx)+(grady*grady)+vec4(inputLambda));\n\n\t\t\tvec4 vx = curdif*(gradx/gradmag);\n\t\t\tfloat vxd = gray(vx);//assumes greyscale\n\t\t\t//format output for flowrepos, out(-x,+x,-y,+y)\n\t\t\tvec2 xout = vec2(max(vxd,0.),abs(min(vxd,0.)))*inputScale;\n\n\t\t\tvec4 vy = curdif*(grady/gradmag);\n\t\t\tfloat vyd = gray(vy);//assumes greyscale\n\t\t\t//format output for flowrepos, out(-x,+x,-y,+y)\n\t\t\tvec2 yout = vec2(max(vyd,0.),abs(min(vyd,0.)))*inputScale;\n\t\n\t\t\t//gl_FragColor = clamp(vec4(xout.xy,yout.xy), 0.0, 1.0);\n\t\t\n\t\t\tvec4 mask = clamp(vec4(xout.xy,yout.xy), 0.0, 1.0);\n\t\t\n\t\t\tvec4 color = IMG_THIS_NORM_PIXEL(maskBuffer);\n\t\t\tvec4 colorL = IMG_NORM_PIXEL(maskBuffer, left_coord);\n\t\t\tvec4 colorR = IMG_NORM_PIXEL(maskBuffer, right_coord);\n\t\t\tvec4 colorA = IMG_NORM_PIXEL(maskBuffer, above_coord);\n\t\t\tvec4 colorB = IMG_NORM_PIXEL(maskBuffer, below_coord);\n\n\t\t\tvec4 colorLA = IMG_NORM_PIXEL(maskBuffer, lefta_coord);\n\t\t\tvec4 colorRA = IMG_NORM_PIXEL(maskBuffer, righta_coord);\n\t\t\tvec4 colorLB = IMG_NORM_PIXEL(maskBuffer, leftb_coord);\n\t\t\tvec4 colorRB = IMG_NORM_PIXEL(maskBuffer, rightb_coord);\n\n\t\t\t//\tblur then sharpen the feedback buffer\n\t\t\tvec4 blurVector = (color + colorL + colorR + colorA + colorB + colorLA + colorRA + colorLB + colorRB) / 9.0;\n\t\t\tgl_FragColor = mask + maskHold * blurVector;\n\t\t}\n\t}\n\telse if (PASSINDEX == 1)\t{\t\n\t\t//\there we just buffer the current frame for next TIME\n\t\tgl_FragColor = IMG_THIS_PIXEL(inputImage);\n\t}\n\telse\t{\n\t\t//\tNOW DO SOMETHING WITH THE MASK - BLUR THE IMAGE AND THE MASK IMAGE\n\t\t\n\t\t//\tblur the mask image\n\t\tvec2 texcoord0 = isf_FragNormCoord.xy;\n\t\t\n\t\tvec4 color = IMG_THIS_NORM_PIXEL(maskBuffer);\n\t\tvec4 colorL = IMG_NORM_PIXEL(maskBuffer, left_coord);\n\t\tvec4 colorR = IMG_NORM_PIXEL(maskBuffer, right_coord);\n\t\tvec4 colorA = IMG_NORM_PIXEL(maskBuffer, above_coord);\n\t\tvec4 colorB = IMG_NORM_PIXEL(maskBuffer, below_coord);\n\n\t\tvec4 colorLA = IMG_NORM_PIXEL(maskBuffer, lefta_coord);\n\t\tvec4 colorRA = IMG_NORM_PIXEL(maskBuffer, righta_coord);\n\t\tvec4 colorLB = IMG_NORM_PIXEL(maskBuffer, leftb_coord);\n\t\tvec4 colorRB = IMG_NORM_PIXEL(maskBuffer, rightb_coord);\n\t\t\n\t\tvec4 blurVector = (color + colorL + colorR + colorA + colorB + colorLA + colorRA + colorLB + colorRB) / 9.0;\n\t\t//vec4 blurVector = IMG_THIS_PIXEL(maskBuffer);\n\t\t\n\t\tvec2 blurAmount = vec2(blurVector.y-blurVector.x, blurVector.w-blurVector.z);\n\t\tvec2 tmp = texcoord0 + blurAmount * amt;\n\t\ttmp.x = clamp(tmp.x,0.0,1.0);\n\t\ttmp.y = clamp(tmp.y,0.0,1.0);\n\t\tvec4 sample0 = IMG_NORM_PIXEL(inputImage, tmp);\n\t\ttmp = (1.02 + texcoord0) + blurAmount * amt * amt;\n\t\ttmp.x = clamp(tmp.x,0.0,1.0);\n\t\ttmp.y = clamp(tmp.y,0.0,1.0);\n\t\tvec4 sample1 = IMG_NORM_PIXEL(inputImage, tmp);\n\t\tgl_FragColor = (sample0 * 3.0 + sample1) / 4.0;\n\t}\n}\n","rawVertexSource":"varying vec2 left_coord;\r\nvarying vec2 right_coord;\r\nvarying vec2 above_coord;\r\nvarying vec2 below_coord;\r\n\r\nvarying vec2 lefta_coord;\r\nvarying vec2 righta_coord;\r\nvarying vec2 leftb_coord;\r\nvarying vec2 rightb_coord;\r\n\r\n\r\nvoid main()\r\n{\r\n\tisf_vertShaderInit();\r\n\tvec2 texc = vec2(isf_FragNormCoord[0],isf_FragNormCoord[1]);\r\n\tvec2 d = 4.0/RENDERSIZE;\r\n\r\n\tleft_coord = clamp(vec2(texc.xy + vec2(-d.x , 0)),0.0,1.0);\r\n\tright_coord = clamp(vec2(texc.xy + vec2(d.x , 0)),0.0,1.0);\r\n\tabove_coord = clamp(vec2(texc.xy + vec2(0,d.y)),0.0,1.0);\r\n\tbelow_coord = clamp(vec2(texc.xy + vec2(0,-d.y)),0.0,1.0);\r\n\r\n\tlefta_coord = clamp(vec2(texc.xy + vec2(-d.x , d.x)),0.0,1.0);\r\n\trighta_coord = clamp(vec2(texc.xy + vec2(d.x , d.x)),0.0,1.0);\r\n\tleftb_coord = clamp(vec2(texc.xy + vec2(-d.x , -d.x)),0.0,1.0);\r\n\trightb_coord = clamp(vec2(texc.xy + vec2(d.x , -d.x)),0.0,1.0);\r\n}","thumbnailCloudinaryId":"lfdrrbenxssvdtji0oez","description":"Uses an optical flow mask to create a distortion","shaderType":"filter","oldId":"5147","createdAt":"2019-11-28T07:36:36.284Z","user":{"_id":"5e7a7f587c113618206ddd52","username":"foroudi9","name":"Krombopulos Michael","id":"5e7a7f587c113618206ddd52"},"username":"foroudi9","updatedAt":"2026-02-20T16:19:41.290Z","__v":0,"id":"5e7a80117c113618206de9f9"},{"working":false,"featured":false,"private":false,"stars":["5e7a7f587c113618206ddd1d","5ea6e00c9a2c7b00176937f5","5eb485bc9a2c7b0017693819","5ebcc0c9658b34001590fea1","5f51a9cbb1ed0d0014c0006d","5f5832d0b1ed0d0014c0007c","5e94a4f33fd9680017950252","5fc10117d4849b0013135bd3","5f3c93a90c6c470015d2feb9","5ffc3f4ddf59c70014cdc510","5fcb406adf59c70014cdc4c3","60d6a4dc063978001a1c6e92","60f5267ff4fe08001a0a6216","6109903e063978001a1c6ec2","614a8cc5f4fe08001a0a628e","616675d6063978001a1c6f4c","617bd2eaf4fe08001a0a62df","617c6247f4fe08001a0a62e0","6185ecc5f4fe08001a0a62ee","61a02c60063978001a1c6f9b","61a4c6fb063978001a1c6fa9","61a797eb063978001a1c6faf","60cb691ddf59c70014cdc6e8","61edca42fa146100147f9a7a","620372defa14610014811007","6207efcbfa1461001481557d","6238896d7917e4001407e88a","62756dfbcbcd96001965fecf","624a4a3b7917e4001408e1a7","5e7a7f587c113618206ddd8d","6288c0f3cbcd960019671f19","62c5b835ad0a68001af80048","62da707fad0a68001af8d8e5","62fba7a8ad0a68001afa5860","5f60c298b1ed0d0014c00087","63139741d12ead001af40056","631c6ba4d12ead001af46c0d","634cce2dc0b6ee001abcb586","635835bad12ead001af80602","635afb92c0b6ee001abdda68","6364f0d524251a001abc94c3","6380e454d12ead001afa67ae","638230e2d12ead001afa7d6f","5e7a7f587c113618206ddd52","63bdfee1d12ead001afe71e4","6473170da58c94001ac9c7ee","6477c7f9454380001a9c2e71","64b73f87073c7a001a88412a","64bbf2515913c5001a3faeee","6238d8aafa1461001483fd4b","65804ab3fe89e9001a1f868a","62221c907917e40014067e8c","657b37ab85611d001af251ba","659c4616fe89e9001a20c574","66054fb585611d001af8c681","6630391cf348b4001985f049","666c1580d15e30001ba106f8","6689c6f4ad5cac00198432e7","668b1848ad5cac00198440c1","6443f7b4a58c94001ac74100","67600071b808e100193409f6","678e5f332909a9001a02a0d1","679021ca2909a9001a02bd9c","6463865e454380001a9b315c","67b6882676e8b4001a2527c9","685894475d14de001ac7b820","679e988c726a2e001aab1b31","689bec213bc53b001a4e30dd","68aa89adabb222001a3fdd9e","68cc8f48abb222001a423173","68d770193bc53b001a531249","68e04eaeb503bb001a9c6e6c","690a71862173f0001a8c3acc","639eeb9224251a001ac05e9f","691eba3e9fa0ee001aa4f2fe","66ffd0f3522bf8001ae9f02d","6934861a276171001a4a0d20","694b88fb75c346001ac82a2e","6976c2d47faa73001a370fb9","6977429680748c001a8aacd0","69987b8cb04833001acfa700"],"images":[],"categories":["5e7a80dd7c113618206df0ad"],"publicCategories":["Automatically Converted"],"privateCategories":[],"_id":"5e7a80417c113618206dede0","title":"st_Ms2SD1.fs","rawFragmentSource":"/*\r\n{\r\n  \"CATEGORIES\": [\r\n    \"Automatically Converted\"\r\n  ],\r\n  \"DESCRIPTION\": \"Automatically converted from https://www.shadertoy.com/view/Ms2SD1\",\r\n  \"IMPORTED\": [\r\n    \r\n  ],\r\n  \"INPUTS\": [\r\n    {\r\n      \"NAME\": \"iMouse\",\r\n      \"TYPE\": \"point2D\"\r\n    },\r\n    {\r\n      \"NAME\": \"SEA_FREQ\",\r\n      \"MIN\": 0.0,\r\n      \"MAX\": 1.0,\r\n      \"TYPE\": \"float\",\r\n      \"DEFAULT\": 0.16\r\n    },\r\n    {\r\n      \"NAME\": \"SEA_CHOPPY\",\r\n      \"MIN\": 0.0,\r\n      \"MAX\": 8.0,\r\n      \"TYPE\": \"float\",\r\n      \"DEFAULT\": 4.0\r\n    },\r\n    {\r\n      \"NAME\": \"SEA_HEIGHT\",\r\n      \"MIN\": 0.0,\r\n      \"MAX\": 3.0,\r\n      \"TYPE\": \"float\",\r\n      \"DEFAULT\": 0.6\r\n    },\r\n    {\r\n      \"NAME\": \"SEA_SPEED\",\r\n      \"MIN\": 0.0,\r\n      \"MAX\": 2.0,\r\n      \"TYPE\": \"float\",\r\n      \"DEFAULT\": 0.8\r\n    },\r\n\t{\r\n\t\t\"NAME\": \"SEA_BASE\",\r\n\t\t\"TYPE\": \"color\",\r\n\t\t\"DEFAULT\": [\r\n\t\t\t0.1,\r\n\t\t\t0.19,\r\n\t\t\t0.22,\r\n\t\t\t1.0\r\n\t\t]\r\n\t},\r\n\t{\r\n\t\t\"NAME\": \"SEA_WATER_COLOR\",\r\n\t\t\"TYPE\": \"color\",\r\n\t\t\"DEFAULT\": [\r\n\t\t\t0.8,\r\n\t\t\t0.9,\r\n\t\t\t0.6,\r\n\t\t\t1.0\r\n\t\t]\r\n\t}\t\r\n  ]\r\n}\r\n*/\r\n\r\n\r\n// \"Seascape\" by Alexander Alekseev aka TDM - 2014\r\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n\r\nconst int NUM_STEPS = 8;\r\nconst float PI\t \t= 3.1415;\r\nconst float EPSILON\t= 1e-3;\r\nfloat EPSILON_NRM\t= 0.1 / RENDERSIZE.x;\r\n\r\n// sea\r\nconst int ITER_GEOMETRY = 3;\r\nconst int ITER_FRAGMENT = 5;\r\n//const float SEA_HEIGHT = 0.6;\r\n//const float SEA_CHOPPY = 4.0;\r\n//const float SEA_SPEED = 0.8;\r\n//const float SEA_FREQ = 0.16;\r\n//const vec3 SEA_BASE = vec3(0.1,0.19,0.22);\r\n//const vec3 SEA_WATER_COLOR = vec3(0.8,0.9,0.6);\r\nfloat SEA_TIME = TIME * SEA_SPEED;\r\nmat2 octave_m = mat2(1.6,1.2,-1.2,1.6);\r\n\r\n// math\r\nmat3 fromEuler(vec3 ang) {\r\n\tvec2 a1 = vec2(sin(ang.x),cos(ang.x));\r\n    vec2 a2 = vec2(sin(ang.y),cos(ang.y));\r\n    vec2 a3 = vec2(sin(ang.z),cos(ang.z));\r\n    mat3 m;\r\n    m[0] = vec3(a1.y*a3.y+a1.x*a2.x*a3.x,a1.y*a2.x*a3.x+a3.y*a1.x,-a2.y*a3.x);\r\n\tm[1] = vec3(-a2.y*a1.x,a1.y*a2.y,a2.x);\r\n\tm[2] = vec3(a3.y*a1.x*a2.x+a1.y*a3.x,a1.x*a3.x-a1.y*a3.y*a2.x,a2.y*a3.y);\r\n\treturn m;\r\n}\r\nfloat hash( vec2 p ) {\r\n\tfloat h = dot(p,vec2(127.1,311.7));\t\r\n    return fract(sin(h)*43758.5453123);\r\n}\r\nfloat noise( in vec2 p ) {\r\n    vec2 i = floor( p );\r\n    vec2 f = fract( p );\t\r\n\tvec2 u = f*f*(3.0-2.0*f);\r\n    return -1.0+2.0*mix( mix( hash( i + vec2(0.0,0.0) ), \r\n                     hash( i + vec2(1.0,0.0) ), u.x),\r\n                mix( hash( i + vec2(0.0,1.0) ), \r\n                     hash( i + vec2(1.0,1.0) ), u.x), u.y);\r\n}\r\n\r\n// lighting\r\nfloat diffuse(vec3 n,vec3 l,float p) {\r\n    return pow(dot(n,l) * 0.4 + 0.6,p);\r\n}\r\nfloat specular(vec3 n,vec3 l,vec3 e,float s) {    \r\n    float nrm = (s + 8.0) / (3.1415 * 8.0);\r\n    return pow(max(dot(reflect(e,n),l),0.0),s) * nrm;\r\n}\r\n\r\n// sky\r\nvec3 getSkyColor(vec3 e) {\r\n    e.y = max(e.y,0.0);\r\n    vec3 ret;\r\n    ret.x = pow(1.0-e.y,2.0);\r\n    ret.y = 1.0-e.y;\r\n    ret.z = 0.6+(1.0-e.y)*0.4;\r\n    return ret;\r\n}\r\n\r\n// sea\r\nfloat sea_octave(vec2 uv, float choppy) {\r\n    uv += noise(uv);        \r\n    vec2 wv = 1.0-abs(sin(uv));\r\n    vec2 swv = abs(cos(uv));    \r\n    wv = mix(wv,swv,wv);\r\n    return pow(1.0-pow(wv.x * wv.y,0.65),choppy);\r\n}\r\n\r\nfloat map(vec3 p) {\r\n    float freq = SEA_FREQ;\r\n    float amp = SEA_HEIGHT;\r\n    float choppy = SEA_CHOPPY;\r\n    vec2 uv = p.xz; uv.x *= 0.75;\r\n    \r\n    float d, h = 0.0;    \r\n    for(int i = 0; i < ITER_GEOMETRY; i++) {        \r\n    \td = sea_octave((uv+SEA_TIME)*freq,choppy);\r\n    \td += sea_octave((uv-SEA_TIME)*freq,choppy);\r\n        h += d * amp;        \r\n    \tuv *= octave_m; freq *= 1.9; amp *= 0.22;\r\n        choppy = mix(choppy,1.0,0.2);\r\n    }\r\n    return p.y - h;\r\n}\r\n\r\nfloat map_detailed(vec3 p) {\r\n    float freq = SEA_FREQ;\r\n    float amp = SEA_HEIGHT;\r\n    float choppy = SEA_CHOPPY;\r\n    vec2 uv = p.xz; uv.x *= 0.75;\r\n    \r\n    float d, h = 0.0;    \r\n    for(int i = 0; i < ITER_FRAGMENT; i++) {        \r\n    \td = sea_octave((uv+SEA_TIME)*freq,choppy);\r\n    \td += sea_octave((uv-SEA_TIME)*freq,choppy);\r\n        h += d * amp;        \r\n    \tuv *= octave_m; freq *= 1.9; amp *= 0.22;\r\n        choppy = mix(choppy,1.0,0.2);\r\n    }\r\n    return p.y - h;\r\n}\r\n\r\nvec3 getSeaColor(vec3 p, vec3 n, vec3 l, vec3 eye, vec3 dist) {  \r\n    float fresnel = 1.0 - max(dot(n,-eye),0.0);\r\n    fresnel = pow(fresnel,3.0) * 0.65;\r\n        \r\n    vec3 reflected = getSkyColor(reflect(eye,n));    \r\n    vec3 refracted = SEA_BASE.rgb + diffuse(n,l,80.0) * SEA_WATER_COLOR.rgb * 0.12; \r\n    \r\n    vec3 color = mix(refracted,reflected,fresnel);\r\n    \r\n    float atten = max(1.0 - dot(dist,dist) * 0.001, 0.0);\r\n    color += SEA_WATER_COLOR.rgb * (p.y - SEA_HEIGHT) * 0.18 * atten;\r\n    \r\n    color += vec3(specular(n,l,eye,60.0));\r\n    \r\n    return color;\r\n}\r\n\r\n// tracing\r\nvec3 getNormal(vec3 p, float eps) {\r\n    vec3 n;\r\n    n.y = map_detailed(p);    \r\n    n.x = map_detailed(vec3(p.x+eps,p.y,p.z)) - n.y;\r\n    n.z = map_detailed(vec3(p.x,p.y,p.z+eps)) - n.y;\r\n    n.y = eps;\r\n    return normalize(n);\r\n}\r\n\r\nfloat heightMapTracing(vec3 ori, vec3 dir, out vec3 p) {  \r\n    float tm = 0.0;\r\n    float tx = 1000.0;    \r\n    float hx = map(ori + dir * tx);\r\n    if(hx > 0.0) return tx;   \r\n    float hm = map(ori + dir * tm);    \r\n    float tmid = 0.0;\r\n    for(int i = 0; i < NUM_STEPS; i++) {\r\n        tmid = mix(tm,tx, hm/(hm-hx));                   \r\n        p = ori + dir * tmid;                   \r\n    \tfloat hmid = map(p);\r\n\t\tif(hmid < 0.0) {\r\n        \ttx = tmid;\r\n            hx = hmid;\r\n        } else {\r\n            tm = tmid;\r\n            hm = hmid;\r\n        }\r\n    }\r\n    return tmid;\r\n}\r\n\r\n// main\r\nvoid main(){\r\n\tvec2 uv = gl_FragCoord.xy / RENDERSIZE.xy;\r\n    uv = uv * 2.0 - 1.0;\r\n    uv.x *= RENDERSIZE.x / RENDERSIZE.y;    \r\n    float time = TIME * 0.3 + iMouse.x*0.01;\r\n        \r\n    // ray\r\n    vec3 ang = vec3(sin(time*3.0)*0.1,sin(time)*0.2+0.3,time);    \r\n    vec3 ori = vec3(0.0,3.5,time*5.0);\r\n    vec3 dir = normalize(vec3(uv.xy,-2.0)); dir.z += length(uv) * 0.15;\r\n    dir = normalize(dir) * fromEuler(ang);\r\n    \r\n    // tracing\r\n    vec3 p;\r\n    heightMapTracing(ori,dir,p);\r\n    vec3 dist = p - ori;\r\n    vec3 n = getNormal(p, dot(dist,dist) * EPSILON_NRM);\r\n    vec3 light = normalize(vec3(0.0,1.0,0.8)); \r\n             \r\n    // color\r\n    vec3 color = mix(\r\n        getSkyColor(dir),\r\n        getSeaColor(p,n,light,dir,dist),\r\n    \tpow(smoothstep(0.0,-0.05,dir.y),0.3));\r\n        \r\n    // post\r\n\tgl_FragColor = vec4(pow(color,vec3(0.75)), 1.0);\r\n}","rawVertexSource":"void main() {\n\tvv_vertShaderInit();\n}","thumbnailCloudinaryId":"zj5jxdxwytndvoufcfct","description":"Automatically converted from https://www.shadertoy.com/view/Ms2SD1","shaderType":"generator","oldId":"4809","createdAt":"2019-09-26T05:57:28.113Z","user":{"_id":"5e7a7f587c113618206ddd1d","username":"mochfarizilham","name":"Moch Fariz Ilham","id":"5e7a7f587c113618206ddd1d"},"username":"mochfarizilham","updatedAt":"2026-02-20T16:30:42.881Z","__v":1,"id":"5e7a80417c113618206dede0"},{"working":false,"featured":false,"private":false,"stars":["699584e3d1b29b0019134d01"],"images":[],"categories":["5e88a5ad3fd9680017950227"],"publicCategories":[],"privateCategories":["Color"],"_id":"69984561b04833001acfa23c","title":"color picker","rawFragmentSource":"/*{\n    \"DESCRIPTION\": \"Text / Logo Color Picker\",\n    \"CREDIT\": \"ChatGPT\",\n    \"ISFVSN\": \"2\",\n    \"CATEGORIES\": [ \"Color\" ],\n    \"INPUTS\": [\n        {\"NAME\":\"inputImage\",\"TYPE\":\"image\"},\n        {\n            \"NAME\":\"color\",\n            \"TYPE\":\"color\",\n            \"DEFAULT\":[1.0,0.0,0.0,1.0]\n        },\n        {\n            \"NAME\":\"intensity\",\n            \"TYPE\":\"float\",\n            \"DEFAULT\":1.0,\n            \"MIN\":0.0,\n            \"MAX\":2.0\n        },\n        {\n            \"NAME\":\"mixAmount\",\n            \"TYPE\":\"float\",\n            \"DEFAULT\":1.0,\n            \"MIN\":0.0,\n            \"MAX\":1.0\n        }\n    ]\n}*/\n\nvoid main() {\n    vec2 uv = isf_FragNormCoord.xy;\n\n    vec4 img = IMG_NORM_PIXEL(inputImage, uv);\n\n    // Apply color tint\n    vec3 tinted = img.rgb * color.rgb * intensity;\n\n    // Blend original vs tinted\n    vec3 finalColor = mix(img.rgb, tinted, mixAmount);\n\n    gl_FragColor = vec4(finalColor, img.a);\n}","rawVertexSource":"\nvoid main() {\n  isf_vertShaderInit();\n}\n","description":"Text / Logo Color Picker","scale":1,"user":{"_id":"699584e3d1b29b0019134d01","username":"guamen","name":"Ohiojemen Emmanuel Areguamen","id":"699584e3d1b29b0019134d01"},"username":"guamen","createdAt":"2026-02-20T11:28:33.233Z","updatedAt":"2026-02-20T11:29:23.138Z","__v":2,"thumbnailCloudinaryId":"rdoiawmgprzetqsrdmgy","id":"69984561b04833001acfa23c"},{"working":false,"featured":true,"private":false,"stars":["5e7a7f587c113618206dda1c","5e7a7f587c113618206ddc23","5e7a7f587c113618206ddc49","5e7a7f587c113618206ddc6e","5e7a7f587c113618206ddc53","5e7a7f587c113618206ddcc5","5e7a7f587c113618206ddceb","5e7a7f587c113618206ddcf4","5e7a7f587c113618206ddd2c","5e7a7f587c113618206ddd46","5e7b2acbda37220013c9c32e","5e7a7f587c113618206dda9d","5e844e27978b6200133227ce","5e7a7f587c113618206ddc81","5e90ede7978b6200133227e5","5e945a923fd968001795024b","5e94cb3f3fd9680017950255","5ea5a15a658b34001590fe27","5ea6e00c9a2c7b00176937f5","5ea5de359a2c7b00176937ef","5eb0eca59a2c7b001769380e","5eb485bc9a2c7b0017693819","5eb85ebf658b34001590fe79","5eb889039a2c7b0017693835","5ebcc0c9658b34001590fea1","5ebf549b9a2c7b0017693854","5ec340a7658b34001590feb5","5ec806da658b34001590fec3","5ece153c658b34001590fed6","5ebc0ee4658b34001590fe9f","5edfff90658b34001590ff03","5efbb75db1ed0d0014bfffe8","5f1054c6b1ed0d0014c00006","5f1b196b0c6c470015d2fe97","5f2c5e9bb1ed0d0014c0002d","5f4b4c6eb1ed0d0014c00063","5f51a9cbb1ed0d0014c0006d","5f77f4e9d4849b0013135b70","5f8cf070d4849b0013135b98","5eb159c99a2c7b0017693810","5f9438afd4849b0013135b9f","5fa1d924d4849b0013135bb1","5f32fe880c6c470015d2feb4","5fc95589d4849b0013135bf0","5fcf4774d4849b0013135bfa","5fd09f0ddf59c70014cdc4ce","5fd4f460df59c70014cdc4da","5fd98eebdf59c70014cdc4df","6015030ad4849b0013135c5d","60312f67df59c70014cdc56f","6063c67cd4849b0013135d82","6067e767df59c70014cdc64c","6079af02d4849b0013135db3","607c3995d4849b0013135dbe","608bf3c2d4849b0013135de8","60a7ace5df59c70014cdc6b9","60c1b13cdf59c70014cdc6d6","60cedffcd4849b0013135e43","60ddce08f4fe08001a0a6204","60e327c2063978001a1c6e9a","60e84399f4fe08001a0a620b","60f36edaf4fe08001a0a6214","60faf120f4fe08001a0a6221","60f5267ff4fe08001a0a6216","61197e0cf4fe08001a0a626a","6125d6b0063978001a1c6ef7","612ccf3f063978001a1c6f02","614bd8a6063978001a1c6f22","6150de8a063978001a1c6f29","61750d18f4fe08001a0a62d4","617581b3f4fe08001a0a62d7","6179b859063978001a1c6f6b","617c6247f4fe08001a0a62e0","617ed8c2063978001a1c6f70","6187097af4fe08001a0a62ef","5eb7bfc1658b34001590fe75","618825e8f4fe08001a0a62f1","61a14896063978001a1c6f9e","61a797eb063978001a1c6faf","61c6d4d9fa146100147d4854","61d5b38dfa146100147e1e78","61ec519ffa146100147f8274","5fe16ce0d4849b0013135c19","6168c19ff4fe08001a0a62c8","6210fae67917e4001405d5db","62285666fa14610014830c80","622d874b7917e400140734f7","622d874b7917e400140734f7","625d52557917e400140a305a","625eef667917e400140a4c40","626deb93fa14610014876937","5e7a7f587c113618206ddd8d","628ab710cbcd960019673352","628b4fdbcbcd9600196739e1","62b705a6ad0a68001af7395f","62d61f6dad0a68001af8af8e","62da707fad0a68001af8d8e5","62fb14f2ad0a68001afa532a","62fba7a8ad0a68001afa5860","62dea623ad0a68001af90e82","63110b88c0b6ee001ab98364","63119b25d12ead001af3ea8b","63139741d12ead001af40056","631c6ba4d12ead001af46c0d","63225a4fd12ead001af4e36f","63249318c0b6ee001abaa08e","633167e0d12ead001af5960f","635835bad12ead001af80602","636ac63024251a001abcff44","637aa224d12ead001afa1699","62c5b835ad0a68001af80048","638230e2d12ead001afa7d6f","6383614cd12ead001afa8be9","639eeb9224251a001ac05e9f","6238d8aafa1461001483fd4b","63bdfee1d12ead001afe71e4","63c162d824251a001ac2663a","63cc297fd12ead001aff1af2","63eb647954062a0019bbddce","6411c24e24251a001ac7b87f","6420cb5924251a001ac88a12","642fbe4154062a0019c06613","64529009a58c94001ac8324f","6331d80ed12ead001af59b4b","63a4715d24251a001ac0e3ab","6493e879073c7a001a869268","64bbf2515913c5001a3faeee","64bd20875913c5001a3fbf68","64e08e17388bc0001a1740fe","64edaefa4fca60001aba9ab2","65066e9d388bc0001a19a4a5","651470ec388bc0001a1a701c","652c4de2f4fa87001b377518","654c242c85611d001aeee3b3","655bbf4ef4fa87001b39f739","655f3dc085611d001af01f2a","65616a8b85611d001af048fa","65641c6685611d001af06526","656bc7f8f4fa87001b3b24ce","657d8155fe89e9001a1f663a","62221c907917e40014067e8c","656ad4dcf4fa87001b3b1ab2","65c93e5a85611d001af60d86","65d67e329f12c7001aea031e","65e7980b9f12c7001aeaaf4d","66054fb585611d001af8c681","663c2da8f348b4001986c136","666c5e8ad15e30001ba10abc","667c1117be01f9001aa223e7","6690ecd9ad5cac0019848fa4","66bb134a6049470019615baf","666c6de8e0ca9e001a0299a8","66d0b5cc604947001962ce94","66ddb4718d90c9001a4b8545","66c6d3938d90c9001a49dfdd","663835c3b9e5d4001a9a95fb","6722ba24a085a6001a5a8b5c","673a31fca085a6001a5c4520","6749918f7c51b3001a5274bc","6750a702a085a6001a5e70a8","6757b61ea085a6001a5eec2f","676ee5a6726a2e001aa7de18","6771777e2909a9001a00c1c2","6771d0ed726a2e001aa7ffa6","677bfa5a2909a9001a016894","677dde662909a9001a0185c6","678d2f6b2909a9001a029147","5f36d4cfb1ed0d0014c00034","679a84c52909a9001a035a51","67c3679c63819f001a74d597","67cc34e963819f001a754d30","67d5cbb2d7aebf0019e1cfe9","67d84765d7aebf0019e1eb82","5f5832d0b1ed0d0014c0007c","67e767a863819f001a77f1be","5e7a7f587c113618206ddadd","67f1bf8ea0bb96001afdec71","6808ba0becc993001a2b2934","680f414ce487fa001ab13dd9","681fbddf932476001a377c1e","67b9a7bb76e8b4001a2584da","685d739e932476001a3aa285","68882a962f6812001a561722","6881576f2f6812001a55c790","68a1fb4c3bc53b001a4ea8f1","68a1fb4c3bc53b001a4ea8f1","68a6f061abb222001a3fbccb","68bf75dfabb222001a410fc5","68e16a13083089001a67c451","691b542c66081f001a4b7d99","691eba3e9fa0ee001aa4f2fe","692b62d0ce8b81001982424a","696fe5917faa73001a3615b0","69700ac080748c001a89affb","698c1079547ea0001a4b9847","6993df3cb04833001acf53c6"],"images":[],"categories":["5e7a80dd7c113618206df0a6","5e7a80de7c113618206df138"],"publicCategories":["Generator"],"privateCategories":["space"],"_id":"5e7a7fa17c113618206de17a","title":"SpaceIsThePlace","rawFragmentSource":"/*{\n  \"CREDIT\": \"by mojovideotech\",\n  \"DESCRIPTION\": \"\",\n  \"CATEGORIES\": [\n    \"generator\",\n    \"space\"\n  ],\n  \"INPUTS\": [\n    {\n      \"NAME\": \"nebula\",\n      \"TYPE\": \"bool\",\n      \"DEFAULT\": 0\n    },\n    {\n      \"NAME\": \"brightness\",\n      \"TYPE\": \"float\",\n      \"DEFAULT\": 0.25,\n      \"MIN\": 0,\n      \"MAX\": 0.5\n    },\n    {\n      \"NAME\": \"zoom\",\n      \"TYPE\": \"float\",\n      \"DEFAULT\": 2.5,\n      \"MIN\": 0.25,\n      \"MAX\": 20\n    },\n    {\n      \"NAME\": \"saturation\",\n      \"TYPE\": \"float\",\n      \"DEFAULT\": 0.5,\n      \"MIN\": 0,\n      \"MAX\": 1\n    },\n    {\n      \"NAME\": \"distfading\",\n      \"TYPE\": \"float\",\n      \"DEFAULT\": 0.25,\n      \"MIN\": 0,\n      \"MAX\": 0.5\n    },\n    {\n      \"NAME\": \"depth\",\n      \"TYPE\": \"float\",\n      \"DEFAULT\": 0.25,\n      \"MIN\": 0.1,\n      \"MAX\": 1\n    },\n    {\n      \"NAME\": \"density\",\n      \"TYPE\": \"float\",\n      \"DEFAULT\": 0.75,\n      \"MIN\": 0.5,\n      \"MAX\": 2\n    },\n    {\n      \"NAME\": \"morph\",\n      \"TYPE\": \"float\",\n      \"DEFAULT\": 0.89,\n      \"MIN\": 0.5,\n      \"MAX\": 1\n    },\n    {\n      \"NAME\": \"rate\",\n      \"TYPE\": \"float\",\n      \"DEFAULT\": 0.005,\n      \"MIN\": -0.1,\n      \"MAX\": 0.1\n    },\n    {\n      \"NAME\": \"move\",\n      \"TYPE\": \"point2D\",\n      \"DEFAULT\": [\n        0,\n        0\n      ]\n    }\n  ]\n}*/\n\n///////////////////////////////////////////\n// SpaceIsThePlace  by mojovideotech\n//\n// Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n//\n// based on :\n// shadertoy.com/\\XlfGRj\tby Kali\n///////////////////////////////////////////\n \n#define iterations 7\n#define volsteps 7\n#define pi   3.141592653589793 \t// pi\n\nfloat field(in vec3 p) {\n\tfloat strength = 7. + .03 * log(1.e-6 + fract(sin(TIME) * 4373.11));\n\tfloat accum = 0.;\n\tfloat prev = 0.;\n\tfloat tw = 0.;\n\tfor (int i = 0; i < 7; ++i) {\n\t\tfloat mag = dot(p, p);\n\t\tp = abs(p) / mag + vec3(-.5, -.4, -1.5);\n\t\tfloat w = exp(-float(i) / 7.);\n\t\taccum += w * exp(-strength * pow(abs(mag - prev), 2.3));\n\t\ttw += w;\n\t\tprev = mag;\n\t}\n\treturn max(0., 5. * accum / tw - .7);\n}\n\nvoid main() {\n\tvec2 uv=gl_FragCoord.xy/RENDERSIZE.xy-.5;\n  \tuv.y*=RENDERSIZE.y/RENDERSIZE.x;\n\tvec3 p = vec3(uv / 4., 0) + vec3(1., -1.3, 0.);\n\tp.x -= 0.25*move.x;\n\tp.y -= 0.25*move.y;\n\tp.x += 0.25*(1.0)*5.0*cos(0.01*TIME)+0.001*TIME;\n\tp.y += 0.25*(1.0)*5.0*sin(0.01*TIME)+0.001*TIME;\n\tp.z += 0.003*TIME;\n\tfloat speed = rate * cos(TIME*0.02 + pi/4.0);\n\tvec3 dir=vec3(uv*zoom,1.);\n\tvec3 from=vec3(0.0, 0.0,0.0);\n\tvec3 forward = vec3(0.,0.,1.);\n\tfloat a1 = pi * (move.x/RENDERSIZE.x-.5);\n\tmat2 rot1 = mat2(cos(a1),sin(a1),-sin(a1),cos(a1));\n\tfloat a2 = pi * (move.y/RENDERSIZE.y-.5); .6;\n\tmat2 rot2 = mat2(cos(a2),sin(a2),-sin(a2),cos(a2));\n\tp.xz *= rot1;\n\tp.xy *= rot1;\n\tp.yz *= -rot2;\n\tp = abs(vec3(density)-mod(p,vec3(density*2.)));\n\tfloat t = field(p);\n\tfloat v2 = (1. - exp((abs(uv.x) - 1.) * 6.)) * (1. - exp((abs(uv.y) - 1.) * 6.));\n\tfrom.x += 5.0*(0.01*rate) + 0.001*TIME;\n\tfrom.y += 5.0*(0.01*rate) +0.001*TIME;\n\tfrom.z += 0.003*TIME;\n\tdir.xz*=rot1;\n\tforward.xz *= rot1;\n\tdir.xy*=rot1;\n\tforward.xy *= rot1;\n\tdir.yz*=-rot2;\n\tforward.yz *= -rot2;\n\tfrom.xz*=rot1;\n\tfrom.xy*=rot1;\n\tfrom.yz*=-rot2;\n\tfrom += (move.x-.5)*vec3(-forward.z,0.,forward.x);\n\tfrom += (move.y-.5)*vec3(0.,-forward.z, forward.y);\n\tfloat zooom = (TIME-3311.)*speed;\n\tfrom += forward* zooom;\n\tfloat sampleShift = mod( zooom, depth );\n\tfloat zoffset = -sampleShift;\n\tsampleShift /= depth; \n\tfloat s=0.1;\n\tvec3 v=vec3(0.);\n\tfor (int r=0; r<volsteps; r++) {\n\t\tvec3 p=from+(s+zoffset)*dir;\n\t\tp = abs(vec3(density)-mod(p,vec3(density*2.))); \n\t\tfloat pa,a=pa=0.;\n\t\tfor (int i=0; i<iterations; i++) {\n\t\t\tp=abs(p)/dot(p,p)-morph; \n\t\t\tfloat D = abs(length(p)-pa); \n\t\t\ta += i > 7 ? min( 12., D) : D;\n\t\t\tpa=length(p);\n\t\t}\n\t\ta*=a*a;\n\t\tfloat s1 = s+zoffset;\n\t\tfloat fade = pow(distfading,max(0.,float(r)-sampleShift));\n\t\tfloat dm=max(0.,2.0-a*a*.001);\n\t\tif (r>3) fade*=1.-dm; \n\t\tif ( r == 0 ) fade *= 1. - sampleShift;\n\t\tif ( r == volsteps-1 ) fade *= sampleShift;\n\t\tv+=vec3(s1,s1*s1,s1*s1*s1*s1)*a*brightness*fade;\n\t\ts+=depth;\n\t}\n\tv=mix(vec3(length(v)),v,saturation); \n\tif (nebula) {\t\n\t\tvec4 forCol = vec4(v*.01,1.);\n\t\tvec4 backCol = mix(.4, 1., v2) * vec4(1.8 * t * t * t, 1.4 * t * t, t, 1.0);\n\t\tbackCol *= 0.2;\n\t\tbackCol.b *= 1.0;\n\t\tbackCol.r = mix(backCol.r, backCol.b, 0.2);\n\t\tforCol.g *= max((backCol.r * 4.0), 1.0);\n\t\tforCol.r += backCol.r * 0.05;\n\t\tforCol.b += 0.5*mix(backCol.g, backCol.b, 0.8);\n\t\tgl_FragColor = forCol;\n\t}\n\telse\t\n\t{\t\n\t\tvec4 col = vec4(vec3(v*.01),1.);\n\t\tgl_FragColor = col;\n\t}\n}","rawVertexSource":"void main() {\n\tisf_vertShaderInit();\n}","thumbnailCloudinaryId":"uf6tsj2c0xnjmkn3sm7n","description":"","shaderType":"generator","oldId":"799","createdAt":"2016-01-08T05:45:39.406Z","user":{"_id":"5e7a7f587c113618206dda0d","username":"mojovideotech","name":"Mojo Video Tech","id":"5e7a7f587c113618206dda0d"},"username":"mojovideotech","updatedAt":"2026-02-17T03:26:54.737Z","__v":11,"id":"5e7a7fa17c113618206de17a"},{"working":false,"featured":false,"private":false,"stars":["5e7a7f587c113618206ddceb","5e7a7f587c113618206ddda1","5eb485bc9a2c7b0017693819","5eb889039a2c7b0017693835","5ebf549b9a2c7b0017693854","5ed00fba9a2c7b001769388a","5f0a1accb1ed0d0014bffffc","5f0da3e6b1ed0d0014c00003","5f1b196b0c6c470015d2fe97","5f4b4c6eb1ed0d0014c00063","5f51a9cbb1ed0d0014c0006d","5e94a4f33fd9680017950252","5fb19e65d4849b0013135bc0","5fb60f5bdf59c70014cdc484","5fd46b5cdf59c70014cdc4d7","5fe5f08fdf59c70014cdc4e8","5f3c93a90c6c470015d2feb9","6015030ad4849b0013135c5d","605dfe63df59c70014cdc640","6063c67cd4849b0013135d82","5f7b71dbd4849b0013135b75","60c1b13cdf59c70014cdc6d6","60cedffcd4849b0013135e43","60ddce08f4fe08001a0a6204","60f36edaf4fe08001a0a6214","60f5267ff4fe08001a0a6216","61240672063978001a1c6ef6","6127087d063978001a1c6efb","615226f5f4fe08001a0a6299","61559c2ef4fe08001a0a62a7","617bd2eaf4fe08001a0a62df","617c6247f4fe08001a0a62e0","6185ecc5f4fe08001a0a62ee","6187097af4fe08001a0a62ef","618825e8f4fe08001a0a62f1","6194cf11f4fe08001a0a6300","61a797eb063978001a1c6faf","61a87341063978001a1c6fb0","61bdb1e2fa146100147cd01b","6053a3ecdf59c70014cdc627","61fbab92fa14610014809aff","6207efcbfa1461001481557d","6168c19ff4fe08001a0a62c8","607e0cf5df59c70014cdc67e","6266a0d9fa1461001486c365","62756dfbcbcd96001965fecf","628e1d64cbcd960019675fae","628fc259cbcd960019677603","5e7a7f587c113618206ddd52","5e7a7f587c113618206ddd52","5e7a7f587c113618206ddd52","5e7a7f587c113618206ddd52","62b705a6ad0a68001af7395f","62c5b835ad0a68001af80048","5e7a7f587c113618206ddd8d","62da707fad0a68001af8d8e5","627ef23dcbcd96001966668a","62fb14f2ad0a68001afa532a","62fba7a8ad0a68001afa5860","63042349cbcd9600196ce759","63119b25d12ead001af3ea8b","63139741d12ead001af40056","63225a4fd12ead001af4e36f","634cce2dc0b6ee001abcb586","635835bad12ead001af80602","63628b5ad12ead001af8a325","637aa224d12ead001afa1699","6380e454d12ead001afa67ae","638230e2d12ead001afa7d6f","63aa4ea4d12ead001afd5415","639d64b3d12ead001afc7f51","63c162d824251a001ac2663a","61a2b1db063978001a1c6fa5","63ebb36954062a0019bbe072","642c260a24251a001ac99019","64419d0fa58c94001ac7241b","645dfd15454380001a9ae3af","649aa7fb073c7a001a8716d1","63a4715d24251a001ac0e3ab","6493e879073c7a001a869268","649caa135913c5001a3e6b13","64ab22d1073c7a001a87c0c3","64b73f87073c7a001a88412a","64bbf2515913c5001a3faeee","64f4f44b388bc0001a189936","5f7a04afd4849b0013135b73","5f875d89df59c70014cdc438","65066e9d388bc0001a19a4a5","652c4de2f4fa87001b377518","63bd87c024251a001ac23868","653ee9c685611d001aee4ea5","654192ed85611d001aee761e","654c242c85611d001aeee3b3","65616a8b85611d001af048fa","655ed7c385611d001af0193d","62221c907917e40014067e8c","656ad4dcf4fa87001b3b1ab2","6595d3f3fe89e9001a206d9b","659c4616fe89e9001a20c574","65b151d285611d001af4f995","65b8de0185611d001af552e1","65c93e5a85611d001af60d86","65e7980b9f12c7001aeaaf4d","6602e9a874e2f0001ab5ac82","66156fabf348b4001984673e","661f330ff348b40019850f6e","661deb97b9e5d4001a98f280","6630391cf348b4001985f049","663c2da8f348b4001986c136","666c6de8e0ca9e001a0299a8","642c873f24251a001ac99526","6689c6f4ad5cac00198432e7","6654b868d15e30001b9fb603","66b073a5604947001960a702","664cf976e0ca9e001a00df42","66d0b5cc604947001962ce94","66c6d3938d90c9001a49dfdd","670b6b9e9e84f80019d12b53","670e831b2e035b001b56612b","673a31fca085a6001a5c4520","673c09afa085a6001a5c5ef1","6749918f7c51b3001a5274bc","6750a702a085a6001a5e70a8","676ee5a6726a2e001aa7de18","678e5f332909a9001a02a0d1","678d2f6b2909a9001a029147","679021ca2909a9001a02bd9c","6463865e454380001a9b315c","67bcfcbd2348540019ddffb9","67c3679c63819f001a74d597","6734a339a085a6001a5bdb1c","67d84765d7aebf0019e1eb82","67e7cf2263819f001a77f559","67f7ddf8d0da12001a75f881","5e7a7f587c113618206ddadd","68024504afd915001ad52769","681be5065d14de001ac4ac94","681fbddf932476001a377c1e","682ff6975d14de001ac5b26b","68334de85d14de001ac5ccba","684aa36c932476001a39986b","685a1580932476001a3a61d0","685d739e932476001a3aa285","688117b4554a4c001a046457","689bec213bc53b001a4e30dd","68a1fb4c3bc53b001a4ea8f1","68bf75dfabb222001a410fc5","68c18cdbabb222001a416ab0","68d770193bc53b001a531249","68dab506b503bb001a9bd691","68e04eaeb503bb001a9c6e6c","6900c7492173f0001a8b385c","68f7b0fb2173f0001a8aac82","690a71862173f0001a8c3acc","639eeb9224251a001ac05e9f","67cce0ef63819f001a755da6","692b62d0ce8b81001982424a","6934861a276171001a4a0d20","69360de6ce8b810019838159","6947ff46ce8b810019855c10","6973db2580748c001a8a5e32","697528c57faa73001a36ebbc","6977429680748c001a8aacd0","698c1079547ea0001a4b9847","6993df3cb04833001acf53c6"],"images":[],"categories":["5e7a80dd7c113618206df110","5e7a80dd7c113618206df0a6","5e7a80de7c113618206df1ec"],"publicCategories":["Generator"],"privateCategories":["clouds","vortex"],"_id":"5e7a80137c113618206dea20","title":"CloudVortex","rawFragmentSource":"/*\n{\n\t\"CREDIT\": \"by mojovideotech\",\n    \"CATEGORIES\": [\n        \"generator\",\n        \"clouds\",\n        \"vortex\"\n    ],\n    \"INPUTS\" : [\n    {\n        \"NAME\" :        \"rate\",\n        \"TYPE\" :        \"float\",\n        \"DEFAULT\" :     1.5,\n        \"MIN\" :         -5.0,\n        \"MAX\" :         5.0\n    },\n    {\n        \"NAME\" :        \"loops\",\n        \"TYPE\" :        \"float\",\n        \"DEFAULT\" :     90.0,\n        \"MIN\" :         50.0,\n        \"MAX\" :         200.0\n    },\n    {\n        \"NAME\" :        \"radius\",\n        \"TYPE\" :        \"float\",\n        \"DEFAULT\" :      1.0,\n        \"MIN\" :         -1.0,\n        \"MAX\" :          3.0\n    },\n    {\n        \"NAME\" :        \"roto\",\n        \"TYPE\" :        \"float\",\n        \"DEFAULT\" :     0.1,\n        \"MIN\" :         -1.0,\n        \"MAX\" :         1.0\n    },\n    {\n        \"NAME\" :        \"turbulance\",\n        \"TYPE\" :        \"float\",\n        \"DEFAULT\" :     2.0,\n        \"MIN\" :         1.0,\n        \"MAX\" :         3.0\n    },\n    {\n        \"NAME\" :        \"color\",\n        \"TYPE\" :        \"bool\",\n        \"DEFAULT\" :     false\n    }\n  ],\n    \"ISFVSN\" : 2.0\n}\n*/\n\n////////////////////////////////////////////////////////////\n// CloudVortex   by mojovideotech\n//\n// based on \n// Protean Clouds\n// by nimitz\n// shadertoy.com\\/3l23Rh\n//\n// Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n////////////////////////////////////////////////////////////\n\n\n\nconst mat3 m3 = mat3(0.33338, 0.56034, -0.71817, -0.87887, 0.32651, -0.15323, 0.15162, 0.69596, 0.61339)*1.93;\n\nfloat T = TIME*rate;\nfloat prm1 = 0.0;\n\nmat2 rot(in float a) {float c = cos(a), s = sin(a);return mat2(c,s,-s,c); }\n\nfloat mag2(vec2 p) {return dot(p,p);}\n\nfloat linstep(in float mn, in float mx, in float x) { return clamp((x - mn)/(mx - mn), 0.0, 1.0); }\n\nvec2 disp(float t) { return vec2(sin(t*0.22)*1.0, cos(t*0.175)*1.0)*2.0; }\n\nvec2 map(vec3 p) {\n    vec3 p2 = p;\n    p2.xy -= disp(p.z).xy;\n    p.xy *= rot(sin(p.z+TIME)*(0.1 + prm1*0.05) + TIME*0.09);\n    float cl = mag2(p2.xy), dspAmp = 0.1 + prm1*0.2;\n    float d = 0.0, z = 1.0, trk = turbulance;\n    p *= 0.61;\n    for(int i = 0; i < 5; i++) {\n\t\tp += sin(p.zxy*0.75*trk + TIME*trk*0.8)*dspAmp;\n        d -= abs(dot(cos(p), sin(p.yzx))*z);\n        z *= 0.57;\n        trk *= 1.4;\n        p = p*m3;\n    }\n    d = abs(d + prm1*3.0) + prm1*0.3 - 2.5 + (1.0 - radius);\n    return vec2(d + cl*0.2 + 0.25, cl);\n}\n\nvec4 render( in vec3 ro, in vec3 rd, float _T ) {\n\tvec4 rez = vec4(0.0);\n    const float ldst = 8.0;\n\tvec3 lpos = vec3(disp(_T + ldst)*0.5, _T + ldst);\n\tfloat t = 1.5, fogT = 0.0, b = floor(loops);\n\tfor(int i=0; i<200; i++) {\n\t\tif(rez.a > 0.99 || float(i) > b) { break; }\n        vec4 col = vec4(0.0);\n        vec3 pos = ro + t*rd;\n        vec2 mpv = map(pos);\n\t\tfloat den = clamp(mpv.x - 0.3, 0.0, 1.0)*1.12;\n\t\tfloat dn = clamp((mpv.x + 2.0), 0.0, 3.0);   \n        if (mpv.x > 0.6) {\n            col = vec4(sin(vec3(5.0, 0.4, 0.2) + mpv.y*0.1 + sin(pos.z*0.4)*0.5 + 1.8)*0.5 + 0.5, 0.08);\n            col *= den*den*den;\n\t\t\tcol.rgb *= linstep(4.0, -2.5, mpv.x)*2.3;\n            float dif =  clamp((den - map(pos + 0.8).x)*0.11111, 0.001, 1.0);\n            dif += clamp((den - map(pos+0.35).x)*0.4, 0.001, 1.0 );\n            col.xyz *= den*(vec3(0.005, 0.045, 0.075) + 1.5*vec3(0.033, 0.07, 0.03)*dif);\n        }\t\t\n\t\tfloat fogC = exp(t*0.2 - 2.2);\n\t\tcol.rgba += vec4(0.06, 0.11, 0.11, 0.1)*clamp(fogC-fogT, 0.0, 1.0);\n\t\tfogT = fogC;\n\t\trez = rez + col*(1.0 - rez.a);\n\t\tt += clamp(0.5 - dn*dn*0.05, 0.09, 0.3);\n\t}\n\treturn clamp(rez, 0.0, 1.0);\n}\n\nfloat getsat(vec3 c) {\n    float mi = min(min(c.x, c.y), c.z);\n    float ma = max(max(c.x, c.y), c.z);\n    return (ma - mi)/(ma + 1e-7);\n}\n\nvec3 iLerp(in vec3 a, in vec3 b, in float x) {\n    vec3 ic = mix(a, b, x) + vec3(1e-6, 0.0 ,0.0);\n    float sd = abs(getsat(ic) - mix(getsat(a), getsat(b), x));\n    vec3 dir = normalize(vec3(2.0*ic.x - ic.y - ic.z, 2.0*ic.y - ic.x - ic.z, 2.0*ic.z - ic.y - ic.x));\n    float lgt = dot(vec3(1.0), ic);\n    float ff = dot(dir, normalize(ic));\n    ic += 1.5*dir*sd*ff*lgt;\n    return clamp(ic, 0.0 ,1.0);\n}\n\nvoid main() \n{\n\tvec2 q = gl_FragCoord.xy/RENDERSIZE.xy;\n    vec2 p = (gl_FragCoord.xy - 0.5*RENDERSIZE.xy)/RENDERSIZE.y;    \n    vec3 ro = vec3(0.0, 0.0, T);\n    ro += vec3(sin(TIME)*0.5, sin(TIME*1.0)*0.0, 0.0);\n    float dspAmp = 0.85, tgtDst = 3.5;\n    ro.xy += disp(ro.z)*dspAmp;\n    vec3 target = normalize(ro - vec3(disp(T + tgtDst)*dspAmp, T + tgtDst));\n    ro.x -= roto*2.0;\n    vec3 rightdir = normalize(cross(target, vec3(0.0, 1.0, 0.0)));\n    vec3 updir = normalize(cross(rightdir, target));\n    rightdir = normalize(cross(updir, target));\n\tvec3 rd=normalize((p.x*rightdir + p.y*updir)*1.0 - target);\n    rd.xy *= rot(-disp(T + 3.5).x*0.2 + roto);\n    prm1 = smoothstep(-0.4, 0.4, sin(TIME*0.3));\n\tvec4 scn = render(ro, rd, T);\n    vec3 col = scn.rgb;\n    if (color) { col = iLerp(col.bgr, col.rgb, clamp(1.0 - prm1, 0.05, 0.9)); }\n\tgl_FragColor = vec4(col, 1.0 );\n}\n","rawVertexSource":"void main() {\n\tisf_vertShaderInit();\n}","thumbnailCloudinaryId":"rz6tvnsqbipugprkifck","description":"","shaderType":"generator","oldId":"4459","createdAt":"2019-06-09T06:04:16.059Z","user":{"_id":"5e7a7f587c113618206dda0d","username":"mojovideotech","name":"Mojo Video Tech","id":"5e7a7f587c113618206dda0d"},"username":"mojovideotech","updatedAt":"2026-02-17T03:33:48.474Z","__v":2,"id":"5e7a80137c113618206dea20"},{"working":false,"featured":false,"private":false,"stars":["5e7a7f587c113618206ddab1","5e7a7f587c113618206ddacc","5e7a7f587c113618206ddb6b","5e7a7f587c113618206ddc32","5e7a7f587c113618206ddd2c","5e945a923fd968001795024b","5eb889039a2c7b0017693835","5ebcc0c9658b34001590fea1","5ebf549b9a2c7b0017693854","5ec63e799a2c7b001769386e","5ece153c658b34001590fed6","5ee7dfdf658b34001590ff29","5e7a7f587c113618206ddcb3","5f51a9cbb1ed0d0014c0006d","5f5832d0b1ed0d0014c0007c","5f7cd9badf59c70014cdc422","5f867b05df59c70014cdc434","5e94a4f33fd9680017950252","5fb19e65d4849b0013135bc0","5fb818b2df59c70014cdc498","5e7a7f587c113618206dda2b","5fcab46dd4849b0013135bf5","5fd1aa1edf59c70014cdc4d5","605dfe63df59c70014cdc640","6064eba8d4849b0013135d84","60770f22d4849b0013135db0","60c1b13cdf59c70014cdc6d6","60ddce08f4fe08001a0a6204","60f36edaf4fe08001a0a6214","612a6ae2f4fe08001a0a6279","61559c2ef4fe08001a0a62a7","617bd2eaf4fe08001a0a62df","617c6247f4fe08001a0a62e0","6186bcae063978001a1c6f7c","618825e8f4fe08001a0a62f1","61a87341063978001a1c6fb0","5e8e4080978b6200133227df","624a4a3b7917e4001408e1a7","625d52557917e400140a305a","628b4fdbcbcd9600196739e1","62b705a6ad0a68001af7395f","62bf841ead0a68001af7c580","62dee331cbcd9600196b3418","62fba7a8ad0a68001afa5860","63119b25d12ead001af3ea8b","63139741d12ead001af40056","633167e0d12ead001af5960f","634cce2dc0b6ee001abcb586","635835bad12ead001af80602","63b8947424251a001ac20867","63bbed9bd12ead001afe55c1","63bd87c024251a001ac23868","63d387c9d12ead001affab8b","643b1f2d24251a001aca8e17","64ab22d1073c7a001a87c0c3","64bbf2515913c5001a3faeee","64dde8924fca60001ab97e93","63d4a39324251a001ac39028","65280b694fca60001abe6085","654a3574f4fa87001b38c9d9","655a972f85611d001aefecdf","65641c6685611d001af06526","657b37ab85611d001af251ba","62221c907917e40014067e8c","656ad4dcf4fa87001b3b1ab2","65e7980b9f12c7001aeaaf4d","6602e9a874e2f0001ab5ac82","661deb97b9e5d4001a98f280","6630391cf348b4001985f049","663c2da8f348b4001986c136","6654b868d15e30001b9fb603","66823dcdad5cac001983c07b","666c6de8e0ca9e001a0299a8","66ffd0f3522bf8001ae9f02d","670e831b2e035b001b56612b","673a31fca085a6001a5c4520","6758a1fda085a6001a5ef92c","6463865e454380001a9b315c","67c8097fd7aebf0019e0a372","67cce0ef63819f001a755da6","67e767a863819f001a77f1be","67ed805cd7aebf0019e3e471","686667be5d14de001ac8c5bb","6881576f2f6812001a55c790","689bec213bc53b001a4e30dd","68a1fb4c3bc53b001a4ea8f1","68ce569fabb222001a42502e","639eeb9224251a001ac05e9f","66b073a5604947001960a702","6900c7492173f0001a8b385c","6993df3cb04833001acf53c6"],"images":[],"categories":["5e7a80dd7c113618206df0b0"],"publicCategories":["Glitch"],"privateCategories":[],"_id":"5e7a80247c113618206deb8a","title":"Time Glitch RGB.fs","rawFragmentSource":"/*{\n  \"DESCRIPTION\": \"Buffers 8 recent frames\",\n  \"CREDIT\": \"by VIDVOX\",\n  \"CATEGORIES\": [\n    \"Glitch\"\n  ],\n  \"INPUTS\": [\n    {\n      \"NAME\": \"inputImage\",\n      \"TYPE\": \"image\"\n    },\n    {\n      \"NAME\": \"inputDelay\",\n      \"LABEL\": \"Buffer\",\n      \"TYPE\": \"color\",\n      \"DEFAULT\": [\n        0.25,\n        0.5,\n        0.75,\n        0.5\n      ]\n    },\n    {\n      \"NAME\": \"inputRate\",\n      \"LABEL\": \"Buffer Lag\",\n      \"TYPE\": \"float\",\n      \"MIN\": 1,\n      \"MAX\": 20,\n      \"DEFAULT\": 4\n    },\n    {\n      \"NAME\": \"glitch_size\",\n      \"LABEL\": \"Size\",\n      \"TYPE\": \"float\",\n      \"MIN\": 0,\n      \"MAX\": 0.5,\n      \"DEFAULT\": 0.1\n    },\n    {\n      \"NAME\": \"glitch_horizontal\",\n      \"LABEL\": \"Horizontal Amount\",\n      \"TYPE\": \"float\",\n      \"MIN\": 0,\n      \"MAX\": 1,\n      \"DEFAULT\": 0.2\n    },\n    {\n      \"NAME\": \"glitch_vertical\",\n      \"LABEL\": \"Vertical Amount\",\n      \"TYPE\": \"float\",\n      \"MIN\": 0,\n      \"MAX\": 1,\n      \"DEFAULT\": 0\n    },\n    {\n      \"NAME\": \"randomize_size\",\n      \"LABEL\": \"Randomize Size\",\n      \"TYPE\": \"bool\",\n      \"DEFAULT\": 1\n    },\n    {\n      \"NAME\": \"randomize_position\",\n      \"LABEL\": \"Randomize Position\",\n      \"TYPE\": \"bool\",\n      \"DEFAULT\": 0\n    },\n    {\n      \"NAME\": \"randomize_zoom\",\n      \"LABEL\": \"Randomize Zoom\",\n      \"TYPE\": \"bool\",\n      \"DEFAULT\": 0\n    }\n  ],\n  \"PASSES\": [\n    {\n      \"TARGET\": \"lastRow\",\n      \"WIDTH:\": 1,\n      \"HEIGHT\": 1,\n      \"DESCRIPTION\": \"this buffer stores the last frame's odd / even state\",\n      \"persistent\": true\n    },\n    {\n      \"TARGET\": \"buffer8\",\n      \"persistent\": true\n    },\n    {\n      \"TARGET\": \"buffer7\",\n      \"persistent\": true\n    },\n    {\n      \"TARGET\": \"buffer6\",\n      \"persistent\": true\n    },\n    {\n      \"TARGET\": \"buffer5\",\n      \"persistent\": true\n    },\n    {\n      \"TARGET\": \"buffer4\",\n      \"persistent\": true\n    },\n    {\n      \"TARGET\": \"buffer3\",\n      \"persistent\": true\n    },\n    {\n      \"TARGET\": \"buffer2\",\n      \"persistent\": true\n    },\n    {\n      \"TARGET\": \"buffer1\",\n      \"persistent\": true\n    },\n    {}\n  ]\n}*/\r\n\r\n\r\nfloat rand(vec2 co){\r\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\r\n}\r\n\r\n\r\nvoid main()\r\n{\r\n\t//\tfirst pass: read the \"buffer7\" into \"buffer8\"\r\n\t//\tapply lag on each pass\r\n\t//\tif this is the first pass, i'm going to read the position from the \"lastRow\" image, and write a new position based on this and the hold variables\r\n\tif (PASSINDEX == 0)\t{\r\n\t\tvec4\t\tsrcPixel = IMG_PIXEL(lastRow,vec2(0.5));\r\n\t\t//\ti'm only using the X and Y components, which are the X and Y offset (normalized) for the frame\r\n\t\tif (inputRate == 0.0)\t{\r\n\t\t\tsrcPixel.x = 0.0;\r\n\t\t\tsrcPixel.y = 0.0;\r\n\t\t}\r\n\t\telse if (inputRate <= 1.0)\t{\r\n\t\t\tsrcPixel.x = (srcPixel.x) > 0.5 ? 0.0 : 1.0;\r\n\t\t\tsrcPixel.y = 0.0;\r\n\t\t}\r\n\t\telse {\r\n\t\t\tsrcPixel.x = srcPixel.x + 1.0 / inputRate + srcPixel.y;\r\n\t\t\tif (srcPixel.x > 1.0)\t{\r\n\t\t\t\tsrcPixel.y = mod(srcPixel.x, 1.0);\r\n\t\t\t\tsrcPixel.x = 0.0;\r\n\t\t\t}\r\n\t\t}\r\n\t\tgl_FragColor = srcPixel;\r\n\t}\r\n\tif (PASSINDEX == 1)\t{\r\n\t\tvec4\t\tlastRow = IMG_PIXEL(lastRow,vec2(0.5));\r\n\t\tif (lastRow.x == 0.0)\t{\r\n\t\t\tgl_FragColor = IMG_THIS_NORM_PIXEL(buffer7);\r\n\t\t}\r\n\t\telse\t{\r\n\t\t\tgl_FragColor = IMG_THIS_NORM_PIXEL(buffer8);\r\n\t\t}\r\n\t}\r\n\telse if (PASSINDEX == 2)\t{\r\n\t\tvec4\t\tlastRow = IMG_PIXEL(lastRow,vec2(0.5));\r\n\t\tif (lastRow.x == 0.0)\t{\r\n\t\t\tgl_FragColor = IMG_THIS_NORM_PIXEL(buffer6);\r\n\t\t}\r\n\t\telse\t{\r\n\t\t\tgl_FragColor = IMG_THIS_NORM_PIXEL(buffer7);\r\n\t\t}\r\n\t}\r\n\telse if (PASSINDEX == 3)\t{\r\n\t\tvec4\t\tlastRow = IMG_PIXEL(lastRow,vec2(0.5));\r\n\t\tif (lastRow.x == 0.0)\t{\r\n\t\t\tgl_FragColor = IMG_THIS_NORM_PIXEL(buffer5);\r\n\t\t}\r\n\t\telse\t{\r\n\t\t\tgl_FragColor = IMG_THIS_NORM_PIXEL(buffer6);\r\n\t\t}\r\n\t}\r\n\telse if (PASSINDEX == 4)\t{\r\n\t\tvec4\t\tlastRow = IMG_PIXEL(lastRow,vec2(0.5));\r\n\t\tif (lastRow.x == 0.0)\t{\r\n\t\t\tgl_FragColor = IMG_THIS_NORM_PIXEL(buffer4);\r\n\t\t}\r\n\t\telse\t{\r\n\t\t\tgl_FragColor = IMG_THIS_NORM_PIXEL(buffer5);\r\n\t\t}\r\n\t}\r\n\telse if (PASSINDEX == 5)\t{\r\n\t\tvec4\t\tlastRow = IMG_PIXEL(lastRow,vec2(0.5));\r\n\t\tif (lastRow.x == 0.0)\t{\r\n\t\t\tgl_FragColor = IMG_THIS_NORM_PIXEL(buffer3);\r\n\t\t}\r\n\t\telse\t{\r\n\t\t\tgl_FragColor = IMG_THIS_NORM_PIXEL(buffer4);\r\n\t\t}\r\n\t}\r\n\telse if (PASSINDEX == 6)\t{\r\n\t\tvec4\t\tlastRow = IMG_PIXEL(lastRow,vec2(0.5));\r\n\t\tif (lastRow.x == 0.0)\t{\r\n\t\t\tgl_FragColor = IMG_THIS_NORM_PIXEL(buffer2);\r\n\t\t}\r\n\t\telse\t{\r\n\t\t\tgl_FragColor = IMG_THIS_NORM_PIXEL(buffer3);\r\n\t\t}\r\n\t}\r\n\telse if (PASSINDEX == 7)\t{\r\n\t\tvec4\t\tlastRow = IMG_PIXEL(lastRow,vec2(0.5));\r\n\t\tif (lastRow.x == 0.0)\t{\r\n\t\t\tgl_FragColor = IMG_THIS_NORM_PIXEL(buffer1);\r\n\t\t}\r\n\t\telse\t{\r\n\t\t\tgl_FragColor = IMG_THIS_NORM_PIXEL(buffer2);\r\n\t\t}\r\n\t}\r\n\telse if (PASSINDEX == 8)\t{\r\n\t\tvec4\t\tlastRow = IMG_PIXEL(lastRow,vec2(0.5));\r\n\t\tif (lastRow.x == 0.0)\t{\r\n\t\t\tgl_FragColor = IMG_THIS_NORM_PIXEL(inputImage);\r\n\t\t}\r\n\t\telse\t{\r\n\t\t\tgl_FragColor = IMG_THIS_NORM_PIXEL(buffer1);\r\n\t\t}\r\n\t}\r\n\telse if (PASSINDEX == 9)\t{\r\n\t\t//\tFigure out which section I'm in and draw the appropriate buffer there\r\n\t\tvec2 tex = isf_FragNormCoord;\r\n\t\tvec4 color = vec4(0.0);\t\t\r\n\t\t//\tfigure out the \"input delay shift\" for this pixel...\r\n\t\tfloat randomDelayShift = 0.0;\r\n\t\t\r\n\t\tvec2 xy; \r\n\t\txy.x = isf_FragNormCoord[0];\r\n\t\txy.y = isf_FragNormCoord[1];\r\n\t\r\n\t\t//\tquantize the xy to the glitch_amount size\r\n\t\t//xy = floor(xy / glitch_size) * glitch_size;\r\n\t\tvec2 random;\r\n\r\n\t\tfloat local_glitch_size = glitch_size;\r\n\t\tfloat random_offset = 0.0;\r\n\t\r\n\t\tif (randomize_size)\t{\r\n\t\t\trandom_offset = mod(rand(vec2(TIME,TIME)), 1.0);\r\n\t\t\tlocal_glitch_size = random_offset * glitch_size;\r\n\t\t}\r\n\t\r\n\t\tif (local_glitch_size > 0.0)\t{\r\n\t\t\trandom.x = rand(vec2(floor(random_offset + xy.y / local_glitch_size) * local_glitch_size, TIME));\r\n\t\t\trandom.y = rand(vec2(floor(random_offset + xy.x / local_glitch_size) * local_glitch_size, TIME));\r\n\t\t}\r\n\t\telse\t{\r\n\t\t\trandom.x = rand(vec2(xy.x, TIME));\r\n\t\t\trandom.y = rand(vec2(xy.y, TIME));\r\n\t\t}\r\n\t\r\n\t\t//\tif doing a horizontal glitch do a random shift\r\n\t\tif ((random.x < glitch_horizontal)&&(random.y < glitch_vertical))\t{\r\n\t\t\trandomDelayShift = clamp(random.x + random.y, 0.0, 2.0);\r\n\t\t}\r\n\t\telse if (random.x < glitch_horizontal)\t{\r\n\t\t\trandomDelayShift = clamp(random.x + random.y, 0.0, 2.0);\r\n\t\t}\r\n\t\telse if (random.y < glitch_vertical)\t{\r\n\t\t\trandomDelayShift = clamp(random.x + random.y, 0.0, 2.0);\r\n\t\t}\r\n\t\t\r\n\t\tvec4 pixelBuffer = randomDelayShift * inputDelay * 9.0;\r\n\t\t\r\n\t\tif (randomize_zoom)\t{\r\n\t\t\tif ((random.x < glitch_horizontal)&&(random.y < glitch_vertical))\t{\r\n\t\t\t\tfloat level = (random.x + random.y) / 3.0 + 0.90;\r\n\t\t\t\ttex = (tex - vec2(0.5))*(1.0/level) + vec2(0.5);\r\n\t\t\t}\r\n\t\t\telse if (random.x < glitch_horizontal)\t{\r\n\t\t\t\tfloat level = (random.x) / 2.0 + 0.95;\r\n\t\t\t\ttex = (tex - vec2(0.5))*(1.0/level) + vec2(0.5);\r\n\t\t\t}\r\n\t\t\telse if (random.y < glitch_vertical)\t{\r\n\t\t\t\tfloat level = (random.y) / 2.0 + 0.95;\r\n\t\t\t\ttex = (tex - vec2(0.5))*(1.0/level) + vec2(0.5);\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\tif (randomize_position)\t{\r\n\t\t\tif ((random.x < glitch_horizontal)&&(random.y < glitch_vertical))\t{\r\n\t\t\t\ttex.x = mod(tex.x + inputDelay.r * random.x, 1.0);\r\n\t\t\t\ttex.y = mod(tex.y + inputDelay.r * random.y, 1.0);\r\n\t\t\t}\r\n\t\t\telse if (random.x < glitch_horizontal)\t{\r\n\t\t\t\ttex.y = mod(tex.y + inputDelay.r * random.x, 1.0);\r\n\t\t\t}\r\n\t\t\telse if (random.y < glitch_vertical)\t{\r\n\t\t\t\ttex.x = mod(tex.x + inputDelay.r * random.y, 1.0);\r\n\t\t\t}\r\n\t\t\t//\tapply small random zoom too\r\n\t\t}\r\n\t\t\r\n\t\tif (pixelBuffer.r < 1.0)\t{\r\n\t\t\tcolor.r = IMG_NORM_PIXEL(inputImage, tex).r;\r\n\t\t}\r\n\t\telse if (pixelBuffer.r < 2.0)\t{\r\n\t\t\tcolor.r = IMG_NORM_PIXEL(buffer1, tex).r;\r\n\t\t}\r\n\t\telse if (pixelBuffer.r < 3.0)\t{\r\n\t\t\tcolor.r = IMG_NORM_PIXEL(buffer2, tex).r;\r\n\t\t}\r\n\t\telse if (pixelBuffer.r < 4.0)\t{\r\n\t\t\tcolor.r = IMG_NORM_PIXEL(buffer3, tex).r;\r\n\t\t}\r\n\t\telse if (pixelBuffer.r < 5.0)\t{\r\n\t\t\tcolor.r = IMG_NORM_PIXEL(buffer4, tex).r;\r\n\t\t}\r\n\t\telse if (pixelBuffer.r < 6.0)\t{\r\n\t\t\tcolor.r = IMG_NORM_PIXEL(buffer5, tex).r;\r\n\t\t}\r\n\t\telse if (pixelBuffer.r < 7.0)\t{\r\n\t\t\tcolor.r = IMG_NORM_PIXEL(buffer6, tex).r;\r\n\t\t}\r\n\t\telse if (pixelBuffer.r < 8.0)\t{\r\n\t\t\tcolor.r = IMG_NORM_PIXEL(buffer7, tex).r;\r\n\t\t}\r\n\t\telse\t{\r\n\t\t\tcolor.r = IMG_NORM_PIXEL(buffer8, tex).r;\r\n\t\t}\r\n\t\t\r\n\t\tif (randomize_position)\t{\r\n\t\t\tif ((random.x < glitch_horizontal)&&(random.y < glitch_vertical))\t{\r\n\t\t\t\ttex.x = mod(tex.x + random.x * inputDelay.g, 1.0);\r\n\t\t\t\ttex.y = mod(tex.y + random.y * inputDelay.g, 1.0);\r\n\t\t\t}\r\n\t\t\telse if (random.x < glitch_horizontal)\t{\r\n\t\t\t\ttex.y = mod(tex.y + random.x * inputDelay.g, 1.0);\r\n\t\t\t}\r\n\t\t\telse if (random.y < glitch_vertical)\t{\r\n\t\t\t\ttex.x = mod(tex.x + random.y * inputDelay.g, 1.0);\r\n\t\t\t}\r\n\t\t\t//\tapply small random zoom too\r\n\t\t\t//float level = inputDelay.g * random.x / 5.0 + 0.9;\r\n\t\t\t//tex = (tex - vec2(0.5))*(1.0/level) + vec2(0.5);\r\n\t\t}\r\n\t\t\r\n\t\tif (pixelBuffer.g < 1.0)\t{\r\n\t\t\tcolor.g = IMG_NORM_PIXEL(inputImage, tex).g;\r\n\t\t}\r\n\t\telse if (pixelBuffer.g < 2.0)\t{\r\n\t\t\tcolor.g = IMG_NORM_PIXEL(buffer1, tex).g;\r\n\t\t}\r\n\t\telse if (pixelBuffer.g < 3.0)\t{\r\n\t\t\tcolor.g = IMG_NORM_PIXEL(buffer2, tex).g;\r\n\t\t}\r\n\t\telse if (pixelBuffer.g < 4.0)\t{\r\n\t\t\tcolor.g = IMG_NORM_PIXEL(buffer3, tex).g;\r\n\t\t}\r\n\t\telse if (pixelBuffer.g < 5.0)\t{\r\n\t\t\tcolor.g = IMG_NORM_PIXEL(buffer4, tex).g;\r\n\t\t}\r\n\t\telse if (pixelBuffer.g < 6.0)\t{\r\n\t\t\tcolor.g = IMG_NORM_PIXEL(buffer5, tex).g;\r\n\t\t}\r\n\t\telse if (pixelBuffer.g < 7.0)\t{\r\n\t\t\tcolor.g = IMG_NORM_PIXEL(buffer6, tex).g;\r\n\t\t}\r\n\t\telse if (pixelBuffer.g < 8.0)\t{\r\n\t\t\tcolor.g = IMG_NORM_PIXEL(buffer7, tex).g;\r\n\t\t}\r\n\t\telse\t{\r\n\t\t\tcolor.g = IMG_NORM_PIXEL(buffer8, tex).g;\r\n\t\t}\r\n\t\t\r\n\t\tif (randomize_position)\t{\r\n\t\t\tif ((random.x < glitch_horizontal)&&(random.y < glitch_vertical))\t{\r\n\t\t\t\ttex.x = mod(tex.x + random.x * inputDelay.b, 1.0);\r\n\t\t\t\ttex.y = mod(tex.y + random.y * inputDelay.b, 1.0);\r\n\t\t\t}\r\n\t\t\telse if (random.x < glitch_horizontal)\t{\r\n\t\t\t\ttex.y = mod(tex.y + random.x * inputDelay.b, 1.0);\r\n\t\t\t}\r\n\t\t\telse if (random.y < glitch_vertical)\t{\r\n\t\t\t\ttex.x = mod(tex.x + random.y * inputDelay.b, 1.0);\r\n\t\t\t}\r\n\t\t\t//\tapply small random zoom too\r\n\t\t\t//float level = inputDelay.b * random.x / 5.0 + 0.9;\r\n\t\t\t//tex = (tex - vec2(0.5))*(1.0/level) + vec2(0.5);\r\n\t\t}\r\n\t\t\r\n\t\tif (pixelBuffer.b < 1.0)\t{\r\n\t\t\tcolor.b = IMG_NORM_PIXEL(inputImage, tex).b;\r\n\t\t}\r\n\t\telse if (pixelBuffer.b < 2.0)\t{\r\n\t\t\tcolor.b = IMG_NORM_PIXEL(buffer1, tex).b;\r\n\t\t}\r\n\t\telse if (pixelBuffer.b < 3.0)\t{\r\n\t\t\tcolor.b = IMG_NORM_PIXEL(buffer2, tex).b;\r\n\t\t}\r\n\t\telse if (pixelBuffer.b < 4.0)\t{\r\n\t\t\tcolor.b = IMG_NORM_PIXEL(buffer3, tex).b;\r\n\t\t}\r\n\t\telse if (pixelBuffer.b < 5.0)\t{\r\n\t\t\tcolor.b = IMG_NORM_PIXEL(buffer4, tex).b;\r\n\t\t}\r\n\t\telse if (pixelBuffer.b < 6.0)\t{\r\n\t\t\tcolor.b = IMG_NORM_PIXEL(buffer5, tex).b;\r\n\t\t}\r\n\t\telse if (pixelBuffer.b < 7.0)\t{\r\n\t\t\tcolor.b = IMG_NORM_PIXEL(buffer6, tex).b;\r\n\t\t}\r\n\t\telse if (pixelBuffer.b < 8.0)\t{\r\n\t\t\tcolor.b = IMG_NORM_PIXEL(buffer7, tex).b;\r\n\t\t}\r\n\t\telse\t{\r\n\t\t\tcolor.b = IMG_NORM_PIXEL(buffer8, tex).b;\r\n\t\t}\r\n\t\t\r\n\t\tif (randomize_position)\t{\r\n\t\t\tif ((random.x < glitch_horizontal)&&(random.y < glitch_vertical))\t{\r\n\t\t\t\ttex.x = mod(tex.x + random.x * inputDelay.a, 1.0);\r\n\t\t\t\ttex.y = mod(tex.y + random.y * inputDelay.a, 1.0);\r\n\t\t\t}\r\n\t\t\telse if (random.x < glitch_horizontal)\t{\r\n\t\t\t\ttex.y = mod(tex.y + random.x * inputDelay.a, 1.0);\r\n\t\t\t}\r\n\t\t\telse if (random.y < glitch_vertical)\t{\r\n\t\t\t\ttex.x = mod(tex.x + random.y * inputDelay.a, 1.0);\r\n\t\t\t}\r\n\t\t\t//\tapply small random zoom too\r\n\t\t\t//float level = inputDelay.a * random.x / 5.0 + 0.9;\r\n\t\t\t//tex = (tex - vec2(0.5))*(1.0/level) + vec2(0.5);\r\n\t\t}\r\n\t\t\r\n\t\tif (pixelBuffer.a < 1.0)\t{\r\n\t\t\tcolor.a = IMG_NORM_PIXEL(inputImage, tex).a;\r\n\t\t}\r\n\t\telse if (pixelBuffer.a < 2.0)\t{\r\n\t\t\tcolor.a = IMG_NORM_PIXEL(buffer1, tex).a;\r\n\t\t}\r\n\t\telse if (pixelBuffer.a < 3.0)\t{\r\n\t\t\tcolor.a = IMG_NORM_PIXEL(buffer2, tex).a;\r\n\t\t}\r\n\t\telse if (pixelBuffer.a < 4.0)\t{\r\n\t\t\tcolor.a = IMG_NORM_PIXEL(buffer3, tex).a;\r\n\t\t}\r\n\t\telse if (pixelBuffer.a < 5.0)\t{\r\n\t\t\tcolor.a = IMG_NORM_PIXEL(buffer4, tex).a;\r\n\t\t}\r\n\t\telse if (pixelBuffer.a < 6.0)\t{\r\n\t\t\tcolor.a = IMG_NORM_PIXEL(buffer5, tex).a;\r\n\t\t}\r\n\t\telse if (pixelBuffer.a < 7.0)\t{\r\n\t\t\tcolor.a = IMG_NORM_PIXEL(buffer6, tex).a;\r\n\t\t}\r\n\t\telse if (pixelBuffer.a < 8.0)\t{\r\n\t\t\tcolor.a = IMG_NORM_PIXEL(buffer7, tex).a;\r\n\t\t}\r\n\t\telse\t{\r\n\t\t\tcolor.a = IMG_NORM_PIXEL(buffer8, tex).a;\r\n\t\t}\r\n\r\n\t\tgl_FragColor = color;\r\n\t}\r\n}\r\n","rawVertexSource":"void main() {\n\tisf_vertShaderInit();\n}","thumbnailCloudinaryId":"irew0f2ftbcxaf1hsj1y","description":"Buffers 8 recent frames","shaderType":"filter","oldId":"260","createdAt":"2015-01-07T00:27:11.609Z","user":{"_id":"5e7a7f587c113618206dda00","username":"VIDVOX","name":"VIDVOX","id":"5e7a7f587c113618206dda00"},"username":"VIDVOX","updatedAt":"2026-02-17T03:39:33.896Z","__v":5,"id":"5e7a80247c113618206deb8a"},{"working":false,"featured":false,"private":false,"stars":["5ed0ebda9a2c7b001769388c","5e7a7f587c113618206ddcb3","5f1e70eb0c6c470015d2fe9b","5f2026dab1ed0d0014c0001b","5f36d4cfb1ed0d0014c00034","5f51a9cbb1ed0d0014c0006d","5f1b196b0c6c470015d2fe97","5f5832d0b1ed0d0014c0007c","5fb19e65d4849b0013135bc0","5e95ee42658b34001590fdaa","5fd09f0ddf59c70014cdc4ce","5fd1aa1edf59c70014cdc4d5","5eb535c09a2c7b0017693822","5fd38820d4849b0013135c04","5fdd427bdf59c70014cdc4e3","6015030ad4849b0013135c5d","6048db34df59c70014cdc5f7","605dfe63df59c70014cdc640","6063c67cd4849b0013135d82","5e7a7f587c113618206ddd6e","60770f22d4849b0013135db0","606bd908d4849b0013135d96","60a8241ad4849b0013135e06","60ddce08f4fe08001a0a6204","60e327c2063978001a1c6e9a","60fc3522f4fe08001a0a6227","60f5267ff4fe08001a0a6216","60f5267ff4fe08001a0a6216","6106ce09f4fe08001a0a6237","61240672063978001a1c6ef6","61559c2ef4fe08001a0a62a7","617581b3f4fe08001a0a62d7","61777b48063978001a1c6f66","617bd2eaf4fe08001a0a62df","617c6247f4fe08001a0a62e0","61a2f481f4fe08001a0a6311","61d5b38dfa146100147e1e78","5e7a7f587c113618206ddbc2","61f1cbcbfa146100147fda16","61f46a297917e4001403e9b3","6053a3ecdf59c70014cdc627","6203859f7917e400140500ca","5fe16ce0d4849b0013135c19","6210fae67917e4001405d5db","62285666fa14610014830c80","622f7dbd7917e40014074c6a","6231d615fa146100148377ef","625d52557917e400140a305a","620e20b37917e40014059f3f","626c5a08fa14610014874a32","62756dfbcbcd96001965fecf","62763b57ad0a68001af3eb12","628b4fdbcbcd9600196739e1","628e1d64cbcd960019675fae","62ae22fdad0a68001af6d21b","62b705a6ad0a68001af7395f","62bf841ead0a68001af7c580","5f60c298b1ed0d0014c00087","62c5b835ad0a68001af80048","62da707fad0a68001af8d8e5","6079af02d4849b0013135db3","62fb14f2ad0a68001afa532a","62fba7a8ad0a68001afa5860","62dea623ad0a68001af90e82","63139741d12ead001af40056","63225a4fd12ead001af4e36f","633167e0d12ead001af5960f","61a4e7fcf4fe08001a0a6314","634cce2dc0b6ee001abcb586","635835bad12ead001af80602","635e4533d12ead001af86e66","63628b5ad12ead001af8a325","639ca606d12ead001afc7798","639eeb9224251a001ac05e9f","63aa4ea4d12ead001afd5415","63bbed9bd12ead001afe55c1","63be24e9d12ead001afe7544","63bea62bd12ead001afe79cb","5e7a7f587c113618206ddd52","63c2e7fcd12ead001afeaab1","63bd87c024251a001ac23868","63bdfee1d12ead001afe71e4","63eb647954062a0019bbddce","642c522f54062a0019c045b1","6356d754d12ead001af7f0b5","6331d80ed12ead001af59b4b","63a4715d24251a001ac0e3ab","649caa135913c5001a3e6b13","64b68d235913c5001a3f7954","64b73f87073c7a001a88412a","64bbf2515913c5001a3faeee","64bd20875913c5001a3fbf68","63f2ca6454062a0019bc525e","5f1054c6b1ed0d0014c00006","64d504174fca60001ab92f87","64edaefa4fca60001aba9ab2","5f5a4d6d0c6c470015d2fef0","5fd4f460df59c70014cdc4da","65045b934fca60001abbefe8","65066e9d388bc0001a19a4a5","652c4de2f4fa87001b377518","654192ed85611d001aee761e","654a3574f4fa87001b38c9d9","65616a8b85611d001af048fa","65641c6685611d001af06526","655ed7c385611d001af0193d","657d8155fe89e9001a1f663a","62221c907917e40014067e8c","6590bace85611d001af342b0","656ad4dcf4fa87001b3b1ab2","65b151d285611d001af4f995","65e7980b9f12c7001aeaaf4d","661c08a4b9e5d4001a98ce20","663c2da8f348b4001986c136","659684cc85611d001af37d51","664c8791d15e30001b9f4a17","667a52ebbe01f9001aa1d3d5","667c1117be01f9001aa223e7","6689c6f4ad5cac00198432e7","666c6de8e0ca9e001a0299a8","66c608f58d90c9001a49d36e","66d0b5cc604947001962ce94","66dd863b8d90c9001a4b8451","66ddb4718d90c9001a4b8545","66c6d3938d90c9001a49dfdd","668ea37fad5cac001984692f","6602e9a874e2f0001ab5ac82","6730190ba085a6001a5b95c1","673a31fca085a6001a5c4520","673c09afa085a6001a5c5ef1","6749918f7c51b3001a5274bc","674ed13aa085a6001a5e3cb6","676ee5a6726a2e001aa7de18","678e5f332909a9001a02a0d1","678d2f6b2909a9001a029147","679021ca2909a9001a02bd9c","67c3679c63819f001a74d597","5e7a7f587c113618206ddadd","67dcc27fd7aebf0019e2b41b","67e5f75ed7aebf0019e3689f","68024504afd915001ad52769","680f414ce487fa001ab13dd9","681be5065d14de001ac4ac94","681fbddf932476001a377c1e","683186b3932476001a385c59","684aa36c932476001a39986b","685a1580932476001a3a61d0","685d739e932476001a3aa285","689bec213bc53b001a4e30dd","68a1fb4c3bc53b001a4ea8f1","68a1fb4c3bc53b001a4ea8f1","68a3a4903bc53b001a4eca8f","68bf75dfabb222001a410fc5","68ce569fabb222001a42502e","68d1a7263bc53b001a525516","68dab506b503bb001a9bd691","6900c7492173f0001a8b385c","6908c7552173f0001a8c1156","690889cc2173f0001a8c0ca1","691b542c66081f001a4b7d99","6762ee42970727001971970b","691eba3e9fa0ee001aa4f2fe","67cce0ef63819f001a755da6","6934861a276171001a4a0d20","696766c27faa73001a33cf18","696fe5917faa73001a3615b0","6973db2580748c001a8a5e32","697528c57faa73001a36ebbc","698c1079547ea0001a4b9847","6993df3cb04833001acf53c6"],"images":[],"categories":["5ece89d09a2c7b0017693883","5e7a80dd7c113618206df0ee","5f9886f9d4849b0013135ba3","5e7a80dd7c113618206df0b2","5e7a80de7c113618206df1d4"],"publicCategories":["Distortion Effect"],"privateCategories":["white","Warp","Black White","black"],"_id":"5ec156239a2c7b001769385f","title":"black hole sun","rawFragmentSource":"/*\n {\n  \"DESCRIPTION\": \"black hole sun\",\n  \"CREDIT\": \"Andrea Bovo <https://linktr.ee/spleenooname>\", \n  \"CATEGORIES\": [\n    \"Distortion Effect\",\n    \"Warp\",\n    \"Black White\",\n    \"black\",\n    \"white\"\n  ],\n  \"INPUTS\": [\n    {\n      \"NAME\": \"brightness\",\n      \"TYPE\": \"float\",\n      \"DEFAULT\": 4,\n      \"MIN\": 0,\n      \"MAX\": 5\n    },\n    {\n      \"NAME\": \"ray_brightness\",\n      \"TYPE\": \"float\",\n      \"DEFAULT\": 2.5,\n      \"MIN\": 0,\n      \"MAX\": 10\n    },\n \n    {\n      \"NAME\": \"spot_brightness\",\n      \"TYPE\": \"float\",\n      \"DEFAULT\": 15,\n      \"MIN\": -15,\n      \"MAX\": 15\n    },\n    {\n      \"NAME\": \"ray_density\",\n      \"TYPE\": \"float\",\n      \"DEFAULT\": 12,\n      \"MIN\": 0,\n      \"MAX\": 100\n    },\n    {\n      \"NAME\": \"curvature\",\n      \"TYPE\": \"float\",\n      \"DEFAULT\": 300,\n      \"MIN\": 1,\n      \"MAX\": 1080\n    },\n    {\n      \"NAME\": \"angle\",\n      \"TYPE\": \"float\",\n      \"DEFAULT\": 0.5,\n      \"MIN\": 0,\n      \"MAX\": 2\n    },\n    {\n      \"NAME\": \"freq\",\n      \"TYPE\": \"float\",\n      \"DEFAULT\": 5,\n      \"MIN\": 1,\n      \"MAX\": 10\n    },\n    {\n      \"NAME\": \"warp\",\n      \"TYPE\": \"bool\",\n      \"DEFAULT\": 1\n    }\n  ]\n}*/\n\n// based on : Flaring by nimitz - https://www.shadertoy.com/view/lsSGzy\n\n#define time TIME\n#define R RENDERSIZE\n\n// Gradient noise by iq - https://www.shadertoy.com/view/XdXGW8\nvec2 hash( vec2 x )  {\n    const vec2 k = vec2( 0.3183099, 0.3678794 );\n    x = x*k + k.yx;\n    return -1.0 + 2.0*fract( 64.0 * k*fract( x.x*x.y*(x.x+x.y)) );\n}\n\nfloat noise( in vec2 p ){\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\tvec2 u = f*f*(3.0-2.0*f);\n    return mix( mix( dot( hash( i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ), \n                     dot( hash( i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( hash( i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ), \n                     dot( hash( i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\n\n\nmat2 rot2d( float angle ) {\n\tfloat s = sin(angle);\n\tfloat c = cos(angle);\n    return mat2(c, -s, s, c);\n}\n\n#define OCTAVES 6\nfloat fbm( in vec2 p, in float freq ){\t\n\tfloat z = 1.;\n    float rz = 0.;\n\tp *= 0.25;\n\tmat2 mrot = rot2d( angle );\n\tfor (int i= 1;i < OCTAVES;i++ ){\n\t\trz += (sin(noise(p) * freq) * 0.5 + 0.5 ) / (z + time * 0.001);\n\t\tz *= 1.75; \n\t\tp *= 2.;\n\t\tp *= mrot;\n\t}\n\treturn rz;\n}\n\nvoid main(){\n    //\n\tfloat t = time * 0.025;\n\t// thx Fabrice\n\tvec2 uv =  ( 2. * gl_FragCoord.xy - R ) / min(R.x,R.y);\n\t\n\tuv *= curvature * 5e-2;\n\t\n\tfloat r = sqrt( dot(uv, uv) );\n\tfloat x = dot( normalize(uv), vec2(.5, 0.) ) + t;\t\n\tfloat y = dot (normalize(uv), vec2(.0, .5) ) + t;\n\t\n\tif (warp) {\n\t  float d = ray_density * .5;\n\t  x = fbm( vec2( y * d, r + x * d), freq );\n\t  y = fbm( vec2( r + y * d, x * d ), freq );\n\t}\n\n    float val = fbm( vec2(r + y * ray_density, r + x * ray_density - y), freq);\n     \n\tval = smoothstep( 0., ray_brightness, val);\n\t\n\tvec3 col = clamp( 1.- vec3(val), 0., 1.);\n\t\n\tcol = mix(col, vec3(1.0), spot_brightness - 10.* r/curvature * 200./brightness);\n\t\n\tgl_FragColor = sqrt(vec4(col, 1.0));\n}","rawVertexSource":"void main() {\n\tisf_vertShaderInit();\n}","description":"black hole sun","shaderType":"generator","forkedFrom":"5e7a7fcf7c113618206de4cb","user":{"_id":"5e7a7f587c113618206ddbc2","username":"spleennooname","name":"Andrea Bovo","id":"5e7a7f587c113618206ddbc2"},"username":"spleennooname","createdAt":"2020-05-17T15:20:03.508Z","updatedAt":"2026-02-17T03:32:38.895Z","__v":93,"thumbnailCloudinaryId":"oiinwiullgb71qev42k1","scale":1,"id":"5ec156239a2c7b001769385f"}]